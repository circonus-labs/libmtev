
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Lua API Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-callouts/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="c.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Mount Everest</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../config/">
            
                <a href="../config/">
            
                    
                    Configuration
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../config/inherit.html">
            
                <a href="../config/inherit.html">
            
                    
                    Inheritance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../config/includes.html">
            
                <a href="../config/includes.html">
            
                    
                    Includes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../config/watchdog.html">
            
                <a href="../config/watchdog.html">
            
                    
                    Watchdog
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../config/managed.html">
            
                <a href="../config/managed.html">
            
                    
                    Managed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../config/eventer.html">
            
                <a href="../config/eventer.html">
            
                    
                    Eventer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../config/logging.html">
            
                <a href="../config/logging.html">
            
                    
                    Logging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../config/listeners.html">
            
                <a href="../config/listeners.html">
            
                    
                    Listeners
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../config/modules.html">
            
                <a href="../config/modules.html">
            
                    
                    Modules
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.8.1" data-path="../config/modules/amqp.html">
            
                <a href="../config/modules/amqp.html">
            
                    
                    amqp
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.2" data-path="../config/modules/consul.html">
            
                <a href="../config/modules/consul.html">
            
                    
                    consul
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.3" data-path="../config/modules/fq.html">
            
                <a href="../config/modules/fq.html">
            
                    
                    fq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.4" data-path="../config/modules/http_hmac_cookie.html">
            
                <a href="../config/modules/http_hmac_cookie.html">
            
                    
                    http_hmac_cookie
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.5" data-path="../config/modules/http_observer.html">
            
                <a href="../config/modules/http_observer.html">
            
                    
                    http_observer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.6" data-path="../config/modules/lua_general.html">
            
                <a href="../config/modules/lua_general.html">
            
                    
                    lua_general
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.7" data-path="../config/modules/lua_web.html">
            
                <a href="../config/modules/lua_web.html">
            
                    
                    lua_web
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.8" data-path="../config/modules/zipkin_fq.html">
            
                <a href="../config/modules/zipkin_fq.html">
            
                    
                    zipkin_fq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.9" data-path="../config/modules/zipkin_jaeger.html">
            
                <a href="../config/modules/zipkin_jaeger.html">
            
                    
                    zipkin_jaeger
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="../config/time_durations.html">
            
                <a href="../config/time_durations.html">
            
                    
                    Time Durations
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../development/">
            
                <a href="../development/">
            
                    
                    Development
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../development/important.html">
            
                <a href="../development/important.html">
            
                    
                    Important Starting Notes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../development/mtev_main.html">
            
                <a href="../development/mtev_main.html">
            
                    
                    mtev_main
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../development/eventer.html">
            
                <a href="../development/eventer.html">
            
                    
                    Eventer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../development/eventer-aco.html">
            
                <a href="../development/eventer-aco.html">
            
                    
                    Eventer (ACO)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../development/rest.html">
            
                <a href="../development/rest.html">
            
                    
                    REST and HTTP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../development/logging.html">
            
                <a href="../development/logging.html">
            
                    
                    Logging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../development/hooks.html">
            
                <a href="../development/hooks.html">
            
                    
                    Hooks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../development/jemalloc.html">
            
                <a href="../development/jemalloc.html">
            
                    
                    jemalloc
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../operations/">
            
                <a href="../operations/">
            
                    
                    Operations
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../operations/env.html">
            
                <a href="../operations/env.html">
            
                    
                    Environment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../operations/rest.html">
            
                <a href="../operations/rest.html">
            
                    
                    REST
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../operations/telnet_console.html">
            
                <a href="../operations/telnet_console.html">
            
                    
                    Telnet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../operations/dtrace.html">
            
                <a href="../operations/dtrace.html">
            
                    
                    DTrace
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../luamtev/">
            
                <a href="../luamtev/">
            
                    
                    luamtev
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../mtev-busted/">
            
                <a href="../mtev-busted/">
            
                    
                    mtev-busted
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="./">
            
                <a href="./">
            
                    
                    Reference
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="c.html">
            
                <a href="c.html">
            
                    
                    C API
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.7.2" data-path="lua.html">
            
                <a href="lua.html">
            
                    
                    Lua API
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Lua API</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h3 id="a">A</h3>
<h4 id="mtevapiget">mtev.Api:get</h4>
<blockquote>
<p>Isse a GET request</p>
</blockquote>
<pre><code class="lang-lua">api_response =
mtev.Api:get(path, payload, headers)
</code></pre>
<h4 id="mtevapihttp">mtev.Api:http</h4>
<blockquote>
<p>Wraps an HTTP Api</p>
</blockquote>
<pre><code class="lang-lua">api =
mtev.Api:http(host, port, [headers])
</code></pre>
<p>Example:</p>
<pre><code>local api = mtev.Api:http(host, port, [headers])
local result_text = api:get(&quot;/&quot;):check():text()
local result_table = api:get(&quot;/&quot;):check():json()
</code></pre><h4 id="mtevapihttps">mtev.Api:https</h4>
<blockquote>
<p>Wraps an HTTPS Api</p>
</blockquote>
<pre><code class="lang-lua">api =
mtev.Api:https(host, port, [headers], [sslconfig])
</code></pre>
<h4 id="mtevapipost">mtev.Api:post</h4>
<blockquote>
<p>Issue a POST request</p>
</blockquote>
<pre><code class="lang-lua">api_response =
mtev.Api:post(path, payload, headers)
</code></pre>
<h4 id="mtevapiput">mtev.Api:put</h4>
<blockquote>
<p>Issue a PUT request</p>
</blockquote>
<pre><code class="lang-lua">api_response =
mtev.Api:put(path, payload, headers)
</code></pre>
<h4 id="mtevapirequest">mtev.Api:request</h4>
<blockquote>
<p>Issue a HTTP(S) request</p>
</blockquote>
<pre><code class="lang-lua">api_response =
mtev.Api:request(method, path, payload, [headers])
</code></pre>
<ul>
<li><strong>RETURN</strong> an mtev.ApiResponse object</li>
</ul>
<h4 id="mtevapiresponsecheck">mtev.ApiResponse:check</h4>
<blockquote>
<p>Raise and error unless rc == 200</p>
</blockquote>
<pre><code class="lang-lua">self =
mtev.ApiResponse:check()
</code></pre>
<ul>
<li><strong>RETURN</strong> self</li>
</ul>
<h4 id="mtevapiresponsejson">mtev.ApiResponse:json</h4>
<pre><code class="lang-lua">t =
mtev.ApiResponse:json()
</code></pre>
<ul>
<li><strong>RETURN</strong> parsed payload of response as table t</li>
</ul>
<h4 id="mtevapiresponserc">mtev.ApiResponse:rc</h4>
<pre><code class="lang-lua">rc =
mtev.ApiResponse:rc()
</code></pre>
<h4 id="mtevapiresponsetext">mtev.ApiResponse:text</h4>
<blockquote>
<p>return payload of response as string</p>
</blockquote>
<pre><code class="lang-lua">text =
mtev.ApiResponse:text()
</code></pre>
<h4 id="mtevapiresponsexml">mtev.ApiResponse:xml</h4>
<pre><code class="lang-lua">t =
mtev.ApiResponse:xml()
</code></pre>
<ul>
<li><strong>RETURN</strong> parsed payload of response as table mtev.xmldoc</li>
</ul>
<h3 id="b">B</h3>
<h4 id="mtevbase64decode">mtev.base64_decode</h4>
<pre><code class="lang-lua">mtev.base64_decode()
</code></pre>
<h4 id="mtevbase64encode">mtev.base64_encode</h4>
<pre><code class="lang-lua">mtev.base64_encode()
</code></pre>
<h3 id="c">C</h3>
<h4 id="mtevcancelcoro">mtev.cancel_coro</h4>
<pre><code class="lang-lua">mtev.cancel_coro()
</code></pre>
<h4 id="mtevchmod">mtev.chmod</h4>
<blockquote>
<p>Change the mode of a file.</p>
</blockquote>
<pre><code class="lang-lua">rv =
mtev.chmod(file, mode)
</code></pre>
<ul>
<li><code>file</code> the path to a target file.</li>
<li><code>a</code> new file mode.</li>
<li><strong>RETURN</strong> rv is the return as documented by the <code>chmod</code> libc call.</li>
</ul>
<h4 id="mtevclose">mtev.close</h4>
<blockquote>
<p>Close a file descripto.</p>
</blockquote>
<pre><code class="lang-lua">mtev.close(fd)
</code></pre>
<ul>
<li><code>fd</code> the integer file descriptor to close.</li>
</ul>
<h4 id="mtevcluster">mtev.cluster</h4>
<pre><code class="lang-lua">cluster =
mtev.cluster(name)
</code></pre>
<ul>
<li><code>name</code> name of cluster</li>
<li><strong>RETURN</strong> a cluster object or nil if no cluster of that name is found.</li>
</ul>
<h4 id="mtevconfgetboolean">mtev.conf_get_boolean</h4>
<pre><code class="lang-lua">mtev.conf_get_boolean()
</code></pre>
<h4 id="mtevconfgetfloat">mtev.conf_get_float</h4>
<pre><code class="lang-lua">mtev.conf_get_float()
</code></pre>
<h4 id="mtevconfgetinteger">mtev.conf_get_integer</h4>
<pre><code class="lang-lua">mtev.conf_get_integer()
</code></pre>
<h4 id="mtevconfgetstring">mtev.conf_get_string</h4>
<pre><code class="lang-lua">mtev.conf_get_string()
</code></pre>
<h4 id="mtevconfgetstringlist">mtev.conf_get_string_list</h4>
<pre><code class="lang-lua">mtev.conf_get_string_list()
</code></pre>
<h4 id="mtevconfreplaceboolean">mtev.conf_replace_boolean</h4>
<pre><code class="lang-lua">mtev.conf_replace_boolean()
</code></pre>
<h4 id="mtevconfreplacevalue">mtev.conf_replace_value</h4>
<pre><code class="lang-lua">mtev.conf_replace_value()
</code></pre>
<h3 id="d">D</h3>
<h4 id="mtevdns">mtev.dns</h4>
<blockquote>
<p>Create an <code>mtev.dns</code> object for DNS lookups.</p>
</blockquote>
<pre><code class="lang-lua">mtev.dns =
mtev.dns(nameserver = <span class="hljs-keyword">nil</span>)
</code></pre>
<ul>
<li><code>nameserver</code> an optional argument specifying the nameserver to use.</li>
<li><strong>RETURN</strong> an <code>mtev.dns</code> object.</li>
</ul>
<p>This function creates an <code>mtev.dns</code> object that can be used to perform
lookups and IP address validation.</p>
<h4 id="mtevdnsisvalidip">mtev.dns:is_valid_ip</h4>
<blockquote>
<p>Determine address family of an IP address.</p>
</blockquote>
<pre><code class="lang-lua">bool, family =
mtev.dns:is_valid_ip(ipstr)
</code></pre>
<ul>
<li><code>ipstr</code> a string of an potential IP address.</li>
<li><strong>RETURN</strong> if the address is valid and, if it is, the family.</li>
</ul>
<p>The first return is true if the suplied string is a valid IPv4 or IPv6
address, otherwise false.  If the address is valid, the second argument
will be the address family as an integer, otherwise nil.</p>
<h4 id="mtevdnslookup">mtev.dns:lookup</h4>
<blockquote>
<p>Perform a DNS lookup.</p>
</blockquote>
<pre><code class="lang-lua">record =
mtev.dns:lookup(query, rtype = <span class="hljs-string">&quot;A&quot;</span>, ctype = <span class="hljs-string">&quot;IN&quot;</span>)
</code></pre>
<ul>
<li><code>query</code> a string representing the DNS query.</li>
<li><code>rtype</code> the DNS resource type (default &quot;A&quot;).</li>
<li><code>ctype</code> the DNS class type (default &quot;IN&quot;).</li>
<li><strong>RETURN</strong> a lua table, nil if the lookup fails.</li>
</ul>
<p>DNS lookup works cooperatively with the eventer to schedule an
lookup and yield the current coroutine to the event loop.  If
successful the table returned will contain field(s) for the
requested resource. Possible fields are:</p>
<ul>
<li><code>a</code> and <code>ttl</code></li>
<li><code>aaaa</code> and <code>ttl</code></li>
<li><code>mx</code> and <code>preference</code></li>
<li><code>cname</code> and <code>ttl</code></li>
<li><code>ptr</code> and <code>ttl</code></li>
<li><code>ns</code> and <code>ttl</code></li>
<li><code>mb</code> and <code>ttl</code></li>
<li><code>md</code> and <code>ttl</code></li>
<li><code>mf</code> and <code>ttl</code></li>
<li><code>mg</code> and <code>ttl</code></li>
<li><code>mr</code> and <code>ttl</code></li>
</ul>
<h3 id="e">E</h3>
<h4 id="mtevenablelog">mtev.enable_log</h4>
<blockquote>
<p>Enable or disable a log facility by name.</p>
</blockquote>
<pre><code class="lang-lua">mtev.enable_log(facility, flags = <span class="hljs-keyword">true</span>)
</code></pre>
<ul>
<li><code>facility</code> the name of the mtev_log_stream (e.g. &quot;debug&quot;)</li>
<li><code>flags</code> true enables, false disables</li>
</ul>
<h4 id="mteveventeraccept">mtev.eventer:accept</h4>
<blockquote>
<p>Accept a new connection.</p>
</blockquote>
<pre><code class="lang-lua">mtev.eventer =
mtev.eventer:accept()
</code></pre>
<ul>
<li><strong>RETURN</strong> a new eventer object representing the new connection.</li>
</ul>
<h4 id="mteveventerbind">mtev.eventer:bind</h4>
<blockquote>
<p>Bind a socket to an address.</p>
</blockquote>
<pre><code class="lang-lua">rv, err =
mtev.eventer:bind(address, port)
</code></pre>
<ul>
<li><code>address</code> the IP address to which to bind.</li>
<li><code>port</code> the port to which to bind.</li>
<li><strong>RETURN</strong> rv is 0 on success, on error rv is non-zero and err contains an error message.</li>
</ul>
<h4 id="mteveventerclose">mtev.eventer:close</h4>
<blockquote>
<p>Closes the socket.</p>
</blockquote>
<pre><code class="lang-lua">rv =
mtev.eventer:close()
</code></pre>
<h4 id="mteveventerconnect">mtev.eventer:connect</h4>
<blockquote>
<p>Request a connection on a socket.</p>
</blockquote>
<pre><code class="lang-lua">rv, err =
mtev.eventer:connect(target[, port][, timeout])
</code></pre>
<ul>
<li><code>target</code> the target address for a connection.  Either an IP address (in which case a port is required), or a <code>reverse:</code> connection for reverse tunnelled connections.</li>
<li><code>timeout</code> for connect operation</li>
<li><strong>RETURN</strong> rv is 0 on success, non-zero on failure with err holding the error message.</li>
</ul>
<h4 id="mteveventerlisten">mtev.eventer:listen</h4>
<blockquote>
<p>Listen on a socket.</p>
</blockquote>
<pre><code class="lang-lua">rv, errno, err =
mtev.eventer:listen(backlog)
</code></pre>
<ul>
<li><code>backlog</code> the listen backlog.</li>
<li><strong>RETURN</strong> rv is 0 on success, on failure rv is non-zero and errno and err contain error information.</li>
</ul>
<h4 id="mteveventerown">mtev.eventer:own</h4>
<blockquote>
<p>Declare ownership of an event within a spawned co-routine.</p>
</blockquote>
<pre><code class="lang-lua">ev =
mtev.eventer:own()
</code></pre>
<ul>
<li><strong>RETURN</strong> New eventer object &apos;ev&apos; that is owed by the calling co-routine</li>
</ul>
<p>The old eventer object will be disowned and invalid for use!</p>
<h4 id="mteveventerpeername">mtev.eventer:peer_name</h4>
<blockquote>
<p>Get details of the remote side of a socket.</p>
</blockquote>
<pre><code class="lang-lua">address, port =
mtev.eventer:peer_name()
</code></pre>
<ul>
<li><strong>RETURN</strong> local address, local port</li>
</ul>
<h4 id="mteveventerread">mtev.eventer:read</h4>
<blockquote>
<p>Read data from a socket.</p>
</blockquote>
<pre><code class="lang-lua">payload =
mtev.eventer:read(stop)
</code></pre>
<ul>
<li><code>stop</code> is either an integer describing a number of bytes to read or a string describing an inclusive read terminator.</li>
<li><strong>RETURN</strong> the payload read, or nothing on error.</li>
</ul>
<h4 id="mteveventerrecv">mtev.eventer:recv</h4>
<blockquote>
<p>Receive bytes from a socket.</p>
</blockquote>
<pre><code class="lang-lua">rv, payload, address, port =
mtev.eventer:recv(nbytes)
</code></pre>
<ul>
<li><code>nbytes</code> the number of bytes to receive.</li>
<li><strong>RETURN</strong> rv is the return of the <code>recvfrom</code> libc call, &lt; 0 if error, otherwise it represents the number of bytes received. payload is a lua string representing the data received. address and port are those of the sender of the packet.</li>
</ul>
<h4 id="mteveventersend">mtev.eventer:send</h4>
<blockquote>
<p>Send data over a socket.</p>
</blockquote>
<pre><code class="lang-lua">nbytes, err =
mtev.eventer:send(payload)
</code></pre>
<ul>
<li><code>payload</code> the payload to send as a lua string.</li>
<li><strong>RETURN</strong> bytes is -1 on error, otherwise the number of bytes sent. err contains error messages.</li>
</ul>
<h4 id="mteveventersendto">mtev.eventer:sendto</h4>
<blockquote>
<p>Send data over a disconnected socket.</p>
</blockquote>
<pre><code class="lang-lua">nbytes, err =
mtev.eventer:sendto(payload, address, port)
</code></pre>
<ul>
<li><code>payload</code> the payload to send as a lua string.</li>
<li><code>address</code> is the destination address for the payload.</li>
<li><code>port</code> is the destination port for the payload.</li>
<li><strong>RETURN</strong> bytes is -1 on error, otherwise the number of bytes sent. err contains error messages.</li>
</ul>
<h4 id="mteveventersetsockopt">mtev.eventer:setsockopt</h4>
<blockquote>
<p>Set a socket option.</p>
</blockquote>
<pre><code class="lang-lua">rv, err =
mtev.eventer:setsockopt(feature, value)
</code></pre>
<ul>
<li><code>feature</code> is on the the OS <code>SO_</code> parameters as a string.</li>
<li><code>value</code> is the value to which <code>feature</code> should be set.</li>
<li><strong>RETURN</strong> rv is 0 on success, -1 on failure. err contains error messages.</li>
</ul>
<h4 id="mteveventersockname">mtev.eventer:sock_name</h4>
<blockquote>
<p>Get details of the local side of a socket.</p>
</blockquote>
<pre><code class="lang-lua">address, port =
mtev.eventer:sock_name()
</code></pre>
<ul>
<li><strong>RETURN</strong> local address, local port</li>
</ul>
<h4 id="mteveventersslctx">mtev.eventer:ssl_ctx</h4>
<blockquote>
<p>Gets the SSL context associated with an SSL-upgraded event.</p>
</blockquote>
<pre><code class="lang-lua">mtev.eventer.ssl_ctx =
mtev.eventer:ssl_ctx()
</code></pre>
<ul>
<li><strong>RETURN</strong> an mtev.eventer.ssl_ctx object.</li>
</ul>
<h4 id="mteveventersslupgradesocket">mtev.eventer:ssl_upgrade_socket</h4>
<blockquote>
<p>Upgrade a normal TCP socket to SSL.</p>
</blockquote>
<pre><code class="lang-lua">rv, err =
mtev.eventer:ssl_upgrade_socket(cert, sslconfig[, snihost[, layer]]]])
</code></pre>
<ul>
<li><code>sslconfig</code> is a table that looks like mtev&apos;s sslconfig</li>
<li><code>snihost</code> the host name to which we&apos;re connecting (SNI).</li>
<li><code>layer</code> a desired SSL layer.</li>
<li><strong>RETURN</strong> rv is 0 on success, -1 on failure. err contains error messages.</li>
</ul>
<h4 id="mteveventerwrite">mtev.eventer:write</h4>
<blockquote>
<p>Writes data to a socket.</p>
</blockquote>
<pre><code class="lang-lua">nbytes =
mtev.eventer:write(data)
</code></pre>
<ul>
<li><code>data</code> a lua string that contains the data to write.</li>
<li><strong>RETURN</strong> the number of bytes written.</li>
</ul>
<h4 id="mteveventerloopconcurrency">mtev.eventer_loop_concurrency</h4>
<pre><code class="lang-lua">mtev.eventer_loop_concurrency()
</code></pre>
<h4 id="mtevexec">mtev.exec</h4>
<blockquote>
<p>Spawn process return output on stdout, stderr as strings</p>
</blockquote>
<pre><code class="lang-lua">status, stdout, stderr =
mtev.exec(path, argv, env, timeout)
</code></pre>
<ul>
<li><strong>RETURN</strong> status is nil if a timeout was hit, stdout, stderr contain process output</li>
</ul>
<h3 id="g">G</h3>
<h4 id="mtevgetaddrinfo">mtev.getaddrinfo</h4>
<blockquote>
<p>Resolves host name using the OS provided getaddrinfo function</p>
</blockquote>
<pre><code class="lang-lua">ipstr, family =
mtev.getaddrinfo(hostname)
</code></pre>
<ul>
<li><strong>RETURN</strong> ipstr  - IP address represented as a string</li>
<li><strong>RETURN</strong> family - &quot;inet&quot; or &quot;inet6&quot; depending on whether the returned address is IPv4, IPv6</li>
</ul>
<p>In particular this will respect the /etc/host entries.</p>
<p>In the case of error, we return <code>false, errormsg</code></p>
<h4 id="mtevgetcwd">mtev.getcwd</h4>
<pre><code class="lang-lua">path =
mtev.getcwd()
</code></pre>
<ul>
<li><strong>RETURN</strong> path string or nil</li>
</ul>
<h4 id="mtevgetipipv4">mtev.getip_ipv4</h4>
<blockquote>
<p>Returns the local address of a connection to tgt.</p>
</blockquote>
<pre><code class="lang-lua">address =
mtev.getip_ipv4([tgt])
</code></pre>
<ul>
<li><code>tgt</code> an IP address to target (default 8.8.8.8)</li>
<li><strong>RETURN</strong> address  - IP address as a string</li>
</ul>
<h4 id="mtevgettimeofday">mtev.gettimeofday</h4>
<pre><code class="lang-lua">sec, usec =
mtev.gettimeofday()
</code></pre>
<ul>
<li><strong>RETURN</strong> the seconds and microseconds since epoch (1970 UTC)</li>
</ul>
<h4 id="mtevgunzip">mtev.gunzip</h4>
<pre><code class="lang-lua">mtev.gunzip()
</code></pre>
<h3 id="h">H</h3>
<h4 id="mtevhmacsha1encode">mtev.hmac_sha1_encode</h4>
<pre><code class="lang-lua">mtev.hmac_sha1_encode()
</code></pre>
<h4 id="mtevhmacsha256encode">mtev.hmac_sha256_encode</h4>
<pre><code class="lang-lua">mtev.hmac_sha256_encode()
</code></pre>
<h3 id="i">I</h3>
<h4 id="mtevinetpton">mtev.inet_pton</h4>
<blockquote>
<p>Wrapper around inet_pton(3). Can be used to validate IP addresses and detect the address family (IPv4,IPv6)</p>
</blockquote>
<pre><code class="lang-lua">rc, family, addr =
mtev.inet_pton(address)
</code></pre>
<ul>
<li><code>address</code> to parse</li>
<li><strong>RETURN</strong> rc true if address is a valid IP address, false otherwise</li>
<li><strong>RETURN</strong> family address family of the address, either &quot;inet&quot; or &quot;inet6&quot;.</li>
<li><strong>RETURN</strong> addr struct in_addr as udata</li>
</ul>
<h3 id="j">J</h3>
<h4 id="mtevjsondocument">mtev.json:document</h4>
<blockquote>
<p>return a lua prepresentation of an <code>mtev.json</code> object</p>
</blockquote>
<pre><code class="lang-lua">obj =
mtev.json:document()
</code></pre>
<ul>
<li><strong>RETURN</strong> a lua object (usually a table)</li>
</ul>
<p>Returns a fair representation of the underlying JSON document
as native lua objects.</p>
<h4 id="mtevjsontostring">mtev.json:tostring</h4>
<blockquote>
<p>return a JSON-formatted string of an <code>mtev.json</code> object</p>
</blockquote>
<pre><code class="lang-lua">obj =
mtev.json:<span class="hljs-built_in">tostring</span>()
</code></pre>
<ul>
<li><strong>RETURN</strong> a lua string</li>
</ul>
<p>Returns a JSON document (as a string) representing the underlying
<code>mtev.json</code> object.</p>
<h3 id="l">L</h3>
<h4 id="mtevlog">mtev.log</h4>
<blockquote>
<p>write message into the libmtev logging system</p>
</blockquote>
<pre><code class="lang-lua">len =
mtev.log(facility, format, ...)
</code></pre>
<ul>
<li><code>facility</code> the name of the mtev_log_stream (e.g. &quot;error&quot;)</li>
<li><code>format</code> a format string see printf(3c)</li>
<li><code>...</code> arguments to be used within the specified format</li>
<li><strong>RETURN</strong> the number of bytes written</li>
</ul>
<h4 id="mtevlogenabled">mtev.log_enabled</h4>
<blockquote>
<p>Determine the enabled status of a log.</p>
</blockquote>
<pre><code class="lang-lua">boolean =
mtev.log_enabled(facility)
</code></pre>
<ul>
<li><code>facility</code> the name of the mtev_log_stream (e.g. &quot;debug&quot;)</li>
<li><strong>RETURN</strong> a boolean indicating the enabled status of the log facility</li>
</ul>
<h4 id="mtevlogwatchstop">mtev.LogWatch:stop</h4>
<blockquote>
<p>stop watching, drain watch queue</p>
</blockquote>
<pre><code class="lang-lua">mtev.LogWatch:stop()
</code></pre>
<h4 id="mtevlogwatchwait">mtev.LogWatch:wait</h4>
<blockquote>
<p>wait for match</p>
</blockquote>
<pre><code class="lang-lua">line =
mtev.LogWatch:wait(timeout)
</code></pre>
<ul>
<li><code>timeout</code> maximial time to wait in seconds</li>
<li><strong>RETURN</strong> line matched or nil on timeout</li>
</ul>
<h3 id="m">M</h3>
<h4 id="mtevmd5">mtev.md5</h4>
<pre><code class="lang-lua">mtev.md5()
</code></pre>
<h4 id="mtevmd5hex">mtev.md5_hex</h4>
<pre><code class="lang-lua">mtev.md5_hex()
</code></pre>
<h4 id="mtevmkdir">mtev.mkdir</h4>
<pre><code class="lang-lua">ok, errno, errstr =
mtev.mkdir(path)
</code></pre>
<ul>
<li><code>path</code> string</li>
<li><strong>RETURN</strong> boolean success flag, error number, string representation of error</li>
</ul>
<h4 id="mtevmkdirforfile">mtev.mkdir_for_file</h4>
<pre><code class="lang-lua">ok, errno, errstr =
mtev.mkdir_for_file(path)
</code></pre>
<pre><code>* `path` string
* **RETURN** boolean success flag, error number, string representation of error
</code></pre><h3 id="n">N</h3>
<h4 id="mtevnotify">mtev.notify</h4>
<blockquote>
<p>Send notification message on given key, to be received by mtev.waitfor(key)</p>
</blockquote>
<pre><code class="lang-lua">mtev.notify(key, ...)
</code></pre>
<ul>
<li><code>key</code> key specifying notification channel</li>
<li><code>...</code> additional args to be included in the message</li>
</ul>
<h3 id="o">O</h3>
<h4 id="mtevopen">mtev.open</h4>
<pre><code class="lang-lua">fh =
mtev.open(file, flags)
</code></pre>
<pre><code>* `file` to open (string)
* `integer` flag
* **RETURN** file handle
</code></pre><p>  The following flag constants are pre-defined:
  <code>O_RDONLY</code>,
  <code>O_WRONLY</code>,
  <code>O_RDWR</code>,
  <code>O_APPEND</code>,
  <code>O_SYNC</code>,
  <code>O_NOFOLLOW</code>,
  <code>O_CREAT</code>,
  <code>O_TRUNC</code>,
  <code>O_EXCL</code>
  see <code>man 2 open</code> for their semantics.</p>
<h3 id="p">P</h3>
<h4 id="mtevparsejson">mtev.parsejson</h4>
<blockquote>
<p>Convert a JSON strint to an <code>mtev.json</code>.</p>
</blockquote>
<pre><code class="lang-lua">jsonobj, err, offset =
mtev.parsejson(<span class="hljs-built_in">string</span>)
</code></pre>
<ul>
<li><code>string</code> is a JSON formatted string.</li>
<li><strong>RETURN</strong> an mtev.json object plus errors on failure.</li>
</ul>
<p>This converts a JSON string to a lua object.  As lua
does not support table keys with nil values, this
implementation sets them to nil and thus elides the keys.
If parsing fails nil is returned followed by the error and
the byte offset into the string where the error occurred.</p>
<h4 id="mtevparsexml">mtev.parsexml</h4>
<blockquote>
<p>Parse xml string</p>
</blockquote>
<pre><code class="lang-lua">mtev.parsexml(str)
</code></pre>
<ul>
<li><strong>RETURN</strong> mtev.xmldoc representation</li>
</ul>
<h4 id="mtevpcre">mtev.pcre</h4>
<pre><code class="lang-lua">matcher =
mtev.pcre(pcre_expression)
</code></pre>
<ul>
<li><code>pcre_expression</code> a perl compatible regular expression</li>
<li><strong>RETURN</strong> a matcher function <code>rv, m, ... = matcher(subject, options)</code></li>
</ul>
<p>A compiled pcre matcher function takes a string subject as the first
argument and optional options as second argument.</p>
<p>The matcher will return first whether there was a match (true/false).
If true, the next return value will be to entire scope of the match
followed by any capture subexpressions.  If the same subject variable
is supplied, subsequent calls will act on the remainder of the subject
past previous matches (allowing for global search emulation).  If the
subject changes, the match starting location is reset to the beginning.
The caller can force a reset by calling <code>matcher(nil)</code>.</p>
<p><code>options</code> is an option table with the optional fields <code>limit</code>
(<code>PCRE_CONFIG_MATCH_LIMIT</code>) and <code>limit_recurse</code> (<code>PCRE_CONFIG_MATCH_LIMIT_RECURSION</code>).
See the pcreapi man page for more details.</p>
<h4 id="mtevprint">mtev.print</h4>
<pre><code class="lang-lua">len =
mtev.<span class="hljs-built_in">print</span>(format, ...)
</code></pre>
<ul>
<li><code>format</code> a format string see printf(3c)</li>
<li><code>...</code> arguments to be used within the specified format</li>
<li><strong>RETURN</strong> the number of bytes written</li>
</ul>
<p>This function is effectively the <code>mtev.log</code> function with the first argument
set to &quot;error&quot;.  It is also aliased into the global <code>print</code> symbol such that
one cannot accidentally call the print builtin.</p>
<h4 id="mtevprintto">mtev.printto</h4>
<pre><code class="lang-lua">len =
mtev.printto(facility)
</code></pre>
<ul>
<li><code>facility</code> is an mtev log stream</li>
</ul>
<p>This function sets the mtev.print output facility.</p>
<h4 id="prockill">Proc:kill</h4>
<blockquote>
<p>Kill process by sending SIGTERM, then SIGKILL</p>
</blockquote>
<pre><code class="lang-lua">ok, status, errno =
Proc:kill(timeout)
</code></pre>
<ul>
<li><code>timeout</code> for the signals</li>
<li><strong>RETURN</strong> ok true if process was terminated, status, errno as returned by mtev.proc:wait()</li>
</ul>
<h4 id="mtevprocloglisten">mtev.Proc:loglisten</h4>
<blockquote>
<p>Execute f on each line emitted to stderr</p>
</blockquote>
<pre><code class="lang-lua">self =
mtev.Proc:loglisten(f)
</code></pre>
<h4 id="mtevprocloglog">mtev.Proc:loglog</h4>
<blockquote>
<p>Forward process output on stderr to mtev log stream</p>
</blockquote>
<pre><code class="lang-lua">self =
mtev.Proc:loglog(stream, [prefix])
</code></pre>
<h4 id="mtevproclogwatch">mtev.Proc:logwatch</h4>
<blockquote>
<p>Watch stderr for a line maching regexp</p>
</blockquote>
<pre><code class="lang-lua">watch =
mtev.Proc:logwatch(regex, [limit])
</code></pre>
<ul>
<li><code>regex</code> is either a regex string or a function that consumes lines</li>
<li><code>limit</code> is the maximal number of matches to find. Default infinite.</li>
<li><strong>RETURN</strong> watch an mtev.LogWatch object</li>
</ul>
<h4 id="mtevproclogwrite">mtev.Proc:logwrite</h4>
<blockquote>
<p>Write process output on stderr to file</p>
</blockquote>
<pre><code class="lang-lua">self =
mtev.Proc:logwrite(file)
</code></pre>
<h4 id="mtevprocnew">mtev.Proc:new</h4>
<blockquote>
<p>Create and control a subprocess</p>
</blockquote>
<pre><code class="lang-lua">proc =
mtev.Proc:new(opts)
</code></pre>
<ul>
<li><code>opts.path</code> path of the executable</li>
<li><code>opts.argv</code> list of command line arguments (including process name)</li>
<li><code>opts.dir</code> working directory of the process, defaults to CWD</li>
<li><code>opts.env</code> table with environment variables, defaults to ENV</li>
<li><code>opts.boot_match</code> message that signals readiness of process</li>
<li><code>opts.boot_timeout</code> time to wait until boot_match appars in stderr in seconds, defaults to 5s</li>
<li><strong>RETURN</strong> a Proc object</li>
</ul>
<h4 id="mtevprocpause">mtev.Proc:pause</h4>
<blockquote>
<p>send SIGSTOP signal</p>
</blockquote>
<pre><code class="lang-lua">status =
mtev.Proc:pause()
</code></pre>
<h4 id="mtevprocpid">mtev.Proc:pid</h4>
<pre><code class="lang-lua">pid =
mtev.Proc:pid()
</code></pre>
<h4 id="procready">Proc:ready</h4>
<blockquote>
<p>wait for the process to become ready</p>
</blockquote>
<pre><code class="lang-lua">status =
Proc:ready()
</code></pre>
<ul>
<li><strong>RETURN</strong> status true/false depending on weather the process became ready
Kills processes that did not become ready in time</li>
</ul>
<h4 id="mtevprocresume">mtev.Proc:resume</h4>
<blockquote>
<p>send SIGCONT signal</p>
</blockquote>
<pre><code class="lang-lua">status =
mtev.Proc:resume()
</code></pre>
<h4 id="mtevprocstart">mtev.Proc:start</h4>
<blockquote>
<p>start process</p>
</blockquote>
<pre><code class="lang-lua">ok, msg =
mtev.Proc:start()
</code></pre>
<ul>
<li><strong>RETURN</strong> self</li>
</ul>
<h4 id="mtevprocwait">mtev.Proc:wait</h4>
<blockquote>
<p>wait for a process to terminate</p>
</blockquote>
<pre><code class="lang-lua">term, status, errno =
mtev.Proc:wait(timeout)
</code></pre>
<ul>
<li><strong>RETURN</strong> term is true if the process terminated normally; status, errno as in mtev.process:wait()
In the case of normal termination, status is passed throught the WEXITSTATUS() before returning.</li>
</ul>
<h4 id="mtevprocesskill">mtev.process:kill</h4>
<blockquote>
<p>Kill a spawned process.</p>
</blockquote>
<pre><code class="lang-lua">success, errno =
mtev.process:kill(signal)
</code></pre>
<ul>
<li><code>signal</code> the integer signal to deliver, if omitted <code>SIGTERM</code> is used.</li>
<li><strong>RETURN</strong> true on success or false and an errno on failure.</li>
</ul>
<h4 id="mtevprocesspgkill">mtev.process:pgkill</h4>
<blockquote>
<p>Kill a spawned process group.</p>
</blockquote>
<pre><code class="lang-lua">success, errno =
mtev.process:pgkill(signal)
</code></pre>
<ul>
<li><code>signal</code> the integer signal to deliver, if omitted <code>SIGTERM</code> is used.</li>
<li><strong>RETURN</strong> true on success or false and an errno on failure.</li>
</ul>
<h4 id="mtevprocesspid">mtev.process:pid</h4>
<blockquote>
<p>Return the process id of a spawned process.</p>
</blockquote>
<pre><code class="lang-lua">pid =
mtev.process:pid()
</code></pre>
<ul>
<li><strong>RETURN</strong> The process id.</li>
</ul>
<h4 id="mtevprocesswait">mtev.process:wait</h4>
<blockquote>
<p>Attempt to wait for a spawned process to terminate.</p>
</blockquote>
<pre><code class="lang-lua">status, errno =
mtev.process:wait(timeout)
</code></pre>
<ul>
<li><code>timeout</code> an option time in second to wait for exit (0 in unspecified).</li>
<li><strong>RETURN</strong> The process status and an errno if applicable.</li>
</ul>
<p>Wait for a process (using <code>waitpid</code> with the <code>WNOHANG</code> option) to terminate
and return its exit status.  If the process has not exited and the timeout
has elapsed, the call will return with a nil value for status.  The lua
subsystem exists within a complex system that might handle process in different
ways, so it does not rely on <code>SIGCHLD</code> signal delivery and instead polls the
system using <code>waitpid</code> every 20ms.</p>
<h3 id="r">R</h3>
<h4 id="mtevrealpath">mtev.realpath</h4>
<blockquote>
<p>Return the real path of a relative path.</p>
</blockquote>
<pre><code class="lang-lua">path =
mtev.realpath(inpath)
</code></pre>
<ul>
<li><code>inpath</code> a relative path as a string</li>
<li><strong>RETURN</strong> The non-relative path inpath refers to (or nil on error).</li>
</ul>
<h4 id="mtevrmdir">mtev.rmdir</h4>
<pre><code class="lang-lua">ok, errno, errstr =
mtev.rmdir(path)
</code></pre>
<ul>
<li><code>path</code> string</li>
<li><strong>RETURN</strong> boolean success flag, error number, string representation of error</li>
</ul>
<h3 id="s">S</h3>
<h4 id="mtevsemaphore">mtev.semaphore</h4>
<blockquote>
<p>initializes semaphore with a given initial value, and returns a pointer to the semaphore object.</p>
</blockquote>
<pre><code class="lang-lua">sem =
mtev.semaphore(name, value)
</code></pre>
<ul>
<li><code>name</code> of the semaphore</li>
<li><code>value</code> initial semaphore value used if not already initialized</li>
</ul>
<p>If a semaphore with the same name already exists, no initialization takes place, and the second argument is ignored.</p>
<p>Semaphores are a way to synchronize actions between different lua states.</p>
<p>Example:</p>
<pre><code class="lang-lua">sem = mtev.semaphore(<span class="hljs-string">&quot;my-first-semaphore&quot;</span>, <span class="hljs-number">10</span>)
sem:acquire()
<span class="hljs-comment">-- ... do something while holding the lock</span>
sem:release()
</code></pre>
<h4 id="semaphoreacquire">semaphore:acquire</h4>
<pre><code class="lang-lua">semaphore:acquire([timeout])
</code></pre>
<ul>
<li><code>timeout</code> optional time to wait for the lock. Defaults to inifinite wait.</li>
</ul>
<blockquote>
<p>returns true of the semaphore lock could be acquired within the given timeout, false if not.</p>
</blockquote>
<p>At the time of this writing, the implementation of this functions uses polling.
Expect delays between calls to :release() and subsequent :acquire() returning.</p>
<h4 id="semaphorerelease">semaphore:release</h4>
<blockquote>
<p>release the semaphore lock.</p>
</blockquote>
<pre><code class="lang-lua">semaphore:release()
</code></pre>
<h4 id="semaphoretryacquire">semaphore:try_acquire</h4>
<blockquote>
<p>returns true of the semaphore lock could be acquired, false if not.</p>
</blockquote>
<pre><code class="lang-lua">semaphore:try_acquire()
</code></pre>
<h4 id="mtevsh">mtev.sh</h4>
<blockquote>
<p>Run shell command, return output</p>
</blockquote>
<pre><code class="lang-lua">status, stdout, stderr =
mtev.sh(command, [timeout], [shell])
</code></pre>
<ul>
<li><code>command</code> to run</li>
<li><code>timeout</code> defaults to nil (infinite wait)</li>
<li><code>shell</code> which shell to use, defaults to $SHELL then to &quot;/bin/sh&quot;</li>
</ul>
<h4 id="mtevsha1">mtev.sha1</h4>
<pre><code class="lang-lua">mtev.sha1()
</code></pre>
<h4 id="mtevsha1hex">mtev.sha1_hex</h4>
<pre><code class="lang-lua">mtev.sha1_hex()
</code></pre>
<h4 id="mtevsha256">mtev.sha256</h4>
<pre><code class="lang-lua">digest =
mtev.sha256(s)
</code></pre>
<ul>
<li><code>s</code> a string</li>
<li><strong>RETURN</strong> the SHA256 digest of the input string</li>
</ul>
<h4 id="mtevsha256hash">mtev.sha256_hash</h4>
<pre><code class="lang-lua">digest_hex =
mtev.sha256_hash(s)
</code></pre>
<ul>
<li><code>s</code> a string</li>
<li><strong>RETURN</strong> the SHA256 digest of the input string, encoded in hexadecimal format</li>
</ul>
<p><strong>DEPRECATED</strong></p>
<p>Use sha256_hex instead.</p>
<h4 id="mtevsha256hex">mtev.sha256_hex</h4>
<pre><code class="lang-lua">digest_hex =
mtev.sha256_hex(s)
</code></pre>
<ul>
<li><code>s</code> a string</li>
<li><strong>RETURN</strong> the SHA256 digest of the input string, encoded in hexadecimal format</li>
</ul>
<h4 id="mtevsharedget">mtev.shared_get</h4>
<blockquote>
<p>Retrieve (via deserialization) a value at some globally named key.</p>
</blockquote>
<pre><code class="lang-lua">mtev.shared_get(key)
</code></pre>
<ul>
<li><code>key</code> must be string</li>
<li><strong>RETURN</strong> a lua value or nil</li>
</ul>
<p>This function allows communication across lua states via mutex-protected storage
of values.</p>
<h4 id="mtevsharednotify">mtev.shared_notify</h4>
<blockquote>
<p>Enqueue (via serialization) a value in some globally named queue.</p>
</blockquote>
<pre><code class="lang-lua">mtev.shared_notify(key, value)
</code></pre>
<ul>
<li><code>key</code> must be string naming the queue</li>
<li><code>value</code> is a lua value simple enough to serialize (no functions, udata, etc.)</li>
<li><strong>RETURN</strong> none</li>
</ul>
<p>This function allows communication across lua states.</p>
<h4 id="mtevsharedseq">mtev.shared_seq</h4>
<blockquote>
<p>returns a sequence number that is increasing across all mtev-lua states and coroutines</p>
</blockquote>
<pre><code class="lang-lua">seq =
mtev.shared_seq(keyname)
</code></pre>
<ul>
<li><code>keyname</code> the globally unique name of the sequence to return and post-increment.</li>
<li><strong>RETURN</strong> seq the sequence number</li>
</ul>
<h4 id="mtevsharedset">mtev.shared_set</h4>
<blockquote>
<p>Store (via serialization) a value at some globally named key.</p>
</blockquote>
<pre><code class="lang-lua">mtev.shared_set(key, value)
</code></pre>
<ul>
<li><code>key</code> must be string</li>
<li><code>value</code> is a lua value simple enough to serialize (no functions, udata, etc.)</li>
<li><strong>RETURN</strong> none</li>
</ul>
<p>This function allows communication across lua states via mutex-protected storage
of values.</p>
<h4 id="mtevsharedwaitfor">mtev.shared_waitfor</h4>
<blockquote>
<p>Retrieve (via deserialization) a value in some globally named queue.</p>
</blockquote>
<pre><code class="lang-lua">mtev.shared_waitfor(key, timeout)
</code></pre>
<ul>
<li><code>key</code> must be string naming the queue</li>
<li><code>timeout</code> number of sections to wait before returning nil</li>
<li><strong>RETURN</strong> a lua value or nil</li>
</ul>
<p>This function allows communication across lua states.</p>
<h4 id="mtevsleep">mtev.sleep</h4>
<pre><code class="lang-lua">slept =
mtev.sleep(duration_s)
</code></pre>
<ul>
<li><code>duration_s</code> the number of sections to sleep</li>
<li><strong>RETURN</strong> the time slept as mtev.timeval object</li>
</ul>
<h4 id="mtevsocket">mtev.socket</h4>
<blockquote>
<p>Open a socket for eventer-friendly interaction.</p>
</blockquote>
<pre><code class="lang-lua">mtev.eventer =
mtev.socket(address[, <span class="hljs-built_in">type</span>])
</code></pre>
<ul>
<li><code>address</code> a string &apos;inet&apos;, &apos;inet6&apos; or an address to connect to</li>
<li><code>type</code> an optional string &apos;tcp&apos; or &apos;udp&apos; (default is &apos;tcp&apos;)</li>
<li><strong>RETURN</strong> an eventer object.</li>
</ul>
<p>No connect() call is performed here, the address provided is only used
to ascertain the address family for the socket.</p>
<h4 id="mtevspawn">mtev.spawn</h4>
<blockquote>
<p>Spawn a subprocess.</p>
</blockquote>
<pre><code class="lang-lua">mtev.process =
mtev.spawn(path, argv, env)
</code></pre>
<ul>
<li><code>path</code> the path to the executable to spawn</li>
<li><code>argv</code> an array of arguments (first argument is the process name)</li>
<li><code>env</code> an optional array of &quot;K=V&quot; strings.</li>
<li><strong>RETURN</strong> an object with the mtev.process metatable set.</li>
</ul>
<p>This function spawns a new subprocess running the binary specified as
the first argument.</p>
<h3 id="t">T</h3>
<h4 id="mtevthreadself">mtev.thread_self</h4>
<pre><code class="lang-lua">thread, tid =
mtev.thread_self()
</code></pre>
<h4 id="mtevtime">mtev.time</h4>
<pre><code class="lang-lua">time =
mtev.time()
</code></pre>
<ul>
<li><strong>RETURN</strong> the seconds since epoch (1970 UTC) as float</li>
</ul>
<h4 id="mtevtimezone">mtev.timezone</h4>
<pre><code class="lang-lua">mtev.timezone =
mtev.timezone(zonename)
</code></pre>
<ul>
<li><ul>
<li><code>zonename</code> is the name of the timezone (e.g. &quot;UTC&quot; or &quot;US/Eastern&quot;)</li>
</ul>
</li>
<li><ul>
<li><strong>RETURN</strong> an mtev.timezone object.</li>
</ul>
</li>
</ul>
<h4 id="mtevtimezoneextract">mtev.timezone:extract</h4>
<pre><code class="lang-lua">a,... =
mtev.timezone:extract(time, field1, ...)
</code></pre>
<ul>
<li><code>time</code> is the offset in seconds from UNIX epoch.</li>
<li><code>field1</code> is a field to extract in the time local to the timezone object.</li>
<li><strong>RETURN</strong> The value of each each requested field.</li>
</ul>
<p>Valid fields are &quot;second&quot;, &quot;minute&quot;, &quot;hour&quot;, &quot;monthday&quot;, &quot;month&quot;, &quot;weekday&quot;,
&quot;yearday&quot;, &quot;year&quot;, &quot;dst&quot;, &quot;offset&quot;, and &quot;zonename.&quot;</p>
<h4 id="mtevtojson">mtev.tojson</h4>
<blockquote>
<p>Convert a lua object into a json doucument.</p>
</blockquote>
<pre><code class="lang-lua">jsonobj =
mtev.tojson(obj, maxdepth = <span class="hljs-number">-1</span>)
</code></pre>
<ul>
<li><code>obj</code> a lua object (usually a table).</li>
<li><code>maxdepth</code> if specified limits the recursion.</li>
<li><strong>RETURN</strong> an mtev.json object.</li>
</ul>
<p>This converts a lua object, ignoring types that do not have JSON
counterparts (like userdata, lightuserdata, functions, threads, etc.).
The return is an <code>mtev.json</code> object not a string. You must invoke
the <code>tostring</code> method to convert it to a simple string.</p>
<h3 id="u">U</h3>
<h4 id="mtevuname">mtev.uname</h4>
<blockquote>
<p>Returns info from the uname libc call</p>
</blockquote>
<pre><code class="lang-lua">details =
mtev.uname()
</code></pre>
<ul>
<li><strong>RETURN</strong> A table resembling the <code>struct utsname</code></li>
</ul>
<h4 id="mtevutf8tohtml">mtev.utf8tohtml</h4>
<pre><code class="lang-lua">mtev.utf8tohtml()
</code></pre>
<h4 id="mtevuuid">mtev.uuid</h4>
<pre><code class="lang-lua">mtev.uuid()
</code></pre>
<h3 id="w">W</h3>
<h4 id="mtevwaitfor">mtev.waitfor</h4>
<blockquote>
<p>Suspend until for notification on key is received or the timeout is reached.</p>
</blockquote>
<pre><code class="lang-lua">... =
mtev.waitfor(key, [timeout])
</code></pre>
<ul>
<li><strong>RETURN</strong> arguments passed to mtev.notify() including the key.</li>
</ul>
<h4 id="mtevwatchdogchildheartbeat">mtev.watchdog_child_heartbeat</h4>
<blockquote>
<p>Heartbeat from a child process.</p>
</blockquote>
<pre><code class="lang-lua">rv =
mtev.watchdog_child_heartbeat()
</code></pre>
<ul>
<li><strong>RETURN</strong> The return value of <code>mtev_watchdog_child_heartbeat()</code></li>
</ul>
<h4 id="mtevwatchdogtimeout">mtev.watchdog_timeout</h4>
<blockquote>
<p>Return the watchdog timeout on the current thread.</p>
</blockquote>
<pre><code class="lang-lua">timeout =
mtev.watchdog_timeout()
</code></pre>
<ul>
<li><strong>RETURN</strong> A timeout in seconds, or nil if no watchdog configured.</li>
</ul>
<h4 id="mtevwcoredump">mtev.WCOREDUMP</h4>
<pre><code class="lang-lua">mtev.WCOREDUMP(status)
</code></pre>
<ul>
<li><code>status</code> a process status returned by <code>mtev.process:wait(timeout)</code></li>
<li><strong>RETURN</strong> true if the process produced a core dump</li>
</ul>
<p>Only valid if <code>mtev.WIFSIGNALED(status)</code> is also true.</p>
<h4 id="mtevwebsocketclientclose">mtev.websocket_client:close</h4>
<blockquote>
<p>Close a websocket client.</p>
</blockquote>
<pre><code class="lang-lua">mtev.websocket_client:close()
</code></pre>
<h4 id="mtevwebsocketclientsend">mtev.websocket_client:send</h4>
<pre><code class="lang-lua">mtev.websocket_client:send(opcode, payload)
</code></pre>
<ul>
<li><code>opcode</code> The websocket opcode.</li>
<li><code>payload</code> The payload.</li>
</ul>
<blockquote>
<p>Send a message over a websocket client.</p>
</blockquote>
<p>The client object has fields exposing: <code>CONTINUATION</code>, <code>TEXT</code>,
<code>BINARY</code>, <code>CONNECTION_CLOSE</code>, <code>PING</code>, and <code>PONG</code>.</p>
<h4 id="mtevwebsocketclientconnect">mtev.websocket_client_connect</h4>
<blockquote>
<p>Create a new web socket client.</p>
</blockquote>
<pre><code class="lang-lua">success =
mtev.websocket_client_connect(host, port, uri, service, callbacks, sslconfig)
</code></pre>
<ul>
<li><code>host</code> The host</li>
<li><code>port</code> The port</li>
<li><code>uri</code> The uri</li>
<li><code>service</code> The service</li>
<li><code>callbacks</code> A table of callbacks</li>
<li><code>sslconfig</code> An optional non-empty table of ssl configuration.</li>
<li><strong>RETURN</strong> True or false for success.</li>
</ul>
<p>Callbacks may include:</p>
<ul>
<li>ready = function(mtev.websocket_client) return boolean</li>
<li>message = function(mtev.websocket_client, opcode, payload) return boolean</li>
<li>cleanup = function(mtev.websocket_client)</li>
</ul>
<p>If callbacks returning boolean return false, the connection will shutdown.
sslconfig can contain <code>ca_chain</code> <code>key</code> <code>cert</code> <code>layer</code> <code>ciphers</code> just as
with other SSL functions.</p>
<h4 id="mtevwexitstatus">mtev.WEXITSTATUS</h4>
<pre><code class="lang-lua">mtev.WEXITSTATUS(status)
</code></pre>
<ul>
<li><code>status</code> a process status returned by <code>mtev.process:wait(timeout)</code></li>
<li><strong>RETURN</strong> the exit status of the process</li>
</ul>
<p>Only valid if <code>mtev.WIFEXITED(status)</code> is true.</p>
<h4 id="mtevwifcontinued">mtev.WIFCONTINUED</h4>
<pre><code class="lang-lua">mtev.WIFCONTINUED(status)
</code></pre>
<ul>
<li><code>status</code> a process status returned by <code>mtev.process:wait(timeout)</code></li>
<li><strong>RETURN</strong> true if the process has continued after a job control stop, but not terminated</li>
</ul>
<h4 id="mtevwifexited">mtev.WIFEXITED</h4>
<pre><code class="lang-lua">mtev.WIFEXITED(status)
</code></pre>
<ul>
<li><code>status</code> a process status returned by <code>mtev.process:wait(timeout)</code></li>
<li><strong>RETURN</strong> true if the process terminated normally</li>
</ul>
<h4 id="mtevwifsignaled">mtev.WIFSIGNALED</h4>
<pre><code class="lang-lua">mtev.WIFSIGNALED(status)
</code></pre>
<ul>
<li><code>status</code> a process status returned by <code>mtev.process:wait(timeout)</code></li>
<li><strong>RETURN</strong> true if the process terminated due to receipt of a signal</li>
</ul>
<h4 id="mtevwifstopped">mtev.WIFSTOPPED</h4>
<pre><code class="lang-lua">mtev.WIFSTOPPED(status)
</code></pre>
<ul>
<li><code>status</code> a process status returned by <code>mtev.process:wait(timeout)</code></li>
<li><strong>RETURN</strong> true if the process was stopped, but not terminated</li>
</ul>
<h4 id="mtevwrite">mtev.write</h4>
<pre><code class="lang-lua">mtev.write(fd, str)
</code></pre>
<h4 id="mtevwstopsig">mtev.WSTOPSIG</h4>
<pre><code class="lang-lua">mtev.WSTOPSIG(status)
</code></pre>
<ul>
<li><code>status</code> a process status returned by <code>mtev.process:wait(timeout)</code></li>
<li><strong>RETURN</strong> the number of the signal that caused the process to stop</li>
</ul>
<p>Only valid if <code>mtev.WIFSTOPPED(status)</code> is true.</p>
<h4 id="mtevwtermsig">mtev.WTERMSIG</h4>
<pre><code class="lang-lua">mtev.WTERMSIG(status)
</code></pre>
<ul>
<li><code>status</code> a process status returned by <code>mtev.process:wait(timeout)</code></li>
<li><strong>RETURN</strong> the number of the signal that caused the termination of the process</li>
</ul>
<p>Only valid if <code>mtev.WIFSIGNALED(status)</code> is true.</p>
<h3 id="x">X</h3>
<h4 id="mtevxmldocroot">mtev.xmldoc:root</h4>
<pre><code class="lang-lua">node =
mtev.xmldoc:root()
</code></pre>
<ul>
<li><strong>RETURN</strong> mtev.xmlnode containing root of document</li>
</ul>
<h4 id="mtevxmldoctostring">mtev.xmldoc:tostring</h4>
<pre><code class="lang-lua">str =
mtev.xmldoc:<span class="hljs-built_in">tostring</span>()
</code></pre>
<ul>
<li><strong>RETURN</strong> string representation of xmldoc</li>
</ul>
<h4 id="mtevxmldocxpath">mtev.xmldoc:xpath</h4>
<pre><code class="lang-lua">iter
mtev.xmldoc:xpath(xpath, [node])
</code></pre>
<ul>
<li><strong>RETURN</strong> iterator over mtev.xmlnode objects</li>
</ul>
<h4 id="mtevxmlnodeaddchild">mtev.xmlnode:addchild</h4>
<blockquote>
<p>Add child to the given xml node</p>
</blockquote>
<pre><code class="lang-lua">child =
mtev.xmlnode:addchild(str)
</code></pre>
<ul>
<li><strong>RETURN</strong> child mtev.xmlnode</li>
</ul>
<h4 id="mtevxmlnodeattr">mtev.xmlnode:attr</h4>
<pre><code class="lang-lua">val =
mtev.xmlnode:attr(key)
</code></pre>
<h4 id="mtevxmlnodechildren">mtev.xmlnode:children</h4>
<pre><code class="lang-lua">iter =
mtev.xmlnode:children()
</code></pre>
<ul>
<li><strong>RETURN</strong> iterator over child mtev.xmlnodes</li>
</ul>
<h4 id="mtevxmlnodecontents">mtev.xmlnode:contents</h4>
<pre><code class="lang-lua">str =
mtev.xmlnode:contents()
</code></pre>
<ul>
<li><strong>RETURN</strong> content of xml node as string</li>
</ul>
<h4 id="mtevxmlnodename">mtev.xmlnode:name</h4>
<pre><code class="lang-lua">str =
mtev.xmlnode:name()
</code></pre>
<h4 id="mtevxmlnodenext">mtev.xmlnode:next</h4>
<pre><code class="lang-lua">sibling =
mtev.xmlnode:<span class="hljs-built_in">next</span>()
</code></pre>
<ul>
<li><strong>RETURN</strong> next sibling xml node</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="c.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: C API">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Lua API","level":"1.7.2","depth":2,"previous":{"title":"C API","level":"1.7.1","depth":2,"path":"apireference/c.md","ref":"apireference/c.md","articles":[]},"dir":"ltr"},"config":{"plugins":["collapsible-menu","callouts","anchorjs"],"root":"./docs-md","styles":{"website":"styles/website.css"},"pluginsConfig":{"collapsible-menu":{},"callouts":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"fontSettings":{"theme":"night","family":"sans"},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"apireference/lua.md","mtime":"","type":"markdown"},"gitbook":{"version":"3.2.3","time":""},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-collapsible-menu/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

