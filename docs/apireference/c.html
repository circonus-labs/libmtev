
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>C API Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-callouts/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="lua.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Mount Everest</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../config/">
            
                <a href="../config/">
            
                    
                    Configuration
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../config/inherit.html">
            
                <a href="../config/inherit.html">
            
                    
                    Inheritance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../config/includes.html">
            
                <a href="../config/includes.html">
            
                    
                    Includes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../config/watchdog.html">
            
                <a href="../config/watchdog.html">
            
                    
                    Watchdog
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../config/managed.html">
            
                <a href="../config/managed.html">
            
                    
                    Managed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../config/eventer.html">
            
                <a href="../config/eventer.html">
            
                    
                    Eventer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../config/logging.html">
            
                <a href="../config/logging.html">
            
                    
                    Logging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../config/listeners.html">
            
                <a href="../config/listeners.html">
            
                    
                    Listeners
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../config/modules.html">
            
                <a href="../config/modules.html">
            
                    
                    Modules
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.8.1" data-path="../config/modules/amqp.html">
            
                <a href="../config/modules/amqp.html">
            
                    
                    amqp
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.2" data-path="../config/modules/consul.html">
            
                <a href="../config/modules/consul.html">
            
                    
                    consul
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.3" data-path="../config/modules/fq.html">
            
                <a href="../config/modules/fq.html">
            
                    
                    fq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.4" data-path="../config/modules/http_hmac_cookie.html">
            
                <a href="../config/modules/http_hmac_cookie.html">
            
                    
                    http_hmac_cookie
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.5" data-path="../config/modules/http_observer.html">
            
                <a href="../config/modules/http_observer.html">
            
                    
                    http_observer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.6" data-path="../config/modules/lua_general.html">
            
                <a href="../config/modules/lua_general.html">
            
                    
                    lua_general
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.7" data-path="../config/modules/lua_web.html">
            
                <a href="../config/modules/lua_web.html">
            
                    
                    lua_web
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.8" data-path="../config/modules/zipkin_fq.html">
            
                <a href="../config/modules/zipkin_fq.html">
            
                    
                    zipkin_fq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8.9" data-path="../config/modules/zipkin_jaeger.html">
            
                <a href="../config/modules/zipkin_jaeger.html">
            
                    
                    zipkin_jaeger
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="../config/time_durations.html">
            
                <a href="../config/time_durations.html">
            
                    
                    Time Durations
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../development/">
            
                <a href="../development/">
            
                    
                    Development
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../development/important.html">
            
                <a href="../development/important.html">
            
                    
                    Important Starting Notes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../development/mtev_main.html">
            
                <a href="../development/mtev_main.html">
            
                    
                    mtev_main
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../development/eventer.html">
            
                <a href="../development/eventer.html">
            
                    
                    Eventer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../development/eventer-aco.html">
            
                <a href="../development/eventer-aco.html">
            
                    
                    Eventer (ACO)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../development/rest.html">
            
                <a href="../development/rest.html">
            
                    
                    REST and HTTP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../development/logging.html">
            
                <a href="../development/logging.html">
            
                    
                    Logging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../development/hooks.html">
            
                <a href="../development/hooks.html">
            
                    
                    Hooks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../development/jemalloc.html">
            
                <a href="../development/jemalloc.html">
            
                    
                    jemalloc
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../operations/">
            
                <a href="../operations/">
            
                    
                    Operations
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../operations/env.html">
            
                <a href="../operations/env.html">
            
                    
                    Environment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../operations/rest.html">
            
                <a href="../operations/rest.html">
            
                    
                    REST
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../operations/telnet_console.html">
            
                <a href="../operations/telnet_console.html">
            
                    
                    Telnet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../operations/dtrace.html">
            
                <a href="../operations/dtrace.html">
            
                    
                    DTrace
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../luamtev/">
            
                <a href="../luamtev/">
            
                    
                    luamtev
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../mtev-busted/">
            
                <a href="../mtev-busted/">
            
                    
                    mtev-busted
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="./">
            
                <a href="./">
            
                    
                    Reference
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.7.1" data-path="c.html">
            
                <a href="c.html">
            
                    
                    C API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="lua.html">
            
                <a href="lua.html">
            
                    
                    Lua API
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >C API</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h3 id="a">A</h3>
<h4 id="mtevamqpsend">mtev_amqp_send</h4>
<blockquote>
<p>Publish an AMQP message to one of the configured amqp brokers.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_amqp_send</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> amqp_envelope_t_ *env, <span class="hljs-keyword">int</span> mandatory, <span class="hljs-keyword">int</span> immediate, <span class="hljs-keyword">int</span> id)</span>
</span></code></pre>
<ul>
<li><code>env</code> An envelope with a valid message. The env pointer must be word aligned.</li>
<li><code>mandatory</code> Set to non-zero if the message should be sent with the mandatory flag.</li>
<li><code>immediate</code> Set to non-zero if the message should be sent with the immediate flag.</li>
<li><code>id</code> the ID of the connection: -1 to broadcast.</li>
</ul>
<h4 id="mtevamqpsenddata">mtev_amqp_send_data</h4>
<blockquote>
<p>Publish an AMQP message to one of the configured amqp brokers.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_amqp_send_data</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *exchange, <span class="hljs-keyword">char</span> *route, <span class="hljs-keyword">int</span> mandatory, <span class="hljs-keyword">int</span> immediate, <span class="hljs-keyword">void</span> *payload,
                    <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> id)</span>
</span></code></pre>
<ul>
<li><code>exchange</code> The AMQP exchange to publish to.</li>
<li><code>route</code> The route to set on the message.</li>
<li><code>mandatory</code> Set to non-zero if the message should be sent with the mandatory flag.</li>
<li><code>immediate</code> Set to non-zero if the message should be sent with the immediate flag.</li>
<li><code>payload</code> the contents of the message.</li>
<li><code>len</code> the number of bytes present in payload.</li>
<li><code>id</code> the ID of the connection: -1 to broadcast.</li>
</ul>
<h3 id="b">B</h3>
<h4 id="mtevb32decode">mtev_b32_decode</h4>
<blockquote>
<p>Decode a base32 encoded input buffer into the provided output buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_b32_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the encoded content.</li>
<li><code>src_len</code> The size (in bytes) of the encoded data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the decoded output.  Returns zero is dest_len is too small.</li>
</ul>
<p>mtev_b32_decode decodes input until an the entire input is consumed or until an invalid base32 character is encountered.</p>
<h4 id="mtevb32encode">mtev_b32_encode</h4>
<blockquote>
<p>Encode raw data as base32 encoded output into the provided buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_b32_encode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the raw data.</li>
<li><code>src_len</code> The size (in bytes) of the raw data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the encoded output.  Returns zero is out_sz is too small.</li>
</ul>
<h4 id="mtevb32encodelen">mtev_b32_encode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain the base-32 encoding for a given number of bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_b32_encode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the raw data buffer that might be encoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to store an encoded version of an input string.</li>
</ul>
<h4 id="mtevb32maxdecodelen">mtev_b32_max_decode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain a decoded base-32-encoded string of a given length.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_b32_max_decode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the base-32-encoded string that might be decoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to decode the input string.</li>
</ul>
<h4 id="mtevb64decode">mtev_b64_decode</h4>
<blockquote>
<p>Decode a base64 encoded input buffer into the provided output buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_b64_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the encoded content.</li>
<li><code>src_len</code> The size (in bytes) of the encoded data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the decoded output.  Returns zero is dest_len is too small.</li>
</ul>
<p>mtev_b64_decode decodes input until an the entire input is consumed or until an invalid base64 character is encountered.</p>
<h4 id="mtevb64encode">mtev_b64_encode</h4>
<blockquote>
<p>Encode raw data as base64 encoded output into the provided buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_b64_encode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the raw data.</li>
<li><code>src_len</code> The size (in bytes) of the raw data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the encoded output.  Returns zero is out_sz is too small.</li>
</ul>
<p>mtev_b64_encode encodes an input string into a base64 representation with no linefeeds.</p>
<h4 id="mtevb64encodelen">mtev_b64_encode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain the base-64 encoding for a given number of bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_b64_encode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the raw data buffer that might be encoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to store an encoded version of an input string.</li>
</ul>
<h4 id="mtevb64encodev">mtev_b64_encodev</h4>
<blockquote>
<p>Encode raw data as base64 encoded output into the provided buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_b64_encodev</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> iovec *iov, size_t iov_len, <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>iov</code> The io-vectors containing the raw data.</li>
<li><code>iovcnt</code> The number of io-vectors.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the encoded output.  Returns zero is out_sz is too small.</li>
</ul>
<p>mtev_b64_encodev encodes an input string into a base64 representation with no linefeeds.</p>
<h4 id="mtevb64maxdecodelen">mtev_b64_max_decode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain a decoded base-64-encoded string of a given length.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_b64_max_decode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the base-64-encoded string that might be decoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to decode the input string.</li>
</ul>
<h3 id="c">C</h3>
<h4 id="callback">callback</h4>
<blockquote>
<p>Get the time of the last invoked callback in this thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_gettimeofeventer_impl_data_t</span> *t,
callback(<span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">void</span> *tzp)
</code></pre>
<ul>
<li><code>t</code> is the thread-local eventer data, if unknown pass NULL</li>
<li><code>now</code> a <code>struct timeval</code> to populate with the request time.</li>
<li><code>tzp</code> is ignored and for API compatibility with gettimeofday.</li>
<li><strong>RETURN</strong> 0 on success, non-zero on failure.</li>
</ul>
<p>This function returns the time of the last callback execution.  It
is fast and cheap (cheaper than gettimeofday), so if a function
wishes to know what time it is and the &quot;time of invocation&quot; is good
enough, this is considerably cheaper than a call to <code>mtev_gettimeofday</code>
or other system facilities.</p>
<h4 id="mtevclusteralivefilter">mtev_cluster_alive_filter</h4>
<blockquote>
<p>A <code>mtev_cluster_node_filter_func_t</code> for alive nodes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_cluster_node_filter_func_t</span>
mtev_cluster_alive_filter
</code></pre>
<p>This function is available to be passed as the <code>filter</code> argument to <code>mtev_cluster_filter_owners</code>.</p>
<h4 id="mtevclusteramioldestnode">mtev_cluster_am_i_oldest_node</h4>
<blockquote>
<p>Determines if the local node is the oldest node within the cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_cluster_am_i_oldest_node</span><span class="hljs-params">(<span class="hljs-keyword">const</span> mtev_cluster_t *cluster)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster in question.</li>
<li><strong>RETURN</strong> Returns mtev_false if there is a node in the cluster with a higher up-time than this one.</li>
</ul>
<h4 id="mtevclusterbyname">mtev_cluster_by_name</h4>
<blockquote>
<p>Find the cluster with the registered name.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_cluster_t</span> *
mtev_cluster_by_name(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>name</code> The name of the cluster.</li>
<li><strong>RETURN</strong> Returns a pointer to the cluster or NULL is not found.</li>
</ul>
<p>Takes a name and finds a globally registered cluster by that name.</p>
<h4 id="mtevclusterdoiown">mtev_cluster_do_i_own</h4>
<blockquote>
<p>Determines if the local node should possess a given key based on internal CHTs.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_cluster_do_i_own</span><span class="hljs-params">(mtev_cluster_t *cluster, <span class="hljs-keyword">void</span> *key, size_t klen, <span class="hljs-keyword">int</span> w)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster in question.</li>
<li><code>key</code> A pointer to the key.</li>
<li><code>klen</code> The length, in bytes, of the key.</li>
<li><code>w</code> The number of nodes that are supposed to own this key.</li>
<li><strong>RETURN</strong> Returns mtev_true or mtev_false based on ownership status.</li>
</ul>
<p>This function determines if the local node is among the w nodes in this
cluster that should own the specified key.</p>
<h4 id="mtevclusterenabled">mtev_cluster_enabled</h4>
<blockquote>
<p>Report on the availability of the clusters feature.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_cluster_enabled</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> mtev_true if clusters can be configured, otherwise mtev_false.</li>
</ul>
<h4 id="mtevclusterfilterowners">mtev_cluster_filter_owners</h4>
<blockquote>
<p>Determines if the local node should possess a given key based on internal CHTs.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_cluster_filter_owners</span><span class="hljs-params">(mtev_cluster_t *cluster, <span class="hljs-keyword">void</span> *key, size_t klen, mtev_cluster_node_t **<span class="hljs-built_in">set</span>,
                           <span class="hljs-keyword">int</span> *w, mtev_cluster_node_filter_func_t filter, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster in question.</li>
<li><code>key</code> A pointer to the key.</li>
<li><code>klen</code> The length, in bytes, of the key.</li>
<li><code>set</code> A caller allocated array of at least *w length.</li>
<li><code>w</code> The number of nodes that are supposed to own this key, updated to set length that matches filter.</li>
<li><code>filter</code> The function used to qualify nodes.</li>
<li><code>closure</code> A user supplied value that is passed to the filter function.</li>
<li><strong>RETURN</strong> Returns mtev_true or mtev_false if set[0] is this node.</li>
</ul>
<p>This function populates a set of owners for a key, but first filters them according to a user-specified function.</p>
<h4 id="mtevclusterfindnode">mtev_cluster_find_node</h4>
<blockquote>
<p>Find a node by uuid within a cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_cluster_node_t</span> *
mtev_cluster_find_node(<span class="hljs-keyword">mtev_cluster_t</span> *cluster, <span class="hljs-keyword">uuid_t</span> nodeid)
</code></pre>
<ul>
<li><code>cluster</code> The &apos;<cluster>&apos; containing the node.</cluster></li>
<li><code>nodeid</code> The nodeid being searched for.</li>
<li><strong>RETURN</strong> Returns a pointer to the mtev_cluster_node_t or NULL if not found.</li>
</ul>
<p>Takes a cluster and a node UUID and returns a pointer to the
corresponding mtev_cluster_node_t.</p>
<h4 id="mtevclustergetconfigseq">mtev_cluster_get_config_seq</h4>
<blockquote>
<p>Returns the current config sequence of the given cluster</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span>
mtev_cluster_get_config_seq(<span class="hljs-keyword">mtev_cluster_t</span> *cluster)
</code></pre>
<ul>
<li><code>cluster</code> The cluster in question, may not be NULL.</li>
</ul>
<p>This function returns the current config sequence of the given cluster</p>
<h4 id="mtevclustergetheartbeatpayload">mtev_cluster_get_heartbeat_payload</h4>
<blockquote>
<p>Gets the current value of a payload segment from a node.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_cluster_get_heartbeat_payload</span><span class="hljs-params">(mtev_cluster_t *cluster, uint8_t app_id, uint8_t key, <span class="hljs-keyword">void</span> **payload)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster in question, may not be NULL.</li>
<li><code>app_id</code> Used to identify the application that attached the payload.</li>
<li><code>key</code> Used to identify the payload amongst other payloads from the application.</li>
<li><code>payload</code> Pointer to a payload pointer.</li>
<li><strong>RETURN</strong> The length of the payload, -1 if that payload segment does not exist.</li>
</ul>
<h4 id="mtevclustergetmyboottime">mtev_cluster_get_my_boot_time</h4>
<blockquote>
<p>Returns the boot time of the local node.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">struct</span> timeval
<span class="hljs-title">mtev_cluster_get_my_boot_time</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> The boot time of the local node.</li>
</ul>
<h4 id="mtevclustergetname">mtev_cluster_get_name</h4>
<blockquote>
<p>Returns the name of the cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">mtev_cluster_get_name</span><span class="hljs-params">(mtev_cluster_t *cluster)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> a cluster</li>
<li><strong>RETURN</strong> A pointer to the cluster&apos;s name.</li>
</ul>
<h4 id="mtevclustergetnode">mtev_cluster_get_node</h4>
<blockquote>
<p>Find a node in a cluster by id.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_cluster_node_t</span> *
mtev_cluster_get_node(<span class="hljs-keyword">mtev_cluster_t</span> *cluster, <span class="hljs-keyword">uuid_t</span> id)
</code></pre>
<ul>
<li><code>cluster</code> The cluster in question.</li>
<li><code>id</code> The uuid of the node in question.</li>
<li><strong>RETURN</strong> An <code>mtev_cluster_node_t *</code> if one is found with the provided id, otherwise NULL,</li>
</ul>
<h4 id="mtevclustergetnodes">mtev_cluster_get_nodes</h4>
<blockquote>
<p>Reports all nodes in the cluster (possible excluding the local node)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_cluster_get_nodes</span><span class="hljs-params">(mtev_cluster_t *cluster, mtev_cluster_node_t **nodes, <span class="hljs-keyword">int</span> n
                       mtev_boolean includeme)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster in question.</li>
<li><code>nodes</code> The destination array to which a node list will be written.</li>
<li><code>n</code> The number of positions available in the passed nodes array.</li>
<li><code>includeme</code> Whether the local node should included in the list.</li>
<li><strong>RETURN</strong> Returns the number of nodes populated in the supplied nodes array.  If insufficient space is available, a negative value is returned whose absolute value indicates the required size of the input array.</li>
</ul>
<p>Enumerates the nodes in a cluster into a provided nodes array.</p>
<h4 id="mtevclustergetoldestnode">mtev_cluster_get_oldest_node</h4>
<blockquote>
<p>Returns the oldest node within the given cluster.</p>
</blockquote>
<pre><code class="lang-c">mtev_cluster_get_oldest_node(<span class="hljs-keyword">const</span> <span class="hljs-keyword">mtev_cluster_t</span> *cluster)
</code></pre>
<ul>
<li><code>cluster</code> The cluster in question.</li>
<li><strong>RETURN</strong> Returns the node in the given cluster with the highest up-time.</li>
</ul>
<h4 id="mtevclustergetself">mtev_cluster_get_self</h4>
<blockquote>
<p>Reports the UUID of the local node.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_cluster_get_self</span><span class="hljs-params">(uuid_t id)</span>
</span></code></pre>
<ul>
<li><code>id</code> The UUID to be updated.</li>
<li><strong>RETURN</strong> Returns -1 on error</li>
</ul>
<p>Pouplates the passed uuid_t with the local node&apos;s UUID.</p>
<h4 id="mtevclusterinit">mtev_cluster_init</h4>
<blockquote>
<p>Initialize the mtev cluster configuration.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_cluster_init</span><span class="hljs-params">()</span>
</span></code></pre>
<p>Initializes the mtev cluster configuration.</p>
<h4 id="mtevclusternodegetaddr">mtev_cluster_node_get_addr</h4>
<pre><code class="lang-c"><span class="hljs-keyword">int8_t</span>
mtev_cluster_node_get_addr(<span class="hljs-keyword">mtev_cluster_node_t</span> *node, <span class="hljs-keyword">struct</span> sockaddr **addr, <span class="hljs-keyword">socklen_t</span> *addrlen)
</code></pre>
<h4 id="mtevclusternodegetboottime">mtev_cluster_node_get_boot_time</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">struct</span> timeval
<span class="hljs-title">mtev_cluster_node_get_boot_time</span><span class="hljs-params">(mtev_cluster_node_t *node)</span>
</span></code></pre>
<pre><code>* **RETURN** boot time as timeval struct
</code></pre><h4 id="mtevclusternodegetcn">mtev_cluster_node_get_cn</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*
<span class="hljs-title">mtev_cluster_node_get_cn</span><span class="hljs-params">(mtev_cluster_node_t *node)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> cn (canonical name) of the cluster node</li>
</ul>
<h4 id="mtevclusternodegetconfigseq">mtev_cluster_node_get_config_seq</h4>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span>
mtev_cluster_node_get_config_seq(<span class="hljs-keyword">mtev_cluster_node_t</span> *node)
</code></pre>
<h4 id="mtevclusternodegetid">mtev_cluster_node_get_id</h4>
<blockquote>
<p>Retrieve the ID of a cluster node.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_cluster_node_get_id</span><span class="hljs-params">(mtev_cluster_node_t *node, uuid_t out)</span>
</span></code></pre>
<ul>
<li><code>node</code> The node in question.</li>
<li><code>out</code> A <code>uuid_t</code> to fill in.</li>
</ul>
<h4 id="mtevclusternodegetidx">mtev_cluster_node_get_idx</h4>
<blockquote>
<p>Get the unique integer idx of the node within it&apos;s cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_cluster_node_get_idx</span><span class="hljs-params">(mtev_cluster_node_t *node)</span>
</span></code></pre>
<ul>
<li><code>node</code> The node in question</li>
<li><strong>RETURN</strong> A number between 0 and cluster_size - 1.</li>
</ul>
<h4 id="mtevclusternodegetlastcontact">mtev_cluster_node_get_last_contact</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">struct</span> timeval
<span class="hljs-title">mtev_cluster_node_get_last_contact</span><span class="hljs-params">(mtev_cluster_node_t *node)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> time of last contact to the given node</li>
</ul>
<h4 id="mtevclusternodehaspayload">mtev_cluster_node_has_payload</h4>
<blockquote>
<p>Determine a cluster node has a custom payload attached.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_cluster_node_has_payload</span><span class="hljs-params">(mtev_cluster_node_t *node)</span>
</span></code></pre>
<ul>
<li><code>node</code> The node in question.</li>
<li><strong>RETURN</strong> True if there is a payload, false otherwise.</li>
</ul>
<h4 id="mtevclusternodeisdead">mtev_cluster_node_is_dead</h4>
<blockquote>
<p>Detrmines if the node in question is dead.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_cluster_node_is_dead</span><span class="hljs-params">(mtev_cluster_node_t *node)</span>
</span></code></pre>
<ul>
<li><code>node</code> The node in question.</li>
<li><strong>RETURN</strong> Returns true if the node is dead.</li>
</ul>
<h4 id="mtevclustersetheartbeatpayload">mtev_cluster_set_heartbeat_payload</h4>
<blockquote>
<p>Triggers the attachment of an arbitrary payload to the cluster heartbeats (see mtev_cluster_handle_node_update)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_cluster_set_heartbeat_payload</span><span class="hljs-params">(mtev_cluster_t *cluster, uint8_t app_id, uint8_t key, <span class="hljs-keyword">void</span>* payload
                                   uint8_t payload_length)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster in question, may not be NULL.</li>
<li><code>app_id</code> Used to identify the application that attached the payload.</li>
<li><code>key</code> Used to identify the payload amongst other payloads from the application.</li>
<li><code>payload</code> A pointer to the payload that should be attached to every heartbeat message.</li>
<li><code>payload_length</code> The number of bytes to be read from payload.</li>
<li><strong>RETURN</strong> Returns mtev_true if the payload was not enabled yet</li>
</ul>
<p>This function triggers the attachment of an arbitrary payload to the cluster heartbeats (see mtev_cluster_get_payload)</p>
<h4 id="mtevclustersetnodeupdatecallback">mtev_cluster_set_node_update_callback</h4>
<blockquote>
<p>Sets a callback which is called everytime a node in the cluster changes it&apos;s up-time.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_cluster_set_node_update_callback</span><span class="hljs-params">(mtev_cluster_t *cluster, mtev_cluster_node_update_cb callback)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster in question.</li>
<li><code>callback</code> Function pointer to the function that should be called.</li>
<li><strong>RETURN</strong> Returns mtev_true if the cluster is not NULL, mtev_false otherwise</li>
</ul>
<h4 id="mtevclustersetself">mtev_cluster_set_self</h4>
<blockquote>
<p>Sets the UUID of the local node.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_cluster_set_self</span><span class="hljs-params">(uuid_t id)</span>
</span></code></pre>
<ul>
<li><code>id</code> The UUID.</li>
</ul>
<p>Sets the local node&apos;s cluster identity, potentially updating the on-disk configuration.</p>
<h4 id="mtevclustersize">mtev_cluster_size</h4>
<blockquote>
<p>Report the number of nodes in the cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_cluster_size</span><span class="hljs-params">(mtev_cluster_t *cluster)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster.</li>
<li><strong>RETURN</strong> The number of nodes in the cluster.</li>
</ul>
<p>Determines the number of nodes in the given cluster.</p>
<h4 id="mtevclusterunsetheartbeatpayload">mtev_cluster_unset_heartbeat_payload</h4>
<blockquote>
<p>Detaches (clears) an arbitrary payload to the cluster heartbeats (see mtev_cluster_handle_node_update)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_cluster_unset_heartbeat_payload</span><span class="hljs-params">(mtev_cluster_t *cluster, uint8_t app_id, uint8_t key)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster in question, may not be NULL.</li>
<li><code>app_id</code> Used to identify the application that attached the payload.</li>
<li><code>key</code> Used to identify the payload amongst other payloads from the application.</li>
</ul>
<h4 id="mtevclusterupdate">mtev_cluster_update</h4>
<blockquote>
<p>Add or update an mtev cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_cluster_update</span><span class="hljs-params">(mtev_conf_section_t cluster)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The &apos;<cluster>&apos; node configuration.</cluster></li>
<li><strong>RETURN</strong> Returns -1 on error, 0 on insert, or 1 on update.</li>
</ul>
<p>Takes a configuration section representing a cluster and registers
it in the global cluster configuration.</p>
<h4 id="mtevconfstrparseduration">mtev_confstr_parse_duration</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_confstr_parse_duration</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *input, uint64_t *output
                            <span class="hljs-keyword">const</span> mtev_duration_definition_t *durations)</span>
</span></code></pre>
<ul>
<li><code>input</code> String representing a duration.</li>
<li><code>output</code> On successful parsing, filled in with the duration corresponding to <code>input</code>.</li>
<li><code>durations</code> Describes allowable duration suffixes when parsing.</li>
<li><strong>RETURN</strong> One of:<ul>
<li><ul>
<li>MTEV_CONFSTR_PARSE_SUCCESS
(<code>input</code> was parsed successfully, <code>output</code> filled in)</li>
</ul>
</li>
<li><ul>
<li>MTEV_CONFSTR_PARSE_ERR_FORMAT (<code>input</code> was not well-formed.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Parses a string representing a duration. The string should be
formatted as a set of (optionally) white-space separated duration
elements, where a duration element is a number with a resolution
suffix. For example, <code>&quot;1s&quot;</code> is a duration element representing one
second, while <code>&quot;3min&quot;</code> is a duration element representing three
minutes. The total duration is calculated by adding together all
the duration elements. For example, <code>&quot;1min 30sec&quot;</code>, with
resolution in seconds, would result in <code>output</code> of <code>90</code>; and
<code>&quot;1min5ms&quot;</code>, at millisecond resolution, would result in <code>output</code>
of <code>60005</code>.</p>
<h4 id="mtevconfstrparsedurationms">mtev_confstr_parse_duration_ms</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_confstr_parse_duration_ms</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *input, uint64_t *output)</span>
</span></code></pre>
<p>Convenience function for parsing a duration with resolution in milliseconds.
See <a href="#mtevconfstrparseduration">mtev_confstr_parse_duration</a>
and <a href="#mtevgetdurationsms">mtev_get_durations_ms</a>.</p>
<h4 id="mtevconfstrparsedurationns">mtev_confstr_parse_duration_ns</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_confstr_parse_duration_ns</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *input, uint64_t *output)</span>
</span></code></pre>
<p>Convenience function for parsing a duration with resolution in nanoseconds.
See <a href="#mtevconfstrparseduration">mtev_confstr_parse_duration</a>
and <a href="#mtevgetdurationsns">mtev_get_durations_ns</a>.</p>
<h4 id="mtevconfstrparsedurations">mtev_confstr_parse_duration_s</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_confstr_parse_duration_s</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *input, uint64_t *output)</span>
</span></code></pre>
<p>Convenience function for parsing a duration with resolution in seconds.
See <a href="#mtevconfstrparseduration">mtev_confstr_parse_duration</a>
and <a href="#mtevgetdurationss">mtev_get_durations_s</a>.</p>
<h4 id="mtevconfstrparsedurationus">mtev_confstr_parse_duration_us</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_confstr_parse_duration_us</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *input, uint64_t *output)</span>
</span></code></pre>
<p>Convenience function for parsing a duration with resolution in microseconds.
See <a href="#mtevconfstrparseduration">mtev_confstr_parse_duration</a>
and <a href="#mtevgetdurationsus">mtev_get_durations_us</a>.</p>
<h4 id="mtevcurlwritecallback">mtev_curl_write_callback</h4>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_curl_write_callback(<span class="hljs-keyword">char</span> *ptr, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> nmemb, <span class="hljs-keyword">void</span> *userdata)
</code></pre>
<p> *</p>
<blockquote>
<p>Pass this to CURLOPT_WRITEFUNCTION and use an mtev_decompress_curl_helper_t as the CURLOPT_WRITEDATA</p>
</blockquote>
<h3 id="d">D</h3>
<h4 id="mtevdynbufferadd">mtev_dyn_buffer_add</h4>
<blockquote>
<p>add data to the dyn_buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_add</span><span class="hljs-params">(mtev_dyn_buffer_t *buf, uint8_t *data, size_t len)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to add to.</li>
<li><code>data</code> the data to add.</li>
<li><code>len</code> the size of the data to add.</li>
</ul>
<h4 id="mtevdynbufferaddjsonstring">mtev_dyn_buffer_add_json_string</h4>
<blockquote>
<p>add data to the dyn_buffer as an unquoted json-encoded string.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_add_json_string</span><span class="hljs-params">(mtev_dyn_buffer_t *buf, uint8_t *data, size_t len)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to add to.</li>
<li><code>data</code> the data to add.</li>
<li><code>len</code> the size of the data to add.</li>
<li><code>sol</code> 1 to escape the solipsis, 0 otherwise.</li>
</ul>
<h4 id="mtevdynbufferaddprintf">mtev_dyn_buffer_add_printf</h4>
<blockquote>
<p>add data to the dyn_buffer using printf semantics.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_add_printf</span><span class="hljs-params">(mtev_dyn_buffer_t *buf, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to add to.</li>
<li><code>format</code> the printf style format string</li>
<li><code>args</code> printf arguments</li>
</ul>
<p>This does NUL terminate the format string but does not advance the write_pointer past
the NUL.  Basically, the last mtev_dyn_buffer_add_printf will leave the resultant
data NUL terminated.</p>
<h4 id="mtevdynbufferadvance">mtev_dyn_buffer_advance</h4>
<blockquote>
<p>move the write_pointer forward len bytes</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_advance</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to advance</li>
</ul>
<h4 id="mtevdynbufferdata">mtev_dyn_buffer_data</h4>
<blockquote>
<p>return the front of the dyn_buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_data</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to get the pointer from.</li>
<li><strong>RETURN</strong> the pointer to the front (beginning) of the dyn_buffer</li>
</ul>
<h4 id="mtevdynbufferdestroy">mtev_dyn_buffer_destroy</h4>
<blockquote>
<p>destroy the dyn_buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_destroy</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><p><code>buf</code> the buffer to destroy</p>
<p>This must be called at the end of dyn_buffer interactions in case the
buffer has overflowed into dynamic allocation space.</p>
</li>
</ul>
<h4 id="mtevdynbufferensure">mtev_dyn_buffer_ensure</h4>
<blockquote>
<p>possibly grow the dyn_buffer so it can fit len bytes</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_ensure</span><span class="hljs-params">(mtev_dyn_buffer_t *buf, size_t len)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to ensure</li>
<li><code>len</code> the size of the data about to be added</li>
</ul>
<h4 id="mtevdynbufferinit">mtev_dyn_buffer_init</h4>
<blockquote>
<p>initialize a dyn_buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_init</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><p><code>buf</code> the buffer to init</p>
<p>Provided for completeness or non-stack allocations.</p>
</li>
</ul>
<h4 id="mtevdynbufferreset">mtev_dyn_buffer_reset</h4>
<blockquote>
<p>move the write position to the beginning of the buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_reset</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to reset.</li>
</ul>
<h4 id="mtevdynbuffersize">mtev_dyn_buffer_size</h4>
<blockquote>
<p>return the total size of the buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_size</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to get the size from.</li>
<li><strong>RETURN</strong> the total size of the buffer</li>
</ul>
<h4 id="mtevdynbufferused">mtev_dyn_buffer_used</h4>
<blockquote>
<p>return the total used space of the buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_used</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to get the used space from.</li>
<li><strong>RETURN</strong> the total used space of the buffer</li>
</ul>
<h4 id="mtevdynbufferwritepointer">mtev_dyn_buffer_write_pointer</h4>
<blockquote>
<p>return the end of the dyn_buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_dyn_buffer_write_pointer</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to get the pointer from.</li>
<li><strong>RETURN</strong> the pointer to the end of the dyn_buffer</li>
</ul>
<h3 id="e">E</h3>
<h4 id="eventeraccept">eventer_accept</h4>
<blockquote>
<p>Execute an opset-appropriate <code>accept</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_accept</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">struct</span> sockaddr *addr, socklen_t *len, <span class="hljs-keyword">int</span> *mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>addr</code> a <code>struct sockaddr</code> to be populated.</li>
<li><code>len</code> a <code>socklen_t</code> pointer to the size of the <code>addr</code> argument; updated.</li>
<li><code>mask</code> a point the a mask. If the call does not complete, <code>*mask</code> it set.</li>
<li><strong>RETURN</strong> an opset-appropriate return value. (fd for POSIX, -1 for SSL).</li>
</ul>
<p>If the function returns -1 and <code>errno</code> is <code>EAGAIN</code>, the <code>*mask</code> reflects the
necessary activity to make progress.</p>
<h4 id="eventeracoaccept">eventer_aco_accept</h4>
<blockquote>
<p>Execute an opset-appropriate <code>accept</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_aco_accept</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">struct</span> sockaddr *addr, socklen_t *len, <span class="hljs-keyword">struct</span> timeval *timeout)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>addr</code> a <code>struct sockaddr</code> to be populated.</li>
<li><code>len</code> a <code>socklen_t</code> pointer to the size of the <code>addr</code> argument; updated.</li>
<li><code>timeout</code> if not NULL, the time after which we fail -1, ETIME</li>
<li><strong>RETURN</strong> an opset-appropriate return value. (fd for POSIX, -1 for SSL).</li>
</ul>
<h4 id="eventeracoarg">eventer_aco_arg</h4>
<blockquote>
<p>Gets the argument used to start an aco coroutine.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">eventer_aco_arg</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> The closure parameter that was passed to <code>eventer_aco_start</code>.</li>
</ul>
<h4 id="eventeracoasynch">eventer_aco_asynch</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_asynch</span><span class="hljs-params">(eventer_asynch_func_t func, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
</ul>
<h4 id="eventeracoasynchgated">eventer_aco_asynch_gated</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_asynch_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_asynch_func_t func, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate to notify on completion.</li>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
</ul>
<h4 id="eventeracoasynchqueue">eventer_aco_asynch_queue</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_asynch_queue</span><span class="hljs-params">(eventer_asynch_func_t func, <span class="hljs-keyword">void</span> *closure, eventer_jobq_t *q)</span>
</span></code></pre>
<ul>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
</ul>
<h4 id="eventeracoasynchqueuegated">eventer_aco_asynch_queue_gated</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_asynch_queue_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_asynch_func_t func, <span class="hljs-keyword">void</span> *closure
                               eventer_jobq_t *q)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate to notify on completion.</li>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
</ul>
<h4 id="eventeracoasynchqueuesubqueue">eventer_aco_asynch_queue_subqueue</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_asynch_queue_subqueue</span><span class="hljs-params">(eventer_asynch_func_t func, <span class="hljs-keyword">void</span> *closure, eventer_jobq_t *q, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
<li><code>id</code> the subqueue within the jobq.</li>
</ul>
<h4 id="eventeracoasynchqueuesubqueuedeadline">eventer_aco_asynch_queue_subqueue_deadline</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_asynch_queue_subqueue_deadline</span><span class="hljs-params">(eventer_asynch_func_t func, <span class="hljs-keyword">void</span> *closure, eventer_jobq_t *q, uint64_t id
                                           <span class="hljs-keyword">struct</span> timeval *whence)</span>
</span></code></pre>
<ul>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
<li><code>id</code> the subqueue within the jobq.</li>
<li><code>whence</code> the deadline</li>
</ul>
<h4 id="eventeracoasynchqueuesubqueuedeadlinegated">eventer_aco_asynch_queue_subqueue_deadline_gated</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_asynch_queue_subqueue_deadline_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_asynch_func_t func, <span class="hljs-keyword">void</span> *closure,
                                                 eventer_jobq_t *q, uint64_t id, <span class="hljs-keyword">struct</span> timeval *whence)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate to notify on completion</li>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
<li><code>id</code> the subqueue within the jobq.</li>
<li><code>whence</code> the deadline</li>
</ul>
<h4 id="eventeracoasynchqueuesubqueuegated">eventer_aco_asynch_queue_subqueue_gated</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_asynch_queue_subqueue_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_asynch_func_t func, <span class="hljs-keyword">void</span> *closure,
                                        eventer_jobq_t *q, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate to notify on completion.</li>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
<li><code>id</code> the subqueue within the jobq.</li>
</ul>
<h4 id="eventeracoclose">eventer_aco_close</h4>
<blockquote>
<p>Execute an opset-appropriate <code>close</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_aco_close</span><span class="hljs-params">(eventer_aco_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> 0 on sucess or -1 with errno set.</li>
</ul>
<h4 id="eventeracofree">eventer_aco_free</h4>
<blockquote>
<p>Dereferences the event specified.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_free</span><span class="hljs-params">(eventer_aco_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> the event to dereference.</li>
</ul>
<h4 id="eventeracogate">eventer_aco_gate</h4>
<blockquote>
<p>Create a new asynchronous gate.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_aco_gate_t</span>
eventer_aco_gate(<span class="hljs-keyword">void</span>)
</code></pre>
<h4 id="eventeracogatewait">eventer_aco_gate_wait</h4>
<blockquote>
<p>Wait for any asynchronous work on this gate to finish.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_gate_wait</span><span class="hljs-params">(eventer_aco_gate_t gate)</span>
</span></code></pre>
<ul>
<li><code>gate</code> an asynchronous gate</li>
</ul>
<h4 id="eventeracogetclosure">eventer_aco_get_closure</h4>
<blockquote>
<p>Retrieve an event&apos;s closure.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">eventer_aco_get_closure</span><span class="hljs-params">(eventer_aco_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> The previous closure set.</li>
</ul>
<h4 id="eventeracoread">eventer_aco_read</h4>
<blockquote>
<p>Execute an opset-appropriate <code>read</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_aco_read</span><span class="hljs-params">(eventer_aco_t e, <span class="hljs-keyword">void</span> *buff, size_t len, <span class="hljs-keyword">struct</span> timeval *timeout)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>buff</code> a buffer in which to place read data.</li>
<li><code>len</code> the size of <code>buff</code> in bytes.</li>
<li><code>timeout</code> if not NULL, the time after which we fail -1, ETIME</li>
<li><strong>RETURN</strong> the number of bytes read or -1 with errno set.</li>
</ul>
<h4 id="eventeracorunasynch">eventer_aco_run_asynch</h4>
<blockquote>
<p>Add an asynchronous event dependent on the current job and wait until completion.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_aco_run_asynch</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the default job queue.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeracorunasynchgated">eventer_aco_run_asynch_gated</h4>
<blockquote>
<p>Add an asynchronous event dependent on the current job and signal gate on completion.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_aco_run_asynch_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate</li>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the default job queue.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeracorunasynchqueue">eventer_aco_run_asynch_queue</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job and wait until completion.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_aco_run_asynch_queue</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeracorunasynchqueuegated">eventer_aco_run_asynch_queue_gated</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job and signal gate on completion.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_aco_run_asynch_queue_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_jobq_t *q, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate</li>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeracorunasynchqueuesubqueue">eventer_aco_run_asynch_queue_subqueue</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job and wait until completion.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_aco_run_asynch_queue_subqueue</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><code>id</code> is a fairly competing subqueue identifier</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeracorunasynchqueuesubqueuegated">eventer_aco_run_asynch_queue_subqueue_gated</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job and signal gate on completion.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_aco_run_asynch_queue_subqueue_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_jobq_t *q, eventer_t e, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate</li>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><code>id</code> is a fairly competing subqueue identifier</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeracosetaccepttimeout">eventer_aco_set_accept_timeout</h4>
<blockquote>
<p>Change the default timeout for ACO events.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_set_accept_timeout</span><span class="hljs-params">(eventer_aco_t e, <span class="hljs-keyword">struct</span> timeval *duration)</span>
</span></code></pre>
<ul>
<li><code>e</code> the ACO event to update.</li>
<li><code>duration</code> a timeout duration, NULL will undo the default.</li>
</ul>
<h4 id="eventeracosetclosure">eventer_aco_set_closure</h4>
<blockquote>
<p>Set an event&apos;s closure.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_set_closure</span><span class="hljs-params">(eventer_aco_t e, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>closure</code> a pointer to user-data to be supplied during callback.</li>
</ul>
<h4 id="eventeracosetreadtimeout">eventer_aco_set_read_timeout</h4>
<blockquote>
<p>Change the default timeout for ACO events.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_set_read_timeout</span><span class="hljs-params">(eventer_aco_t e, <span class="hljs-keyword">struct</span> timeval *duration)</span>
</span></code></pre>
<ul>
<li><code>e</code> the ACO event to update.</li>
<li><code>duration</code> a timeout duration, NULL will undo the default.</li>
</ul>
<h4 id="eventeracosetwritetimeout">eventer_aco_set_write_timeout</h4>
<blockquote>
<p>Change the default timeout for ACO events.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_set_write_timeout</span><span class="hljs-params">(eventer_aco_t e, <span class="hljs-keyword">struct</span> timeval *duration)</span>
</span></code></pre>
<ul>
<li><code>e</code> the ACO event to update.</li>
<li><code>duration</code> a timeout duration, NULL will undo the default.</li>
</ul>
<h4 id="eventeracosimpleasynch">eventer_aco_simple_asynch</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_simple_asynch</span><span class="hljs-params">(eventer_asynch_simple_func_t func, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
</ul>
<h4 id="eventeracosimpleasynchgated">eventer_aco_simple_asynch_gated</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_simple_asynch_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_asynch_simple_func_t func, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate to notify on completion.</li>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
</ul>
<h4 id="eventeracosimpleasynchqueue">eventer_aco_simple_asynch_queue</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_simple_asynch_queue</span><span class="hljs-params">(eventer_asynch_simple_func_t func, <span class="hljs-keyword">void</span> *closure, eventer_jobq_t *q)</span>
</span></code></pre>
<ul>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
</ul>
<h4 id="eventeracosimpleasynchqueuegated">eventer_aco_simple_asynch_queue_gated</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_simple_asynch_queue_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_asynch_simple_func_t func, <span class="hljs-keyword">void</span> *closure
                                      eventer_jobq_t *q)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate to notify on completion.</li>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
</ul>
<h4 id="eventeracosimpleasynchqueuesubqueue">eventer_aco_simple_asynch_queue_subqueue</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_simple_asynch_queue_subqueue</span><span class="hljs-params">(eventer_asynch_simple_func_t func, <span class="hljs-keyword">void</span> *closure, eventer_jobq_t *q
                                         uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
<li><code>id</code> the subqueue within the jobq.</li>
</ul>
<h4 id="eventeracosimpleasynchqueuesubqueuegated">eventer_aco_simple_asynch_queue_subqueue_gated</h4>
<blockquote>
<p>Asynchronously execute a function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_simple_asynch_queue_subqueue_gated</span><span class="hljs-params">(eventer_aco_gate_t gate, eventer_asynch_simple_func_t func, <span class="hljs-keyword">void</span> *closure,
                                               eventer_jobq_t *q, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>gate</code> a gate to notify on completion.</li>
<li><code>func</code> the function to execute.</li>
<li><code>closure</code> the closure for the function.</li>
<li><code>q</code> the jobq on which to schedule the work.</li>
<li><code>id</code> the subqueue within the jobq.</li>
</ul>
<h4 id="eventeracosleep">eventer_aco_sleep</h4>
<blockquote>
<p>Execute a sleep within an aco context.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_aco_sleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timeval *duration)</span>
</span></code></pre>
<ul>
<li><code>duration</code> the time to suspend.</li>
</ul>
<h4 id="eventeracostart">eventer_aco_start</h4>
<blockquote>
<p>Start a new aco coroutine to be eventer driven.</p>
</blockquote>
<pre><code class="lang-c">void
eventer_aco_start(void (*func)(void), void *closure)
</code></pre>
<ul>
<li><code>func</code> The function to start.</li>
<li><code>closure</code> The closure to set (available within <code>func</code> via <code>eventer_aco_arg()</code>)</li>
</ul>
<h4 id="eventeracostartstack">eventer_aco_start_stack</h4>
<blockquote>
<p>Start a new aco coroutine to be eventer driven.</p>
</blockquote>
<pre><code class="lang-c">void
eventer_aco_start_stack(void (*func)(void), void *closure, size_t stksz)
</code></pre>
<ul>
<li><code>func</code> The function to start.</li>
<li><code>closure</code> The closure to set (available within <code>func</code> via <code>eventer_aco_arg()</code>)</li>
<li><code>stksz</code> A specified maximum stack size other than the default 32k.</li>
</ul>
<h4 id="eventeracotryrunasynchqueuesubqueue">eventer_aco_try_run_asynch_queue_subqueue</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job and wait until completion.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_aco_try_run_asynch_queue_subqueue</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><code>id</code> is a fairly competing subqueue identifier</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeracowrite">eventer_aco_write</h4>
<blockquote>
<p>Execute an opset-appropriate <code>write</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_aco_write</span><span class="hljs-params">(eventer_aco_t e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buff, size_t len, <span class="hljs-keyword">struct</span> timeval *timeout)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>buff</code> a buffer containing data to write.</li>
<li><code>len</code> the size of <code>buff</code> in bytes.</li>
<li><code>timeout</code> if not NULL, the time after which we fail -1, ETIME</li>
<li><strong>RETURN</strong> the number of bytes written or -1 with errno set.</li>
</ul>
<h4 id="eventeradd">eventer_add</h4>
<blockquote>
<p>Add an event object to the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_add</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object to add.</li>
</ul>
<h4 id="eventeraddasynch">eventer_add_asynch</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_add_asynch</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.</p>
<h4 id="eventeraddasynchdep">eventer_add_asynch_dep</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_add_asynch_dep</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeraddasynchdepsubqueue">eventer_add_asynch_dep_subqueue</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_add_asynch_dep_subqueue</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><code>id</code> is a fairly competing subqueue identifier</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventeraddasynchsubqueue">eventer_add_asynch_subqueue</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_add_asynch_subqueue</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><code>id</code> is a fairly competing subqueue identifier</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.</p>
<h4 id="eventeraddat">eventer_add_at</h4>
<blockquote>
<p>Convenience function to schedule a callback at a specific time.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_add_at(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval whence)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>whence</code> the time at which to run the callback.</li>
<li><strong>RETURN</strong> N/A (C Macro).</li>
</ul>
<h4 id="eventeraddin">eventer_add_in</h4>
<blockquote>
<p>Convenience function to create an event to run a callback in the future</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_add_in(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval diff)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>diff</code> the amount of time to wait before running the callback.</li>
<li><strong>RETURN</strong> N/A (C Macro).</li>
</ul>
<h4 id="eventeraddinsus">eventer_add_in_s_us</h4>
<blockquote>
<p>Convenience function to create an event to run a callback in the future</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_add_in_s_us(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> seconds
                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> microseconds)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>seconds</code> the number of seconds to wait before running the callback.</li>
<li><code>microseconds</code> the number of microseconds (in addition to <code>seconds</code>) to wait before running the callback.</li>
<li><strong>RETURN</strong> N/A (C Macro).</li>
</ul>
<h4 id="eventeraddrecurrent">eventer_add_recurrent</h4>
<blockquote>
<p>Add an event to run during every loop cycle.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_add_recurrent</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
</ul>
<p><code>e</code> must have a mask of EVENER<em>RECURRENT.  This event will be invoked on
a single thread (dictated by <code>e</code>) once for each pass through the eventer loop.
This happens _often</em>, so do light work.</p>
<h4 id="eventeraddtimed">eventer_add_timed</h4>
<blockquote>
<p>Add a timed event to the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_add_timed</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
</ul>
<p>This adds the <code>e</code> event to the eventer. <code>e</code> must have a mask of
<code>EVENTER_TIMED</code>.</p>
<h4 id="eventeraddtimernextopportunity">eventer_add_timer_next_opportunity</h4>
<blockquote>
<p>Convenience function to schedule a callback to run in a specific event-loop thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_add_timer_next_opportunity(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">pthread_t</span> owner)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>owner</code> the event-loop thread in which to run the callback.</li>
<li><strong>RETURN</strong> N/A (C Macro).</li>
</ul>
<h4 id="eventeralloc">eventer_alloc</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_alloc()
</code></pre>
<ul>
<li><strong>RETURN</strong> A newly allocated event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventerallocasynch">eventer_alloc_asynch</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_alloc_asynch(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><strong>RETURN</strong> A newly allocated asynch event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventerallocasynchtimeout">eventer_alloc_asynch_timeout</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_alloc_asynch_timeout(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval *deadline)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><code>deadline</code> an absolute time by which the task must be completed.</li>
<li><strong>RETURN</strong> A newly allocated asynch event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.  Depending on the timeout method, there are not hard
guarantees on enforcing the deadline; this is more of a guideline for
the schedule and the job could be aborted (where the <code>EVENTER_ASYNCH_WORK</code>
phase is not finished or even started, but the <code>EVENTER_ASYNCH_CLEANUP</code>
will be called).</p>
<h4 id="eventeralloccopy">eventer_alloc_copy</h4>
<blockquote>
<p>Allocate an event copied from another to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_alloc_copy(<span class="hljs-keyword">eventer_t</span> src)
</code></pre>
<ul>
<li><code>src</code> a source eventer_t to copy.</li>
<li><strong>RETURN</strong> A newly allocated event that is a copy of src.</li>
</ul>
<p>The allocated event has a refernce count of 1.</p>
<h4 id="eventerallocfd">eventer_alloc_fd</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_alloc_fd(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> mask)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><code>fd</code> The file descriptor.</li>
<li><code>mask</code> The mask of activity of interest.</li>
<li><strong>RETURN</strong> A newly allocated fd event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventerallocrecurrent">eventer_alloc_recurrent</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_alloc_recurrent(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><strong>RETURN</strong> A newly allocated recurrent event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventeralloctimer">eventer_alloc_timer</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_alloc_timer(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval *whence)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><code>whence</code> The time at which the event should fire.</li>
<li><strong>RETURN</strong> A newly allocated timer event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventeralloctimernextopportunity">eventer_alloc_timer_next_opportunity</h4>
<blockquote>
<p>Convenience function to create an event to run a callback on a specific thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_alloc_timer_next_opportunity(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">pthread_t</span> owner)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>owner</code> the event-loop thread on which to run the callback.</li>
<li><strong>RETURN</strong> an event that has not been added to the eventer.</li>
</ul>
<blockquote>
<p>Note this does not actually schedule the event. See <a href="c.html#eventeraddtimernextopportunity"><code>eventer_add_timer_next_opportunity</code></a>.</p>
</blockquote>
<h4 id="eventerallocationscurrent">eventer_allocations_current</h4>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span>
eventer_allocations_current()
</code></pre>
<ul>
<li><strong>RETURN</strong> the number of currently allocated eventer objects.</li>
</ul>
<h4 id="eventerallocationstotal">eventer_allocations_total</h4>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span>
eventer_allocations_total()
</code></pre>
<ul>
<li><strong>RETURN</strong> the number of allocated eventer objects over the life of the process.</li>
</ul>
<h4 id="eventerat">eventer_at</h4>
<blockquote>
<p>Convenience function to create an event to run a callback at a specific time.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_at(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval whence)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>whence</code> the time at which to run the callback.</li>
<li><strong>RETURN</strong> an event that has not been added to the eventer.</li>
</ul>
<blockquote>
<p>Note this does not actually schedule the event. See <a href="c.html#eventeraddat"><code>eventer_add_at</code></a>.</p>
</blockquote>
<h4 id="eventercallback">eventer_callback</h4>
<blockquote>
<p>Directly invoke an event&apos;s callback.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_callback</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> mask, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval *now)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>mask</code> the mask that callback should be acting upon (see <code>eventer_get_mask</code>)</li>
<li><code>closure</code> the closure on which the callback should act</li>
<li><code>now</code> the time the callback should see as &quot;now&quot;.</li>
<li><strong>RETURN</strong> The return value of the callback function as invoked.</li>
</ul>
<p>This does not call the callback in the contexts of the eventloop.  This means
that should the callback return a mask, the event-loop will not interpret it
and change state appropriately.  The caller must respond appropriately to any
return values.</p>
<h4 id="eventercallbackforname">eventer_callback_for_name</h4>
<blockquote>
<p>Find an event callback function that has been registered by name.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">evneter_func_t</span>
eventer_callback_for_name(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>name</code> the name of the callback.</li>
<li><strong>RETURN</strong> the function pointer or NULL if no such callback has been registered.</li>
</ul>
<h4 id="eventercallbackms">eventer_callback_ms</h4>
<blockquote>
<p>Get the milliseconds since epoch of the current callback invocation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span>
eventer_callback_ms()
</code></pre>
<ul>
<li><strong>RETURN</strong> milliseconds since epoch of callback invocation, or current time.</li>
</ul>
<h4 id="eventercallbackus">eventer_callback_us</h4>
<blockquote>
<p>Get the microseconds since epoch of the current callback invocation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span>
eventer_callback_us()
</code></pre>
<ul>
<li><strong>RETURN</strong> microseconds since epoch of callback invocation, or current time.</li>
</ul>
<h4 id="eventerchooseowner">eventer_choose_owner</h4>
<blockquote>
<p>Find a thread in the default eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">pthread_t</span>
eventer_choose_owner(<span class="hljs-keyword">int</span> n)
</code></pre>
<ul>
<li><code>n</code> an integer.</li>
<li><strong>RETURN</strong> a pthread_t of an eventer loop thread in the default eventer pool.</li>
</ul>
<p>This return the first thread when 0 is passed as an argument.  All non-zero arguments
are spread across the remaining threads (if existent) as <code>n</code> modulo one less than
the concurrency of the default event pool.</p>
<p>This is done because many systems aren&apos;t thread safe and can only schedule their
work on a single thread (thread 1). By spreading all thread-safe workloads across
the remaining threads we reduce potential overloading of the &quot;main&quot; thread.</p>
<p>To assign an event to a thread, use the result of this function to assign:
<code>e-&gt;thr_owner</code>.</p>
<h4 id="eventerchooseownerpool">eventer_choose_owner_pool</h4>
<blockquote>
<p>Find a thread in a specific eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">pthread_t</span>
eventer_choose_owner_pool(<span class="hljs-keyword">eventer_pool_t</span> *pool, <span class="hljs-keyword">int</span> n)
</code></pre>
<ul>
<li><code>pool</code> an eventer pool.</li>
<li><code>n</code> an integer.</li>
<li><strong>RETURN</strong> a pthread_t of an eventer loop thread in the specified evneter pool.</li>
</ul>
<p>This function chooses a thread within the specified pool by taking <code>n</code>
modulo the concurrency of the pool.  If the default pool is speicified, special
assignment behavior applies. See <a href="c.html#eventerchooseowner"><code>eventer_choose_owner</code></a>.</p>
<p>To assign an event to a thread, use the result of this function to assign:
<code>e-&gt;thr_owner</code>.</p>
<h4 id="eventerclose">eventer_close</h4>
<blockquote>
<p>Execute an opset-appropriate <code>close</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_close</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> *mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>mask</code> a point the a mask. If the call does not complete, <code>*mask</code> it set.</li>
<li><strong>RETURN</strong> 0 on sucess or -1 with errno set.</li>
</ul>
<p>If the function returns -1 and <code>errno</code> is <code>EAGAIN</code>, the <code>*mask</code> reflects the
necessary activity to make progress.</p>
<h4 id="eventerderef">eventer_deref</h4>
<blockquote>
<p>See eventer_free.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_deref</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> the event to dereference.</li>
<li><strong>RETURN</strong> <code>mtev_true</code> if the event was freed.</li>
</ul>
<h4 id="eventerfdopsetgetaccept">eventer_fd_opset_get_accept</h4>
<blockquote>
<p>Retrieve the accept function from an fd opset.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_accept_t</span>
eventer_fd_opset_get_accept(<span class="hljs-keyword">eventer_fd_opset_t</span> opset)
</code></pre>
<ul>
<li><code>opset</code> an opset (see <code>eventer_get_fd_opset</code>)</li>
<li><strong>RETURN</strong> An eventer_fd_accept_t function</li>
</ul>
<h4 id="eventerfdopsetgetclose">eventer_fd_opset_get_close</h4>
<blockquote>
<p>Retrieve the close function from an fd opset.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_close_t</span>
eventer_fd_opset_get_close(<span class="hljs-keyword">eventer_fd_opset_t</span> opset)
</code></pre>
<ul>
<li><code>opset</code> an opset (see <code>eventer_get_fd_opset</code>)</li>
<li><strong>RETURN</strong> An eventer_fd_close_t function</li>
</ul>
<h4 id="eventerfdopsetgetread">eventer_fd_opset_get_read</h4>
<blockquote>
<p>Retrieve the read function from an fd opset.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_read_t</span>
eventer_fd_opset_get_read(<span class="hljs-keyword">eventer_fd_opset_t</span> opset)
</code></pre>
<ul>
<li><code>opset</code> an opset (see <code>eventer_get_fd_opset</code>)</li>
<li><strong>RETURN</strong> An eventer_fd_read_t function</li>
</ul>
<h4 id="eventerfdopsetgetwrite">eventer_fd_opset_get_write</h4>
<blockquote>
<p>Retrieve the write function from an fd opset.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_write_t</span>
eventer_fd_opset_get_write(<span class="hljs-keyword">eventer_fd_opset_t</span> opset)
</code></pre>
<ul>
<li><code>opset</code> an opset (see <code>eventer_get_fd_opset</code>)</li>
<li><strong>RETURN</strong> An eventer_fd_write_t function</li>
</ul>
<h4 id="eventerfindfd">eventer_find_fd</h4>
<blockquote>
<p>Find an event object in the eventer system by file descriptor.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_find_fd(<span class="hljs-keyword">int</span> e)
</code></pre>
<ul>
<li><code>fd</code> a file descriptor</li>
<li><strong>RETURN</strong> the event object if it exists; NULL if not found.</li>
</ul>
<h4 id="eventerforeachfdevent">eventer_foreach_fdevent</h4>
<blockquote>
<p>Run a user-provided function over all registered file descriptor events.</p>
</blockquote>
<pre><code class="lang-c">void
eventer_foreach_fdevent(void (*fn)(eventer_t, void *), void *closure)
</code></pre>
<ul>
<li><code>fn</code> a function to be called with each event and <code>closure</code> as its arguments.</li>
<li><code>closure</code> the second argument to be passed to <code>fn</code>.</li>
</ul>
<h4 id="eventerforeachtimedevent">eventer_foreach_timedevent</h4>
<blockquote>
<p>Run a user-provided function over all registered timed events.</p>
</blockquote>
<pre><code class="lang-c">void
eventer_foreach_timedevent(void (*fn)(eventer_t, void *), void *closure)
</code></pre>
<ul>
<li><code>fn</code> a function to be called with each event and <code>closure</code> as its arguments.</li>
<li><code>closure</code> the second argument to be passed to <code>fn</code>.</li>
</ul>
<h4 id="eventerfree">eventer_free</h4>
<blockquote>
<p>Dereferences the event specified.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_free</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> the event to dereference.</li>
<li><strong>RETURN</strong> <code>mtev_true</code> if the event was freed.</li>
</ul>
<h4 id="eventergetcallback">eventer_get_callback</h4>
<blockquote>
<p>Retrieve the callback function for an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_func_t</span>
eventer_get_callback(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> An <code>eventer_func_t</code> callback function.</li>
</ul>
<h4 id="eventergetclosure">eventer_get_closure</h4>
<blockquote>
<p>Retrieve an event&apos;s closure.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">eventer_get_closure</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> The previous closure set.</li>
</ul>
<h4 id="eventergetcontext">eventer_get_context</h4>
<blockquote>
<p>Get a context for an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_get_context</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> ctx_idx)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>ctx_idx</code> is an idx returned from <code>eventer_register_context</code></li>
<li><strong>RETURN</strong> The attached context.</li>
</ul>
<h4 id="eventergetepoch">eventer_get_epoch</h4>
<blockquote>
<p>Find the start time of the eventer loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_get_epoch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timeval *epoch)</span>
</span></code></pre>
<ul>
<li><code>epoch</code> a point to a <code>struct timeval</code> to fill out.</li>
<li><strong>RETURN</strong> 0 on success; -1 on failure (eventer loop not started).</li>
</ul>
<h4 id="eventergetfd">eventer_get_fd</h4>
<blockquote>
<p>Retrieve the file descriptor for an fd-based event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_get_fd</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> a file descriptor.</li>
</ul>
<h4 id="eventergetfdopset">eventer_get_fd_opset</h4>
<blockquote>
<p>Retrieve the fd opset from an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_opset_t</span>
eventer_get_fd_opset(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> The currently active opset for a fd-based eventer_t.</li>
</ul>
<h4 id="eventergetmask">eventer_get_mask</h4>
<blockquote>
<p>Retrieve the mask for an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_get_mask</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><p><strong>RETURN</strong> a mask of bitwise-or&apos;d valued.</p>
<ul>
<li><code>EVENTER_READ</code> -- trigger/set when a file descriptor is readable.</li>
<li><code>EVENTER_WRITE</code> -- trigger/set when a file descriptor is writeable.</li>
<li><code>EVENTER_EXCEPTION</code> -- trigger/set problems with a file descriptor.</li>
<li><code>EVENTER_TIMER</code> -- trigger/set at a specific time.</li>
<li><code>EVENTER_RECURRENT</code> -- trigger/set on each pass through the event-loop.</li>
<li><code>EVENTER_ASYNCH_COMPLETE</code> -- trigger from a non-event-loop thread, set upon completion.</li>
<li><code>EVENTER_ASYNCH_WORK</code> -- set during asynchronous work.</li>
<li><code>EVENTER_ASYNCH_CLEANUP</code> -- set during asynchronous cleanup.</li>
</ul>
</li>
</ul>
<h4 id="eventergetowner">eventer_get_owner</h4>
<blockquote>
<p>Retrieve the thread that owns an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">pthread_t</span>
eventer_get_owner(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> a <code>pthread_t</code> thread.</li>
</ul>
<h4 id="eventergetpoolforevent">eventer_get_pool_for_event</h4>
<blockquote>
<p>Determin which eventer pool owns a given event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_pool_t</span> *
eventer_get_pool_for_event(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object.</li>
<li><strong>RETURN</strong> the <code>eventer_pool_t</code> to which the event is scheduled.</li>
</ul>
<h4 id="eventergetthisevent">eventer_get_this_event</h4>
<blockquote>
<p>Get the eventer_t (if any) of which we are currently in the callback.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_get_this_event(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><strong>RETURN</strong> An eventer_t or NULL.</li>
</ul>
<h4 id="eventergetthreadname">eventer_get_thread_name</h4>
<blockquote>
<p>Retrieve a human-friendly name for an eventer thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">eventer_get_thread_name</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> A thread name.</li>
</ul>
<h4 id="eventergetwhence">eventer_get_whence</h4>
<blockquote>
<p>Retrieve the time at which a timer event will fire.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">struct</span> timeval
<span class="hljs-title">eventer_get_whence</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> A absolute time.</li>
</ul>
<h4 id="eventerheartbeatdeadline">eventer_heartbeat_deadline</h4>
<blockquote>
<p>Return the remaining time before the watchdog timeout on this thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_heartbeat_deadline</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">struct</span> timeval *delta)</span>
</span></code></pre>
<ul>
<li><code>now</code> the current time (NULL means now)</li>
<li><code>delta</code> the relative time remaining before a watchdog</li>
<li><strong>RETURN</strong> mtev_true if the timeout was successfully calculated.</li>
</ul>
<h4 id="eventerimplpropset">eventer_impl_propset</h4>
<blockquote>
<p>Set properties for the event loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_impl_propset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *value)</span>
</span></code></pre>
<ul>
<li><code>key</code> the property</li>
<li><code>value</code> the property&apos;s value.</li>
<li><strong>RETURN</strong> 0 on success, -1 otherwise.</li>
</ul>
<p>Sets propoerties within the eventer. That can only be called prior
to <a href="c.html#eventerinit"><code>eventer_init</code></a>. See [Eventer configuuration)(../config/eventer.md)
for valid properties.</p>
<h4 id="eventerimplsetrlimit">eventer_impl_setrlimit</h4>
<blockquote>
<p>Attempt to set the rlimit on allowable open files.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_impl_setrlimit</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> the limit of the number of open files.</li>
</ul>
<p>The target is the <code>rlim_nofiles</code> eventer config option. If that configuration
option is unspecified, 1048576 is used.</p>
<h4 id="eventerin">eventer_in</h4>
<blockquote>
<p>Convenience function to create an event to run a callback in the future</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_in(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval diff)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>diff</code> the amount of time to wait before running the callback.</li>
<li><strong>RETURN</strong> an event that has not been added to the eventer.</li>
</ul>
<blockquote>
<p>Note this does not actually schedule the event. See <a href="c.html#eventeraddin"><code>eventer_add_in</code></a>.</p>
</blockquote>
<h4 id="eventerinloop">eventer_in_loop</h4>
<blockquote>
<p>Determine if the current thread is an event loop thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_in_loop</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> mtev_true if currently in an event loop thread, mtev_false otherwise.</li>
</ul>
<h4 id="eventerinsus">eventer_in_s_us</h4>
<blockquote>
<p>Convenience function to create an event to run a callback in the future</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_in_s_us(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> seconds
                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> microseconds)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>seconds</code> the number of seconds to wait before running the callback.</li>
<li><code>microseconds</code> the number of microseconds (in addition to <code>seconds</code>) to wait before running the callback.</li>
<li><strong>RETURN</strong> an event that has not been added to the eventer.</li>
</ul>
<blockquote>
<p>Note this does not actually schedule the event. See <a href="c.html#eventeraddinsus"><code>eventer_add_in_s_us</code></a>.</p>
</blockquote>
<h4 id="eventerinitglobals">eventer_init_globals</h4>
<blockquote>
<p>Initialize global structures required for eventer operation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_init_globals</span><span class="hljs-params">()</span>
</span></code></pre>
<p>This function is called by <a href="c.html#mtevmain"><code>mtev_main</code></a>.  Developers should not
need to call this function directly.</p>
<h4 id="eventerisaco">eventer_is_aco</h4>
<blockquote>
<p>Determine if an event is in ACO mode.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_is_aco</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> The eventer_t in question (NULL represent &quot;current context&quot;)</li>
<li><strong>RETURN</strong> True if in ACO mode, false otherwise.</li>
</ul>
<h4 id="eventerisloop">eventer_is_loop</h4>
<blockquote>
<p>Determine if a thread is participating in the eventer loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_is_loop</span><span class="hljs-params">(pthread_t tid)</span>
</span></code></pre>
<ul>
<li><code>tid</code> a thread</li>
<li><strong>RETURN</strong> 0 if the specified thread lives outside the eventer loop; 1 otherwise.</li>
</ul>
<h4 id="eventerjobqcreate">eventer_jobq_create</h4>
<blockquote>
<p>Create a new jobq.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_jobq_t</span> *
eventer_jobq_create(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *queue_name)
</code></pre>
<ul>
<li><code>queue_name</code> a name for the new jobq</li>
<li><strong>RETURN</strong> a pointer to a new (or existing) jobq with that name. NULL on error.</li>
</ul>
<h4 id="eventerjobqcreatebackq">eventer_jobq_create_backq</h4>
<blockquote>
<p>Create a new jobq for use as a return queue.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_jobq_t</span> *
eventer_jobq_create_backq(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *queue_name)
</code></pre>
<ul>
<li><code>queue_name</code> a name for the new jobq</li>
<li><strong>RETURN</strong> a pointer to a new (or existing) jobq with that name. NULL on error.</li>
</ul>
<h4 id="eventerjobqcreatems">eventer_jobq_create_ms</h4>
<blockquote>
<p>Create a new jobq with the specified memory safety.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_jobq_t</span> *
eventer_jobq_create_ms(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *queue_name, <span class="hljs-keyword">eventer_jobq_memory_safety_t</span> safety)
</code></pre>
<ul>
<li><code>queue_name</code> a name for the new jobq</li>
<li><code>safety</code> a specific mtev_memory safey level for epoch-based memory reclamation schemes.</li>
<li><strong>RETURN</strong> a pointer to a new (or existing) jobq with that name. NULL on error.</li>
</ul>
<h4 id="eventerjobqdestroy">eventer_jobq_destroy</h4>
<blockquote>
<p>Destory a jobq.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_destroy</span><span class="hljs-params">(eventer_jobq_t *jobq)</span>
</span></code></pre>
<h4 id="eventerjobqdrainandshutdown">eventer_jobq_drain_and_shutdown</h4>
<blockquote>
<p>Make a jobq unable to accept new jobs and drain all inflight jobs.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_drain_and_shutdown</span><span class="hljs-params">(eventer_jobq_t *jobq)</span>
</span></code></pre>
<ul>
<li><code>jobq</code> the joqs to drain and shut down</li>
</ul>
<h4 id="eventerjobqinflight">eventer_jobq_inflight</h4>
<blockquote>
<p>Reveal the currently executing job (visiable to a callee).</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_job_t</span> *
eventer_jobq_inflight(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><strong>RETURN</strong> the job that is currentlt running in the calling thread.</li>
</ul>
<h4 id="eventerjobqpost">eventer_jobq_post</h4>
<blockquote>
<p>Wake up a jobq to see if there are pending events.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_post</span><span class="hljs-params">(eventer_jobq_t *jobq)</span>
</span></code></pre>
<ul>
<li><code>jobq</code> the jobq to post to.</li>
</ul>
<h4 id="eventerjobqretrieve">eventer_jobq_retrieve</h4>
<blockquote>
<p>Find a jobq by name.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_jobq_t</span> *
eventer_jobq_retrieve(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>name</code> the name of a jobq</li>
<li><strong>RETURN</strong> a jobq or NULL if no such jobq exists.</li>
</ul>
<h4 id="eventerjobqsetconcurrency">eventer_jobq_set_concurrency</h4>
<blockquote>
<p>Set a jobq&apos;s concurrency level.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_set_concurrency</span><span class="hljs-params">(eventer_jobq_t *jobq, uint32_t new_concurrency)</span>
</span></code></pre>
<ul>
<li><code>jobq</code> the jobq to modify</li>
<li><code>new_concurrency</code> the new number of desired threads</li>
</ul>
<h4 id="eventerjobqsetfloor">eventer_jobq_set_floor</h4>
<blockquote>
<p>Set a jobq&apos;s minimum active thread count.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_set_floor</span><span class="hljs-params">(eventer_jobq_t *jobq, uint32_t new_floor)</span>
</span></code></pre>
<ul>
<li><code>jobq</code> the jobq to modify</li>
<li><code>new_floor</code> the new number of minimum threads</li>
</ul>
<h4 id="eventerjobqsetlifo">eventer_jobq_set_lifo</h4>
<blockquote>
<p>Instruct the jobq system to process jobs in LIFO vs. FIFO ordering.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_set_lifo</span><span class="hljs-params">(eventer_jobq_t *jobq, mtev_boolean nv)</span>
</span></code></pre>
<ul>
<li><code>jobq</code> the jobq to modify</li>
<li><code>nv</code> Use LIFO or FIFO ordering if true or false, respectively.</li>
</ul>
<h4 id="eventerjobqsetmaxbacklog">eventer_jobq_set_max_backlog</h4>
<blockquote>
<p>Set and advisory limit on the backlog a jobq will handle.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_set_max_backlog</span><span class="hljs-params">(eventer_jobq_t *jobq, uint32_t max)</span>
</span></code></pre>
<ul>
<li><code>jobq</code> the jobq to modify</li>
<li><code>max</code> a maximum pending jobs count before eventer_try_add_asynch calls will fail.</li>
</ul>
<h4 id="eventerjobqsetminmax">eventer_jobq_set_min_max</h4>
<blockquote>
<p>Set the upper and lower bounds on desired concurrency for a jobq.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_set_min_max</span><span class="hljs-params">(eventer_jobq_t *jobq, uint32_t min, uint32_t max)</span>
</span></code></pre>
<ul>
<li><code>jobq</code> the jobq to modify</li>
<li><code>min</code> a minimum number of threads to maintain</li>
<li><code>max</code> a maximum number of threads to not exceed</li>
</ul>
<h4 id="eventerjobqsetshortname">eventer_jobq_set_shortname</h4>
<blockquote>
<p>Set a &quot;shorter&quot; name for a jobq to be used in terse displays.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_jobq_set_shortname</span><span class="hljs-params">(eventer_jobq_t *jobq, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span>
</span></code></pre>
<ul>
<li><code>jobq</code> the jobq to modify</li>
<li><code>name</code> a shorter name for a job (clipped to 13 characters)</li>
</ul>
<h4 id="eventerloop">eventer_loop</h4>
<blockquote>
<p>Start the event loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_loop</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> N/A (does not return)</li>
</ul>
<p>This function should be called as that last thing in your <code>child_main</code> function.
See <a href="c.html#mtevmain%60"><code>mtev_main</code></a>.</p>
<h4 id="eventerloopconcurrency">eventer_loop_concurrency</h4>
<blockquote>
<p>Determine the concurrency of the default eventer loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_loop_concurrency</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> number of threads used for the default eventer loop.</li>
</ul>
<h4 id="eventerloopreturn">eventer_loop_return</h4>
<blockquote>
<p>Start the event loop and return control to the caller.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_loop_return</span><span class="hljs-params">()</span>
</span></code></pre>
<p>This function should be called as that last thing in your <code>child_main</code> function.
Be sure not to return or exit after calling this as it could terminate your program.
See <a href="c.html#mtevmain%60"><code>mtev_main</code></a>.</p>
<h4 id="eventernamecallback">eventer_name_callback</h4>
<blockquote>
<p>Register a human/developer readable name for a eventer callback function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_name_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, eventer_func_t callback)</span>
</span></code></pre>
<ul>
<li><code>name</code> the human readable name.  You should select clear/unique names for clarity in debugging.</li>
<li><code>callback</code> the function pointer of the eventer callback.</li>
<li><strong>RETURN</strong> 0 on success.</li>
</ul>
<h4 id="eventernamecallbackext">eventer_name_callback_ext</h4>
<blockquote>
<p>Register a functional describer for a callback and it&apos;s event object.</p>
</blockquote>
<pre><code class="lang-c">int
eventer_name_callback_ext(const char *name, eventer_func_t callback, void (*fn)(char *buff, int bufflen,
                          eventer_t e, void *closure), void *closure)
</code></pre>
<ul>
<li><code>name</code> the human readable name.  You should select clear/unique names for clarity in debugging.</li>
<li><code>callback</code> the function pointer of the eventer callback.</li>
<li><code>fn</code> function to call when describing the event. It should write a null terminated string into buff (no more than bufflen).  If this is defined, it will override the &quot;name&quot; paramter when eventer_name_for_callback is called.</li>
<li><strong>RETURN</strong> 0 on success.</li>
</ul>
<p>This function allows more in-depth descriptions of events.  When an event
is displayed (over the console or REST endpoints), this function is called
with the event in question and the closure specified at registration time.</p>
<h4 id="eventernameforcallback">eventer_name_for_callback</h4>
<blockquote>
<p>Retrieve a human readable name for the provided callback with event context.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">eventer_name_for_callback</span><span class="hljs-params">(evneter_func_t f, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>f</code> a callback function.</li>
<li><code>e</code> and event object</li>
<li><strong>RETURN</strong> name of callback</li>
</ul>
<p>The returned value may be a pointer to reusable thread-local storage.
The value should be used before a subsequent call to this function.
Aside from that caveat, it is thread-safe.</p>
<h4 id="eventerpool">eventer_pool</h4>
<blockquote>
<p>Find an eventer pool by name.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_pool_t</span> *
eventer_pool(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>name</code> the name of an eventer pool.</li>
<li><strong>RETURN</strong> an <code>eventer_pool_t *</code> by the given name, or NULL.</li>
</ul>
<h4 id="eventerpoolconcurrency">eventer_pool_concurrency</h4>
<blockquote>
<p>Retrieve the concurrency of an eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint32_t</span>
eventer_pool_concurrency(<span class="hljs-keyword">eventer_pool_t</span> *pool)
</code></pre>
<ul>
<li><code>pool</code> an eventer pool.</li>
<li><strong>RETURN</strong> the number of threads powering the specified pool.</li>
</ul>
<h4 id="eventerpoolname">eventer_pool_name</h4>
<blockquote>
<p>Retrieve the name of an eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">eventer_pool_name</span><span class="hljs-params">(eventer_pool_t *pool)</span>
</span></code></pre>
<ul>
<li><code>pool</code> an eventer pool.</li>
<li><strong>RETURN</strong> the name of the eventer pool.</li>
</ul>
<h4 id="eventerpoolwatchdogtimeout">eventer_pool_watchdog_timeout</h4>
<blockquote>
<p>Set a custom watchdog timeout for threads in an eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_pool_watchdog_timeout</span><span class="hljs-params">(eventer_pool_t *pool, <span class="hljs-keyword">double</span> timeout)</span>
</span></code></pre>
<ul>
<li><code>pool</code> an eventer pool</li>
<li><code>timeout</code> the deadman timer in seconds.</li>
</ul>
<h4 id="eventerread">eventer_read</h4>
<blockquote>
<p>Execute an opset-appropriate <code>read</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_read</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">void</span> *buff, size_t len, <span class="hljs-keyword">int</span> *mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>buff</code> a buffer in which to place read data.</li>
<li><code>len</code> the size of <code>buff</code> in bytes.</li>
<li><code>mask</code> a point the a mask. If the call does not complete, <code>*mask</code> it set.</li>
<li><strong>RETURN</strong> the number of bytes read or -1 with errno set.</li>
</ul>
<p>If the function returns -1 and <code>errno</code> is <code>EAGAIN</code>, the <code>*mask</code> reflects the
necessary activity to make progress.</p>
<h4 id="eventerref">eventer_ref</h4>
<blockquote>
<p>Add a reference to an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_ref</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> the event to reference.</li>
</ul>
<p>Adding a reference to an event will prevent it from being deallocated
prematurely.  This is classic reference counting.  It is are that one
needs to maintain an actual event past the point where the eventer
system would normally free it.  Typically, one will allocate a new
event and copy the contents of the old event into it allowing the
original to be freed.</p>
<h4 id="eventerregistercontext">eventer_register_context</h4>
<blockquote>
<p>Register an eventer carry context.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_register_context</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, eventer_context_opset_t *opset)</span>
</span></code></pre>
<ul>
<li><code>name</code> a string naming the context class.</li>
<li><code>opset</code> an opset for context maintenance</li>
<li><strong>RETURN</strong> A <code>ctx_idx</code>, -1 on failure.</li>
</ul>
<h4 id="eventerremove">eventer_remove</h4>
<blockquote>
<p>Remove an event object from the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_remove(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object to add.</li>
<li><strong>RETURN</strong> the event object removed if found; NULL if not found.</li>
</ul>
<h4 id="eventerremovefd">eventer_remove_fd</h4>
<blockquote>
<p>Remove an event object from the eventer system by file descriptor.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_remove_fd(<span class="hljs-keyword">int</span> e)
</code></pre>
<ul>
<li><code>fd</code> a file descriptor</li>
<li><strong>RETURN</strong> the event object removed if found; NULL if not found.</li>
</ul>
<h4 id="eventerremovefde">eventer_remove_fde</h4>
<blockquote>
<p>Removes an fd event from the eventloop based on filedescriptor alone.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_remove_fde(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> The event removed, NULL if no event was present.</li>
</ul>
<h4 id="eventerremoverecurrent">eventer_remove_recurrent</h4>
<blockquote>
<p>Remove a recurrent event from the eventer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_remove_recurrent(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object.</li>
<li><strong>RETURN</strong> The event removed (<code>== e</code>); NULL if not found.</li>
</ul>
<h4 id="eventerremovetimed">eventer_remove_timed</h4>
<blockquote>
<p>Remove a timed event from the eventer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
eventer_remove_timed(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object (mask must be <code>EVENTER_TIMED</code>).</li>
<li><strong>RETURN</strong> the event removed, NULL if not found.</li>
</ul>
<h4 id="eventerruncallback">eventer_run_callback</h4>
<blockquote>
<p>Run a callback as the eventer would</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_run_callback</span><span class="hljs-params">(eventer_funt_t f, eventer_t e, <span class="hljs-keyword">int</span> mask, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval *now
                     uint64_t *dur)</span>
</span></code></pre>
<ul>
<li><code>f</code> The callback function (should always be eventer_get_callback(e))</li>
<li><code>e</code> The event to execute</li>
<li><code>mask</code> The mask observed.</li>
<li><code>closure</code> The closure (should always be eventer_get_closure(e))</li>
<li><code>now</code> The current time.</li>
<li><code>dur</code> An option nanosecond timing to populate.</li>
<li><strong>RETURN</strong> The mask that is desired from the callback.</li>
</ul>
<h4 id="eventerruninthread">eventer_run_in_thread</h4>
<blockquote>
<p>Spawns a thread and runs the event until it returns 0.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_run_in_thread</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>a</code> starting mask for triggering the event.</li>
</ul>
<p>This function will remove the event from the eventer and set the socket into blocking mode.</p>
<h4 id="eventersetcallback">eventer_set_callback</h4>
<blockquote>
<p>Set an event&apos;s callback function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_set_callback</span><span class="hljs-params">(eventer_t e, eventer_func_t func)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
</ul>
<h4 id="eventersetclosure">eventer_set_closure</h4>
<blockquote>
<p>Set an event&apos;s closure.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_set_closure</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>closure</code> a pointer to user-data to be supplied during callback.</li>
</ul>
<h4 id="eventersetcontext">eventer_set_context</h4>
<blockquote>
<p>Set a context for an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">eventer_set_context</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> ctx_idx, <span class="hljs-keyword">void</span> *data)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>ctx_idx</code> is an idx returned from <code>eventer_register_context</code></li>
<li><code>data</code> is new context data.</li>
<li><strong>RETURN</strong> The previously attached context.</li>
</ul>
<h4 id="eventerseteventeraco">eventer_set_eventer_aco</h4>
<blockquote>
<p>Convert an eventer_t into an eventer_aco_t.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_aco_t</span>
eventer_set_eventer_aco(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> The converted event.</li>
</ul>
<p>This calls <code>eventer_set_eventer_aco_co</code> with the current aco
as the <code>co</code> argument.</p>
<h4 id="eventerseteventeracoco">eventer_set_eventer_aco_co</h4>
<blockquote>
<p>Convert an eventer_t into an eventer_aco_t.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_aco_t</span>
eventer_set_eventer_aco_co(<span class="hljs-keyword">eventer_t</span> e, <span class="hljs-keyword">aco_t</span> *co)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>co</code> a coroutine to which the event should bound. NULL to revert.</li>
<li><strong>RETURN</strong> The converted event.</li>
</ul>
<p>The input event is modified in-place.  If the NULL is passed as co,
then the event is reverted and NULL is returned.  You almost always
want to be calling this on a brand-new object or a <code>eventer_alloc_copy</code>
of a pre-existing object.</p>
<h4 id="eventersetfdblocking">eventer_set_fd_blocking</h4>
<blockquote>
<p>Set a file descriptor into blocking mode.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_set_fd_blocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span>
</span></code></pre>
<ul>
<li><code>fd</code> a file descriptor</li>
<li><strong>RETURN</strong> 0 on success, -1 on error (errno set).</li>
</ul>
<h4 id="eventersetfdnonblocking">eventer_set_fd_nonblocking</h4>
<blockquote>
<p>Set a file descriptor into non-blocking mode.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_set_fd_nonblocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span>
</span></code></pre>
<ul>
<li><code>fd</code> a file descriptor</li>
<li><strong>RETURN</strong> 0 on success, -1 on error (errno set).</li>
</ul>
<h4 id="eventersetmask">eventer_set_mask</h4>
<blockquote>
<p>Change an event&apos;s interests or intentions.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_set_mask</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>mask</code> a new mask</li>
</ul>
<p>Do not change change a mask from one event &quot;type&quot; to another. fd events
must remain fd events. Timer must remain timer. Recurrent must remain recurrent.
Do not alter asynch events at all.  This simply changes the mask of the event
without changing any eventer state and should be used with extremem care.
Consider using the callback&apos;s return value or <code>eventer_update</code> to change
the mask of an active event in the system.</p>
<h4 id="eventersetowner">eventer_set_owner</h4>
<blockquote>
<p>Set the thread that owns an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_set_owner</span><span class="hljs-params">(eventer_t e, pthread_t t)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>t</code> a <code>pthread_t</code> thread; must be a valid event-loop.</li>
</ul>
<h4 id="eventerthreadcheck">eventer_thread_check</h4>
<blockquote>
<p>Determine if the calling thread &quot;owns&quot; an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_thread_check</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> 0 if <code>e-&gt;thr_owner</code> is the <code>pthread_self()</code>, non-zero otherwise.</li>
</ul>
<h4 id="eventertrigger">eventer_trigger</h4>
<blockquote>
<p>Trigger an unregistered eventer and incorporate the outcome into the eventer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_trigger</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object that is not registered with the eventer.</li>
<li><code>mask</code> the mask to be used when invoking the event&apos;s callback.</li>
</ul>
<p>This is often used to &quot;start back up&quot; an event that has been removed from the
eventer for any reason.</p>
<h4 id="eventertryaddasynch">eventer_try_add_asynch</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_try_add_asynch</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.</p>
<h4 id="eventertryaddasynchdep">eventer_try_add_asynch_dep</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_try_add_asynch_dep</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventertryaddasynchdepsubqueue">eventer_try_add_asynch_dep_subqueue</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue dependent on the current job.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_try_add_asynch_dep_subqueue</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><code>id</code> is a fairly competing subqueue identifier</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.  This should be called from within a asynch callback
during a mask of <code>EVENTER_ASYNCH_WORK</code> and the new job will be a child
of the currently executing job.</p>
<h4 id="eventertryaddasynchsubqueue">eventer_try_add_asynch_subqueue</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_try_add_asynch_subqueue</span><span class="hljs-params">(eventer_jobq_t *q, eventer_t e, uint64_t id)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
<li><code>id</code> is a fairly competing subqueue identifier</li>
<li><strong>RETURN</strong> <code>mtev_false</code> if over max backlog, caller must clean event.</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENTER_ASYNCH</code>.</p>
<h4 id="eventerupdate">eventer_update</h4>
<blockquote>
<p>Change the activity mask for file descriptor events.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_update</span><span class="hljs-params">(evneter_t e, <span class="hljs-keyword">int</span> mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>mask</code> a new mask that is some bitwise or of <code>EVENTER_READ</code>, <code>EVENTER_WRITE</code>, and <code>EVENTER_EXCEPTION</code></li>
</ul>
<h4 id="eventerupdatewhence">eventer_update_whence</h4>
<blockquote>
<p>Change the time at which a registered timer event should fire.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_update_whence</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">struct</span> timeval whence)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>whence</code> an absolute time.</li>
</ul>
<h4 id="eventerwakeup">eventer_wakeup</h4>
<blockquote>
<p>Signal up an event loop manually.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">eventer_wakeup</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event</li>
</ul>
<p>The event <code>e</code> is used to determine which thread of the eventer loop to wake up.
If <code>e</code> is <code>NULL</code> the first thread in the default eventer loop is signalled. The
eventer loop can wake up on timed events, asynchronous job completions and
file descriptor activity.  If, for an external reason, one needs to wake up
a looping thread, this call is used.</p>
<h4 id="eventerwatchdogtimeout">eventer_watchdog_timeout</h4>
<blockquote>
<p>Return the current watchdog timeout on this thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">double</span>
<span class="hljs-title">eventer_watchdog_timeout</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> A timeout in seconds, 0.0 if none configured.</li>
</ul>
<h4 id="eventerwatchdogtimeouttimeval">eventer_watchdog_timeout_timeval</h4>
<blockquote>
<p>Return the current watchdog timeout on this thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">eventer_watchdog_timeout_timeval</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timeval *dur)</span>
</span></code></pre>
<ul>
<li><code>dur</code> the timeval structure to populate with the timeout.</li>
<li><strong>RETURN</strong> mtev_true if a timeout is set, mtev_false otherwise.</li>
</ul>
<h4 id="eventerwrite">eventer_write</h4>
<blockquote>
<p>Execute an opset-appropriate <code>write</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">eventer_write</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buff, size_t len, <span class="hljs-keyword">int</span> *mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>buff</code> a buffer containing data to write.</li>
<li><code>len</code> the size of <code>buff</code> in bytes.</li>
<li><code>mask</code> a point the a mask. If the call does not complete, <code>*mask</code> it set.</li>
<li><strong>RETURN</strong> the number of bytes written or -1 with errno set.</li>
</ul>
<p>If the function returns -1 and <code>errno</code> is <code>EAGAIN</code>, the <code>*mask</code> reflects the
necessary activity to make progress.</p>
<h4 id="mtevexlog">mtev_ex_log</h4>
<blockquote>
<p>Log to a log stream (metadata, va_list)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_ex_log</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">int</span> line,
            <span class="hljs-keyword">const</span> mtev_log_kv_t *kvpairs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>now</code> the current time</li>
<li><code>file</code> a source file name</li>
<li><code>line</code> a source file line number</li>
<li><code>kvpairs</code> a list of key-value metadata</li>
<li><code>format</code> a <code>printf</code>-style format string</li>
<li><code>arg</code> a <code>varargs</code> list</li>
<li><strong>RETURN</strong> The number of bytes written or an approximation</li>
</ul>
<p>This function (used by the <code>mtevL</code>, <code>mtevLT</code>, <code>mtevEL</code>, <code>mtevELT</code> macros) is responsible for logging.
A variery of metadata fields are created internally including timestamp, <code>threadname</code>, <code>threadid</code>,
facility (log name), file, and line.  These metadata fields are extended with those passed in
as <code>kvpairs</code>.  These KV pairs should be created with the <code>MLKV, MLKV_NUM, MLKV_STR, MLKV_END</code>
macros.  The message is formatted, filtering is applied and then the resulting payload is
pushed through the directed acyclic graph of log streams.  See <code>mtevEL</code> for examples.</p>
<h4 id="mtevexvlog">mtev_ex_vlog</h4>
<blockquote>
<p>Log to a log stream (metadata, <code>va_list</code>)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_ex_vlog</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">int</span> line,
             <span class="hljs-keyword">const</span> mtev_log_kv_t *kvpairs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list arg)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>now</code> the current time</li>
<li><code>file</code> a source file name</li>
<li><code>line</code> a source file line number</li>
<li><code>kvpairs</code> a list of key-value metadata</li>
<li><code>format</code> a <code>printf</code>-style format string</li>
<li><code>arg</code> a <code>varargs</code> list</li>
<li><strong>RETURN</strong> The number of bytes written or an approximation</li>
</ul>
<p>See mtev_ex_log.</p>
<h3 id="f">F</h3>
<h4 id="mtevflowregulatorack">mtev_flow_regulator_ack</h4>
<blockquote>
<p>Acknowledge processing mtev_flow_regulator_toggle_t instruction.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_flow_regulator_toggle_t</span>
mtev_flow_regulator_ack(<span class="hljs-keyword">mtev_flow_regulator_t</span> *fr, <span class="hljs-keyword">mtev_flow_regulator_toggle_t</span> t)
</code></pre>
<ul>
<li><code>t</code> Instruction returned from previous call to <code>mtev_flow_regulator_raise_one</code>, <code>mtev_flow_regulator_lower</code>, or <code>mtev_flow_regulator_ack</code>.</li>
<li><strong>RETURN</strong> New flow-toggle instruction.</li>
</ul>
<p>The flow-regulator is designed to be usable in multi-producer
(where multiple concurrent entities may produce work) /
multi-consumer (where multiple concurrent entities may mark work
completed) scenarios, which means that many entities may be adding
and removing work from the flow-regulator at the same time. As
such, when one entity observes that the flow-regulator has become
disabled and takes some action to pause further work generation,
it&apos;s possible that enough work will have drained from the
flow-regulator that it needs to be re-enabled... Or, that after
re-enabling the flow-regulator, enough work was already being
scheduled that it needs to be disabled again. So
<code>mtev_flow_regulator_ack</code> returns a <em>new</em> instruction, in case the
flow-regulator needs further adjustment. Clients are expected to
call this function in a loop, with the function&apos;s previous return
value, until the flow-regulator settles on
<code>MTEV_FLOW_REGULATOR_TOGGLE_KEEP</code> or
<code>MTEV_FLOW_REGULATOR_TOGGLE_DISABLED</code>. (There is no harm in
continuing to call <code>mtev_flow_regulator_ack</code> after it reaches one
of these values: it will eventually settle on
<code>MTEV_FLOW_REGULATOR_TOGGLE_KEEP</code>.)</p>
<p>The toggle-instruction should be interpreted as follows:</p>
<ul>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_DISABLED</code>: Flow control is currently
disabled. No client action necessary.</li>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_DISABLE</code>: Flow control <em>was</em> enabled,
and we&apos;ve started transitioning to DISABLED. (The transition to
DISABLED is not complete until the client calls
<code>mtev_flow_regulator_ack</code>, again.) Client MAY try to prevent
generating new work before calling <code>mtev_flow_regulator_ack</code>, again.</li>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_KEEP</code>: No client action required.</li>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_ENABLE</code>: Flow control <em>was</em> disabled,
and has just started transitioning to ENABLED. (The transition to
ENABLED is not complete until the client calls
<code>mtev_flow_regulator_ack</code>, again.) Client MAY re-enable
work-generation before calling <code>mtev_flow_regulator_ack</code>, again.</li>
</ul>
<p>To facilitate multi-producer / multi-consumer use, the
flow-regulator enforces that only <em>one</em> client will see a
flow-toggling result (<em>i.e.</em> <code>MTEV_FLOW_REGULATOR_TOGGLE_ENABLE</code>
or <code>MTEV_FLOW_REGULATOR_TOGGLE_DISABLE</code>) until that client calls
<code>mtev_flow_regulator_ack</code>, and that the same toggling result will
not occur twice in a row across all concurrent clients.</p>
<h4 id="mtevflowregulatorcreate">mtev_flow_regulator_create</h4>
<blockquote>
<p>Create a flow-regulator object.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_flow_regulator_t</span> *
mtev_flow_regulator_create(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> high)
</code></pre>
<ul>
<li><code>low</code> Threshold that indicates when work flow should be re-enabled.</li>
<li><code>high</code> Threshold at which to stop work flow. Must be strictly greater than <code>low</code>.</li>
<li><strong>RETURN</strong> Flow-regulator object.</li>
</ul>
<p>The returned flow-regulator object is &quot;enabled&quot; on creation. When
<code>high</code> work items are added (by <code>mtev_flow_regulator_raise_one</code>)
without being removed (by <code>mtev_flow_regulator_lower</code>), the
flow-regulator will become disabled. When <code>high - low</code> work-items
are subsequently marked done (by <code>mtev_flow_regulator_lower</code>),
without new work being added (by <code>mtev_flow_regulator_raise_one</code>),
the flow-regulator will transition back to &quot;enabled&quot;.</p>
<h4 id="mtevflowregulatordestroy">mtev_flow_regulator_destroy</h4>
<blockquote>
<p>Destroy a flow-regulator object.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_flow_regulator_destroy</span><span class="hljs-params">(mtev_flow_regulator_t *fr)</span>
</span></code></pre>
<h4 id="mtevflowregulatorlower">mtev_flow_regulator_lower</h4>
<blockquote>
<p>Release space for work-items in a flow-regulator.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_flow_regulator_toggle_t</span>
mtev_flow_regulator_lower(<span class="hljs-keyword">mtev_flow_regulator_t</span> *fr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> by)
</code></pre>
<ul>
<li><code>by</code> Number of work-items to mark completed.</li>
<li><strong>RETURN</strong> Action to take on releasing work.</li>
</ul>
<p>See <code>mtev_flow_regulator_ack</code> for description of how to handle the
return value. This function will return one of:</p>
<ul>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_KEEP</code></li>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_ENABLE</code></li>
</ul>
<h4 id="mtevflowregulatorraiseone">mtev_flow_regulator_raise_one</h4>
<blockquote>
<p>Reserve space for a work-item in a flow-regulator.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_flow_regulator_toggle_t</span>
mtev_flow_regulator_raise_one(<span class="hljs-keyword">mtev_flow_regulator_t</span> *fr)
</code></pre>
<ul>
<li><strong>RETURN</strong> Success / fail status on inserting work.</li>
</ul>
<p>See <code>mtev_flow_regulator_ack</code> for description of how to handle the
return value. This function will return one of:</p>
<ul>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_DISABLED</code></li>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_DISABLE</code></li>
<li><code>MTEV_FLOW_REGULATOR_TOGGLE_KEEP</code></li>
</ul>
<p>Note that, unless the return value was
<code>MTEV_FLOW_REGULATOR_TOGGLE_KEEP</code>, space was <em>not</em> reserved in the
flow-regulator for the work-item.</p>
<h4 id="mtevflowregulatorstablelower">mtev_flow_regulator_stable_lower</h4>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_flow_regulator_toggle_t</span>
mtev_flow_regulator_stable_lower(<span class="hljs-keyword">mtev_flow_regulator_t</span> *fr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> by)
</code></pre>
<ul>
<li><strong>RETURN</strong> <code>mtev_true</code> if the caller is responsible for re-scheduling work-creation for the flow-regulator, <code>mtev_false</code> otherwise.</li>
</ul>
<p>This function is a simple wrapper around
<code>mtev_flow_regulator_lower</code> and <code>mtev_flow_regulator_ack</code>, to
simplify handling in cases where the client needs take no explicit
action to enable or disable work-production before calling
<code>mtev_flow_regulator_ack</code>.</p>
<h4 id="mtevflowregulatorstabletryraiseone">mtev_flow_regulator_stable_try_raise_one</h4>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_flow_regulator_toggle_t</span>
mtev_flow_regulator_stable_try_raise_one(<span class="hljs-keyword">mtev_flow_regulator_t</span> *fr)
</code></pre>
<ul>
<li><strong>RETURN</strong> mtev_true if work-item was successfully added to the flow regulator, mtev_false otherwise.</li>
</ul>
<p>This function is a simple wrapper around
<code>mtev_flow_regulator_raise_one</code> and <code>mtev_flow_regulator_ack</code>, to
simplify handling in cases where the client needs take no explicit
action to enable or disable work-production before calling
<code>mtev_flow_regulator_ack</code>.</p>
<h4 id="mtevfrrhadjustprob">mtev_frrh_adjust_prob</h4>
<blockquote>
<p>Change the replacement probability on a <code>mtev_frrh_t</code>.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_frrh_adjust_prob</span><span class="hljs-params">(mtev_frrh_t *cache, uint32_t prob)</span>
</span></code></pre>
<ul>
<li><code>cache</code> the <code>mtev_frrh_t</code> on which to change the probability.</li>
<li><code>prob</code> is the probability of replaement on collision (0 to UINT_MAX).</li>
</ul>
<h4 id="mtevfrrhalloc">mtev_frrh_alloc</h4>
<blockquote>
<p>Allocate a fast random replacement hash.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_frrh_t</span> *
mtev_frrh_alloc(<span class="hljs-keyword">uint64_t</span> size, <span class="hljs-keyword">size_t</span> datasize, <span class="hljs-keyword">uint32_t</span> prob, mtev_frrh_hash hashf,
                mtev_frrh_alloc_entry allocf, mtev_frrh_free_entry freef)
</code></pre>
<ul>
<li><code>size</code> is the total capacity of the hash.</li>
<li><code>datasize</code> is the fixed-size of the data which will be stored.</li>
<li><code>prob</code> is the probability of replaement on collision (0 to UINT_MAX).</li>
<li><code>hashf</code> is the hashing function, NULL uses XXH64.</li>
<li><code>allocf</code> is the allocation function to use, NULL uses malloc.</li>
<li><code>freef</code> is the free function to use, NULL uses free.</li>
<li><strong>RETURN</strong> a pointer to a <code>mtev_frrh_t</code> on success, NULL otherwise.</li>
</ul>
<h4 id="mtevfrrhget">mtev_frrh_get</h4>
<blockquote>
<p>Retrieves the data associated with the provided key from the cache.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *
<span class="hljs-title">mtev_frrh_get</span><span class="hljs-params">(mtev_frrh_t *cache, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key, uint32_t keylen)</span>
</span></code></pre>
<ul>
<li><code>cache</code> a <code>mtev_frrh_t</code>.</li>
<li><code>key</code> a pointer to the key.</li>
<li><code>keylen</code> the length of the key in bytes.</li>
<li><strong>RETURN</strong> a pointer to a copy of the data store with the key.</li>
</ul>
<h4 id="mtevfrrhset">mtev_frrh_set</h4>
<blockquote>
<p>Possibly set a key-value pair in a <code>mtev_frrh_t</code></p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_frrh_set</span><span class="hljs-params">(mtev_frrh_t *cache, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key, uint32_t keylen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data)</span>
</span></code></pre>
<ul>
<li><code>cache</code> a <code>mtev_frrh_t</code>.</li>
<li><code>key</code> a pointer to the key.</li>
<li><code>keylen</code> the length of the key in bytes.</li>
<li><code>data</code> a pointer to the data (must be of the specified datasize for the <code>mtev_frrh_t</code>.</li>
<li><strong>RETURN</strong> <code>mtev_true</code> if added, <code>mtev_false</code> if not.</li>
</ul>
<h4 id="mtevfrrhsetprobfunction">mtev_frrh_set_prob_function</h4>
<pre><code class="lang-c">void
mtev_frrh_set_prob_function(mtev_frrh_t *cache, mtev_boolean (*func)(uint32_t prob, const char *key,
                            uint32_t keylen, const void *data))
</code></pre>
<p> *</p>
<blockquote>
<p>Set a probability tester.</p>
</blockquote>
<ul>
<li><ul>
<li><code>cache</code> the <code>mtev_frrh_t</code> on which to change the probability tester.</li>
</ul>
</li>
<li><ul>
<li><code>func</code> a function taking the configured probability and existing key/data return true if it should be replaced.</li>
</ul>
</li>
</ul>
<h4 id="mtevfrrhstats">mtev_frrh_stats</h4>
<blockquote>
<p>Retrieve access and hit statatistics.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_frrh_stats</span><span class="hljs-params">(mtev_frrh_t *cache, uint64_t *accesses, uint64_t *hits)</span>
</span></code></pre>
<ul>
<li><code>cache</code> the <code>mtev_frrh_t</code> in question.</li>
<li><code>accesses</code> is an optional out pointer to store the number of accesses.</li>
<li><code>hits</code> is an optional out pointer to store the number of hits.</li>
</ul>
<h3 id="g">G</h3>
<h4 id="mtevgetdurationsms">mtev_get_durations_ms</h4>
<blockquote>
<p>Return suffixes for millisecond-resolution durations.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> mtev_duration_definition_t *
<span class="hljs-title">mtev_get_durations_ms</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<p>Return value is suitable to pass as the second argument to
mtev_confstr_parse_duration. Millisecond-scale duration suffixes are:</p>
<ul>
<li><code>ms</code> (for milliseconds);</li>
<li><code>s</code> and <code>sec</code> (for seconds);</li>
<li><code>min</code> (for minutes);</li>
<li><code>hr</code> (for hours).</li>
<li><code>d</code> (for days).</li>
<li><code>w</code> (for weeks).</li>
</ul>
<h4 id="mtevgetdurationsns">mtev_get_durations_ns</h4>
<blockquote>
<p>Return suffixes for nanosecond-resolution durations.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> mtev_duration_definition_t *
<span class="hljs-title">mtev_get_durations_ns</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<p>Return value is suitable to pass as the second argument to
mtev_confstr_parse_duration. Nanosecond-scale duration suffixes are:</p>
<ul>
<li><code>ns</code> (for nanoseconds);</li>
<li><code>us</code> (for microseconds);</li>
<li><code>ms</code> (for milliseconds);</li>
<li><code>s</code> and <code>sec</code> (for seconds);</li>
<li><code>min</code> (for minutes);</li>
<li><code>hr</code> (for hours).</li>
</ul>
<h4 id="mtevgetdurationss">mtev_get_durations_s</h4>
<blockquote>
<p>Return suffixes for second-resolution durations.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> mtev_duration_definition_t *
<span class="hljs-title">mtev_get_durations_s</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<p>Return value is suitable to pass as the second argument to
mtev_confstr_parse_duration. Second-scale duration suffixes are:</p>
<ul>
<li><code>s</code> and <code>sec</code> (for seconds);</li>
<li><code>min</code> (for minutes);</li>
<li><code>hr</code> (for hours).</li>
<li><code>d</code> (for days).</li>
<li><code>w</code> (for weeks).</li>
</ul>
<h4 id="mtevgetdurationsus">mtev_get_durations_us</h4>
<blockquote>
<p>Return suffixes for microsecond-resolution durations.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> mtev_duration_definition_t *
<span class="hljs-title">mtev_get_durations_us</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<p>Return value is suitable to pass as the second argument to
mtev_confstr_parse_duration. Microsecond-scale duration suffixes are:</p>
<ul>
<li><code>us</code> (for microseconds);</li>
<li><code>ms</code> (for milliseconds);</li>
<li><code>s</code> and <code>sec</code> (for seconds);</li>
<li><code>min</code> (for minutes);</li>
<li><code>hr</code> (for hours).</li>
<li><code>d</code> (for days).</li>
</ul>
<h4 id="mtevgetnanos">mtev_get_nanos</h4>
<blockquote>
<p>Like mtev_gethrtime. It actually is the implementation of mtev_gethrtime()</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span>
mtev_get_nanos(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><strong>RETURN</strong> number of nanos seconds from an arbitrary time in the past.</li>
</ul>
<h4 id="mtevgetipipv4">mtev_getip_ipv4</h4>
<blockquote>
<p>find the local IPv4 address that would be used to talk to remote</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_getip_ipv4</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr remote, <span class="hljs-keyword">struct</span> in_addr *local)</span>
</span></code></pre>
<ul>
<li><code>remote</code> the destination (no packets are sent)</li>
<li><code>local</code> the pointer to the local address to be set</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure</li>
</ul>
<h4 id="mtevgettimeofday">mtev_gettimeofday</h4>
<blockquote>
<p>Maybe fast-pathed version of gettimeofday</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_gettimeofday</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timeval *t, <span class="hljs-keyword">void</span> **ttp)</span>
</span></code></pre>
<ul>
<li><p><strong>RETURN</strong> same as system gettimeofday();</p>
<p>If the fast path is taken, ttp is ignored.</p>
</li>
</ul>
<h3 id="h">H</h3>
<h4 id="mtevhashhash">mtev_hash__hash</h4>
<pre><code class="lang-c"><span class="hljs-keyword">uint32_t</span>
mtev_hash__hash(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, <span class="hljs-keyword">uint32_t</span> length, <span class="hljs-keyword">uint32_t</span> initval)
</code></pre>
<blockquote>
<p>the internal hash function that mtev_hash_table uses exposed for external usage</p>
</blockquote>
<h4 id="mtevhashadv">mtev_hash_adv</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_adv</span><span class="hljs-params">(mtev_hash_table *h, mtev_hash_iter *iter)</span>
</span></code></pre>
<blockquote>
<p>iterate through key/values in the hash_table</p>
</blockquote>
<p>  This is an iterator and requires the hash to not be written to during the
   iteration process.
   To use:
 mtev_hash_iter iter = MTEV_HASH_ITER_ZERO;</p>
<p> while(mtev_hash_adv(h, &amp;iter)) {
   .... use iter.key.{str,ptr}, iter.klen and iter.value.{str,ptr} ....
 }</p>
<h4 id="mtevhashadvspmc">mtev_hash_adv_spmc</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_adv_spmc</span><span class="hljs-params">(mtev_hash_table *h, mtev_hash_iter *iter)</span>
</span></code></pre>
<blockquote>
<p>iterate through the key/values in the hash_table</p>
</blockquote>
<p>   This is an iterator and requires that if the hash it written to
   during the iteration process, you must employ SMR on the hash itself
   to prevent destruction of memory for hash resizes by using the
   special init function mtev_hash_init_mtev_memory.</p>
<p>   To use:
   mtev_hash_iter iter = MTEV_HASH_ITER_ZERO;</p>
<p>   while(mtev_hash_adv_spmc(h, &amp;iter)) {
   .... use iter.key.{str,ptr}, iter.klen and iter.value.{str,ptr} ....
   }</p>
<h4 id="mtevhashdelete">mtev_hash_delete</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_delete</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, <span class="hljs-keyword">int</span> klen, NoitHashFreeFunc keyfree
                 NoitHashFreeFunc datafree)</span>
</span></code></pre>
<blockquote>
<p>remove the key/value stored at &quot;k&quot; and call keyfree and datafree if they are provided</p>
</blockquote>
<h4 id="mtevhashdeleteall">mtev_hash_delete_all</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_hash_delete_all</span><span class="hljs-params">(mtev_hash_table *h, NoitHashFreeFunc keyfree, NoitHashFreeFunc datafree)</span>
</span></code></pre>
<blockquote>
<p>remove all keys and values and call keyfree and datafree if they are provided</p>
</blockquote>
<h4 id="mtevhashdestroy">mtev_hash_destroy</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_hash_destroy</span><span class="hljs-params">(mtev_hash_table *h, NoitHashFreeFunc keyfree, NoitHashFreeFunc datafree)</span>
</span></code></pre>
<blockquote>
<p>remove all keys and values and call keyfree and datafree if they are provided but also wipe out the underlying map</p>
</blockquote>
<p>  This must be called on any hash_table that has been mtev_hash_inited or it will leak memory</p>
<h4 id="mtevhashget">mtev_hash_get</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">mtev_hash_get</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, <span class="hljs-keyword">int</span> klen)</span>
</span></code></pre>
<blockquote>
<p>return the value at &quot;k</p>
</blockquote>
<h4 id="mtevhashinit">mtev_hash_init</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_hash_init</span><span class="hljs-params">(mtev_hash_table *h)</span>
</span></code></pre>
<blockquote>
<p>initialize a hash_table</p>
</blockquote>
<p>  will default to LOCK_MODE_NONE and MTEV_HASH_DEFAULT_SIZE (1&lt;&lt;7)</p>
<h4 id="mtevhashinitlocks">mtev_hash_init_locks</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_hash_init_locks</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">int</span> size, mtev_hash_lock_mode_t lock_mode)</span>
</span></code></pre>
<blockquote>
<p>choose the lock mode when initing the hash.</p>
</blockquote>
<p>  It&apos;s worth noting that the lock only affects the write side of the hash,
  the read side remains completely lock free.</p>
<h4 id="mtevhashinitmtevmemory">mtev_hash_init_mtev_memory</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_hash_init_mtev_memory</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">int</span> size, mtev_hash_lock_mode_t lock_mode)</span>
</span></code></pre>
<blockquote>
<p>choose the lock mode when initing the hash.</p>
</blockquote>
<p>  It&apos;s worth noting that the lock only affects the write side of the hash,
  the read side remains completely lock free.</p>
<p>  This variant will use mtev_memory ck allocator functions to allow this
  hash to participate in SMR via mtev_memory transactions.  You need to wrap
  memory transactions in mtev_memory_begin()/mtev_memory_end()</p>
<h4 id="mtevhashinitsize">mtev_hash_init_size</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_hash_init_size</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">int</span> size)</span>
</span></code></pre>
<blockquote>
<p>initialize a hash_table with an initial size</p>
</blockquote>
<p>  will default to LOCK_MODE_NONE</p>
<h4 id="mtevhashmergeasdict">mtev_hash_merge_as_dict</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_hash_merge_as_dict</span><span class="hljs-params">(mtev_hash_table *dst, mtev_hash_table *src)</span>
</span></code></pre>
<blockquote>
<p>merge string values in &quot;src&quot; into &quot;dst&quot;</p>
</blockquote>
<p>  This is a convenience function only.  It assumes that all keys and values
  in the destination hash are strings and allocated with malloc() and
  assumes that the source contains only keys and values that can be
  suitably duplicated by strdup().</p>
<h4 id="mtevhashnext">mtev_hash_next</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_next</span><span class="hljs-params">(mtev_hash_table *h, mtev_hash_iter *iter, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **k, <span class="hljs-keyword">int</span> *klen
               <span class="hljs-keyword">void</span> **data)</span>
</span></code></pre>
<blockquote>
<p>iterate through the key/values in the hash_table</p>
</blockquote>
<p>  These are older, more painful APIs... use mtev_hash_adv
   Note that neither of these sets the key, value, or klen in iter</p>
<h4 id="mtevhashnextstr">mtev_hash_next_str</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_next_str</span><span class="hljs-params">(mtev_hash_table *h, mtev_hash_iter *iter, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **k, <span class="hljs-keyword">int</span> *klen
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **dstr)</span>
</span></code></pre>
<blockquote>
<p>iterate through the key/values in the hash_table as strings</p>
</blockquote>
<p>  These are older, more painful APIs... use mtev_hash_adv </p>
<h4 id="mtevhashreplace">mtev_hash_replace</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_replace</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, <span class="hljs-keyword">int</span> klen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data,
                  NoitHashFreeFunc keyfree, NoitHashFreeFunc datafree)</span>
</span></code></pre>
<blockquote>
<p>replace and delete (call keyfree and datafree functions) anything that was already in this hash location</p>
</blockquote>
<h4 id="mtevhashretrstr">mtev_hash_retr_str</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_retr_str</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, <span class="hljs-keyword">int</span> klen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **dstr)</span>
</span></code></pre>
<blockquote>
<p>fetch the value at &quot;k&quot; into &quot;data&quot; as a string</p>
</blockquote>
<h4 id="mtevhashretrieve">mtev_hash_retrieve</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_retrieve</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, <span class="hljs-keyword">int</span> klen, <span class="hljs-keyword">void</span> **data)</span>
</span></code></pre>
<blockquote>
<p>fetch the value at &quot;k&quot; into &quot;data&quot;</p>
</blockquote>
<h4 id="mtevhashset">mtev_hash_set</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_set</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, <span class="hljs-keyword">int</span> klen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">char</span> **oldkey
              <span class="hljs-keyword">void</span> **olddata)</span>
</span></code></pre>
<blockquote>
<p>replace and return the old value and old key that was in this hash location</p>
</blockquote>
<p>  will return MTEV_HASH_SUCCESS on successful set with no replacement
  will return MTEV_HASH_FAILURE on failure to set
  will return MTEV_HASH_SUCCESS_REPLACEMENT on successful set with replacement</p>
<h4 id="mtevhashsize">mtev_hash_size</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_size</span><span class="hljs-params">(mtev_hash_table *h)</span>
</span></code></pre>
<blockquote>
<p>return the number of entries in the hash_table</p>
</blockquote>
<h4 id="mtevhashstore">mtev_hash_store</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_hash_store</span><span class="hljs-params">(mtev_hash_table *h, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, <span class="hljs-keyword">int</span> klen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data)</span>
</span></code></pre>
<blockquote>
<p>put something in the hash_table</p>
</blockquote>
<p>  This will fail if the key already exists in the hash_table</p>
<p>  NOTE! &quot;k&quot; and &quot;data&quot; MUST NOT be transient buffers, as the hash table
  implementation does not duplicate them.  You provide a pair of
  NoitHashFreeFunc functions to free up their storage when you call
  mtev_hash_delete(), mtev_hash_delete_all() or mtev_hash_destroy().</p>
<h4 id="mtevhtmlencode">mtev_html_encode</h4>
<blockquote>
<p>Encode raw data as html encoded output into the provided buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_html_encode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the raw data.</li>
<li><code>src_len</code> The size (in bytes) of the raw data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the encoded output.  Returns zero is out_sz is too small.</li>
</ul>
<h4 id="mtevhtmlencodelen">mtev_html_encode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain the url encoding for a given number of bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_html_encode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the raw data buffer that might be encoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to store an encoded version of an input string.</li>
</ul>
<h4 id="mtevhugehashadv">mtev_huge_hash_adv</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_huge_hash_adv</span><span class="hljs-params">(mtev_huge_hash_iter_t *iter)</span>
</span></code></pre>
<blockquote>
<p>iterate through key/values in the hash_table</p>
</blockquote>
<p>   To use:
 mtev_huge_hash_iter_t *iter = mtev_huge_hash_create_iter(hh);</p>
<p> while(mtev_huge_hash_adv(iter)) {
   size_t key_len, data_len;
   void <em>k = mtev_huge_hash_iter_key(iter, &amp;key_len);
   void </em>d = mtev_huge_hash_iter_value(iter, &amp;data_len);
 }</p>
<h4 id="mtevhugehashcreate">mtev_huge_hash_create</h4>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_huge_hash_t</span> *
mtev_huge_hash_create(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)
</code></pre>
<blockquote>
<p>create or open a huge_hash</p>
</blockquote>
<p>  Failure to open or create will return NULL and errno will be set appropriately.
  See: mtev_huge_hash_strerror()</p>
<p>\fn mtev_huge_hash_iter_t <em>mtev_huge_hash_create_iter(mtev_huge_hash_t </em>hh);</p>
<blockquote>
<p>create an iterator for walking the huge_hash</p>
</blockquote>
<p>  Note that the existence of an interator can prevent calls to mtev_huge_hash_store
  from completing if the underlying data has to resize.  Iterate with caution.</p>
<h4 id="mtevhugehashdelete">mtev_huge_hash_delete</h4>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_huge_hash_delete</span><span class="hljs-params">(mtev_huge_hash_t *hh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, size_t klen)</span>
</span></code></pre>
<blockquote>
<p>remove the key/value stored at &quot;k&quot;</p>
</blockquote>
<h4 id="mtevhugehashreplace">mtev_huge_hash_replace</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_huge_hash_replace</span><span class="hljs-params">(mtev_huge_hash_t *hh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, size_t klen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data
                       size_t dlen)</span>
</span></code></pre>
<blockquote>
<p>replace anything that was already in this hash location</p>
</blockquote>
<h4 id="mtevhugehashretrieve">mtev_huge_hash_retrieve</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *
<span class="hljs-title">mtev_huge_hash_retrieve</span><span class="hljs-params">(mtev_huge_hash_t *hh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, size_t klen, size_t *data_len)</span>
</span></code></pre>
<blockquote>
<p>return the value at &quot;k&quot; and fill data_len with sizeof the data</p>
</blockquote>
<p>  The memory returned here is owned by the huge_hash.  Do not modify</p>
<h4 id="mtevhugehashsize">mtev_huge_hash_size</h4>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_huge_hash_size(<span class="hljs-keyword">mtev_huge_hash_t</span> *hh)
</code></pre>
<blockquote>
<p>return the number of entries in the huge_hash</p>
</blockquote>
<h4 id="mtevhugehashstore">mtev_huge_hash_store</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_huge_hash_store</span><span class="hljs-params">(mtev_huge_hash_t *hh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *k, size_t klen, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data
                     size_t dlen)</span>
</span></code></pre>
<blockquote>
<p>put something in the huge_hash</p>
</blockquote>
<p>  This will fail if the key already exists in the hash_table
  Copies are made of <code>k</code> and <code>data</code></p>
<p>  Returns mtev_true on success</p>
<h3 id="i">I</h3>
<h4 id="mtevintern">mtev_intern</h4>
<blockquote>
<p>Like <code>mtev_intern_pool</code> invoked with <code>MTEV_INTERN_DEFAULT_POOL</code>.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_intern_t</span>
mtev_intern(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> len)
</code></pre>
<ul>
<li><code>buff</code> The data to be interned.</li>
<li><code>len</code> The length of data to be considered (0, 2^23)</li>
<li><strong>RETURN</strong> A new, or pre-existing intern from the default pool.</li>
</ul>
<h4 id="mtevinterncopy">mtev_intern_copy</h4>
<blockquote>
<p>Return a reference to an existing <code>mtev_intern_t</code>.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_intern_t</span>
mtev_intern_copy(<span class="hljs-keyword">const</span> <span class="hljs-keyword">mtev_intern_t</span> iv)
</code></pre>
<ul>
<li><code>iv</code> An existing, valid <code>mtev_intern_t</code></li>
<li><strong>RETURN</strong> A reference to the interned data.</li>
</ul>
<p>The copy must be released just as if you created it via <code>mtev_intern_pool</code>.</p>
<h4 id="mtevinterngetcstr">mtev_intern_get_cstr</h4>
<blockquote>
<p>Retrieve the string from an <code>mtev_intern_t</code> type.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">mtev_intern_get_cstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> mtev_intern_t iv, size_t *len)</span>
</span></code></pre>
<ul>
<li><code>iv</code> The interned data.</li>
<li><code>len</code> An out value for the length of the string. Unused if NULL.</li>
<li><strong>RETURN</strong> The string contained in the interned value.</li>
</ul>
<p>The return value is only valid until <code>mtev_intern_release*</code> is called.</p>
<h4 id="mtevinterngetptr">mtev_intern_get_ptr</h4>
<blockquote>
<p>Retrieve the data from an <code>mtev_intern_t</code> type.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *
<span class="hljs-title">mtev_intern_get_ptr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> mtev_intern_t iv, size_t *len)</span>
</span></code></pre>
<ul>
<li><code>iv</code> The interned data.</li>
<li><code>len</code> An out value for the length of the string. Unused if NULL.</li>
<li><strong>RETURN</strong> The memory contained in the interned value.</li>
</ul>
<p>The return value is only valid until <code>mtev_intern_release*</code> is called.</p>
<h4 id="mtevinterngetrefcnt">mtev_intern_get_refcnt</h4>
<blockquote>
<p>Retrieve the current refcnt for an intern item.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint32_t</span>
mtev_intern_get_refcnt(<span class="hljs-keyword">mtev_intern_t</span> iv)
</code></pre>
<ul>
<li><code>iv</code> The interned value.</li>
<li><strong>RETURN</strong> The number of references currently outstanding.</li>
</ul>
<h4 id="mtevinternpool">mtev_intern_pool</h4>
<blockquote>
<p>Request an interned data item with specific contents.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_intern_t</span>
mtev_intern_pool(<span class="hljs-keyword">mtev_intern_pool_t</span> *pool, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> len)
</code></pre>
<ul>
<li><code>pool</code> The pool in which to intern the data.</li>
<li><code>buff</code> The data to be interned.</li>
<li><code>len</code> The length of data to be considered (0, 2^23)</li>
<li><strong>RETURN</strong> A new, or pre-existing intern from the pool.</li>
</ul>
<p>This function will attempt to find the specified data in the pool, but create it on absence.
The reference count of the interned object returned will be increased and it must be released
using <code>mtev_intern_release_pool</code>.</p>
<h4 id="mtevinternpoolbyid">mtev_intern_pool_by_id</h4>
<blockquote>
<p>Return an existing pool by id.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_intern_pool_t</span> *
mtev_intern_pool_by_id(<span class="hljs-keyword">uint8_t</span> id)
</code></pre>
<ul>
<li><code>id</code> the pool id.</li>
<li><strong>RETURN</strong> A new intern pool.</li>
</ul>
<h4 id="mtevinternpoolcompact">mtev_intern_pool_compact</h4>
<blockquote>
<p>Attempt a compaction of an intern pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_intern_pool_compact</span><span class="hljs-params">(mtev_intern_pool_t *pool, mtev_boolean force)</span>
</span></code></pre>
<ul>
<li><code>pool</code> The pool to compact.</li>
<li><code>force</code> A boolean dictating if compaction should be forced.</li>
<li><strong>RETURN</strong> The number of free fragment merges that occurred, -1 if it will be performed asynch.</li>
</ul>
<p>This function will walk all the free fragment lists within the
pool joining adjacent ones and promoting them into the the right
slabs.  If force is false, compaction will be avoided if there are less
than approximately 1.5x fragments as there were after the previous successful
compaction.  If this is called from an eventer thread (not a jobq), it will be
scheduled to be done in the default jobq (work deferred) and will return -1
instead of a measurement of compaction.  If force is specified, it will be done
synchronously regardless of callsite location.</p>
<h4 id="mtevinternpoolitemcount">mtev_intern_pool_item_count</h4>
<blockquote>
<p>Return the number of unique interned items in a pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint32_t</span>
mtev_intern_pool_item_count(<span class="hljs-keyword">mtev_intern_pool_t</span> *pool)
</code></pre>
<ul>
<li><code>pool</code> The pool to analyze.</li>
<li><strong>RETURN</strong> The number of unique interned items.</li>
</ul>
<h4 id="mtevinternpoolnew">mtev_intern_pool_new</h4>
<blockquote>
<p>Create a new intern pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_intern_pool_t</span> *
mtev_intern_pool_new(<span class="hljs-keyword">mtev_intern_pool_attr_t</span> *attr)
</code></pre>
<ul>
<li><code>attr</code> the attributes describing the pool.</li>
<li><strong>RETURN</strong> A new intern pool.</li>
</ul>
<h4 id="mtevinternpoolstats">mtev_intern_pool_stats</h4>
<blockquote>
<p>Return statistics for an intern pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_intern_pool_stats</span><span class="hljs-params">(mtev_intern_pool_t *pool, mtev_intern_pool_stats_t *stats)</span>
</span></code></pre>
<ul>
<li><code>pool</code> The pool to inspect.</li>
<li><code>stats</code> The statistics structure to fill out.</li>
</ul>
<h4 id="mtevinternpoolstr">mtev_intern_pool_str</h4>
<blockquote>
<p>Request an interned string item with specific contents.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_intern_t</span>
mtev_intern_pool_str(<span class="hljs-keyword">mtev_intern_pool_t</span> *pool, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *buff, <span class="hljs-keyword">size_t</span> len)
</code></pre>
<ul>
<li><code>pool</code> The pool in which to intern the string.</li>
<li><code>buff</code> The string to be interned.</li>
<li><code>len</code> The length of <code>buff</code>. <code>len</code> must be less than 2^23-1. If 0, strlen will be invoked.</li>
<li><strong>RETURN</strong> A new, or pre-existing intern from the pool.</li>
</ul>
<p>This function will attempt to find the specified string in the pool, but create it on absence.
The reference count of the interned string returned will be increased and it must be released
using <code>mtev_intern_release_pool</code>.</p>
<h4 id="mtevinternrelease">mtev_intern_release</h4>
<blockquote>
<p>Release interned data back to the pool from which it was allocated.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_intern_release</span><span class="hljs-params">(mtev_intern_t iv)</span>
</span></code></pre>
<ul>
<li><code>iv</code> The interned value to release.</li>
</ul>
<h4 id="mtevinternreleasepool">mtev_intern_release_pool</h4>
<blockquote>
<p>Release interned data back to a pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_intern_release_pool</span><span class="hljs-params">(mtev_intern_pool_t *pool, mtev_intern_t iv)</span>
</span></code></pre>
<ul>
<li><code>pool</code> The pool to release <code>iv</code> to.</li>
<li><code>iv</code> The interned value to release.</li>
</ul>
<p>Interned values must be released to the pool they were retrieved from.  Attempting
to release to a different pool will cause a crash.</p>
<h4 id="mtevinternstr">mtev_intern_str</h4>
<blockquote>
<p>Like <code>mtev_intern_pool</code> invoked with <code>MTEV_INTERN_DEFAULT_POOL</code>.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_intern_t</span>
mtev_intern_str(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *buff, <span class="hljs-keyword">size_t</span> len)
</code></pre>
<ul>
<li><code>buff</code> The string to be interned.</li>
<li><code>len</code> The length of string. <code>len</code> must be less than 2^23-1. If 0, strlen will be invoked.</li>
<li><strong>RETURN</strong> A new, or pre-existing intern from the default pool.</li>
</ul>
<h3 id="l">L</h3>
<h4 id="mtevlfucreate">mtev_lfu_create</h4>
<pre><code class="lang-c">mtev_lfu_create(<span class="hljs-keyword">int32_t</span> max_entries, <span class="hljs-keyword">void</span> (*free_fn)(<span class="hljs-keyword">void</span> *))
</code></pre>
<blockquote>
<p>Create an LFU of max_entries size</p>
</blockquote>
<p>  Will call free_fn when an item is evicted. if free_fn is null, call free().
  If max_entries == -1 then this devolves to a normal hashtable.</p>
<h4 id="mtevlfudestroy">mtev_lfu_destroy</h4>
<pre><code class="lang-c">mtev_lfu_destroy(<span class="hljs-keyword">mtev_lfu_t</span> *)
</code></pre>
<blockquote>
<p>Destroy the LFU</p>
</blockquote>
<h4 id="mtevlfuget">mtev_lfu_get</h4>
<pre><code class="lang-c"><span class="hljs-function">mtev_lfu_entry_token
<span class="hljs-title">mtev_lfu_get</span><span class="hljs-params">(mtev_lfu_t *lfu, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, size_t key_len, <span class="hljs-keyword">void</span> **value)</span>
</span></code></pre>
<blockquote>
<p>Get an item from the LFU by key</p>
</blockquote>
<p>  This will fetch the item at &quot;key&quot; and put the value in &quot;value&quot;. It will also
  return a token as the return value of the function.  This token is used
  as the checkout of the item from the LFU.  When you are finished using
  the value, you must call &quot;mtev_lfu_release(mtev_lfu_t *lfu, mtev_lfu_entry_token token)&quot;
  to let the LFU know that reclamation for that key/value is possible.</p>
<h4 id="mtevlfuinvalidate">mtev_lfu_invalidate</h4>
<pre><code class="lang-c">mtev_lfu_invalidate(<span class="hljs-keyword">mtev_lfu_t</span> *)
</code></pre>
<blockquote>
<p>Remove all entries from the LFU</p>
</blockquote>
<h4 id="mtevlfuiterate">mtev_lfu_iterate</h4>
<pre><code class="lang-c">void
mtev_lfu_iterate(mtev_lfu_t *lfu, void (*callback)(mtev_lfu_t *lfu, const char *key,
                 size_t key_len, void *value, void *closure), void *closure)
</code></pre>
<blockquote>
<p>Iterate through all entries in the LFU</p>
</blockquote>
<pre><code>* `lfu` The LFU to iterate
* `callback` This function is called for each item in the LFU
* `closure` The pointer to pass as the last param to the callback
</code></pre><p>  This leaves the LFU locked during iteration which will starve
  out other operations.  Keep this in mind if you are storing
  a lot of stuff in the LFU and have multithreaded access to it.</p>
<p>  The &quot;key&quot; and &quot;value&quot; passed to the callback function is direct
  LFU memory and should not be freed.</p>
<h4 id="mtevlfuput">mtev_lfu_put</h4>
<pre><code class="lang-c">mtev_lfu_put(<span class="hljs-keyword">mtev_lfu_t</span> *lfu, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">size_t</span> key_len, <span class="hljs-keyword">void</span> *value)
</code></pre>
<blockquote>
<p>Put a new item into the LFU</p>
</blockquote>
<p>  If some other thread has added a val at this key this will overwrite it and
  restart the frequency count at 1.</p>
<p>  This will cause an eviction of the least frequently used item if the cache is full.</p>
<h4 id="mtevlfurelease">mtev_lfu_release</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_lfu_release</span><span class="hljs-params">(mtev_lfu_t *lfu, mtev_lfu_entry_token token)</span>
</span></code></pre>
<blockquote>
<p>Surrender an item back to the LFU</p>
</blockquote>
<p>  To be memory safe LFU tokens must be released back to the LFU when
  the user is finished using them.</p>
<h4 id="mtevlfuremove">mtev_lfu_remove</h4>
<pre><code class="lang-c">mtev_lfu_remove(<span class="hljs-keyword">mtev_lfu_t</span> *lfu, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">size_t</span> key_len)
</code></pre>
<blockquote>
<p>Remove key from the LFU</p>
</blockquote>
<p>  This does not call the free_fn, instead it returns the value</p>
<h4 id="mtevlfusize">mtev_lfu_size</h4>
<pre><code class="lang-c">mtev_lfu_size(<span class="hljs-keyword">mtev_lfu_t</span> *lfu)
</code></pre>
<blockquote>
<p>Return the total entry count in the LFU</p>
</blockquote>
<h4 id="mtevlockfileacquire">mtev_lockfile_acquire</h4>
<blockquote>
<p>lock the file immediately if possible, return -1 otherwise.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_lockfile_t</span>
mtev_lockfile_acquire(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fp)
</code></pre>
<ul>
<li><code>fp</code> the path to the lock file</li>
<li><strong>RETURN</strong> &gt;= 0 on success, -1 on failure</li>
</ul>
<h4 id="mtevlockfileacquireowner">mtev_lockfile_acquire_owner</h4>
<blockquote>
<p>lock the file immediately if possible, return -1 otherwise.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_lockfile_t</span>
mtev_lockfile_acquire_owner(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fp, <span class="hljs-keyword">pid_t</span> *owner)
</code></pre>
<ul>
<li><code>fp</code> the path to the lock file</li>
<li><code>owner</code> is a pointer to a pid.  If the lock is owned by another process, this will be set to that pid, otherwise it will be set to -1.</li>
<li><strong>RETURN</strong> &gt;= 0 on success, -1 on failure</li>
</ul>
<h4 id="mtevlockfilerelease">mtev_lockfile_release</h4>
<blockquote>
<p>release a held file lock</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_lockfile_release</span><span class="hljs-params">(mtev_lockfile_t fd)</span>
</span></code></pre>
<ul>
<li><code>fd</code> the file lock to release</li>
<li><strong>RETURN</strong> -1 on failure, 0 on success</li>
</ul>
<h4 id="mtevlog">mtev_log</h4>
<blockquote>
<p>Log to a log stream (metadata, <code>va_list</code>)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">int</span> line,
         <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>now</code> the current time</li>
<li><code>file</code> a source file name</li>
<li><code>line</code> a source file line number</li>
<li><code>format</code> a <code>printf</code>-style format string</li>
<li><code>arg</code> a <code>varargs</code> list</li>
<li><strong>RETURN</strong> The number of bytes written or an approximation</li>
</ul>
<p>See mtev_ex_log.</p>
<h4 id="mtevlogentersighandler">mtev_log_enter_sighandler</h4>
<blockquote>
<p>Instruct the logging system that the current thread is in a signal handler.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_enter_sighandler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<h4 id="mtevlogfinalresolve">mtev_log_final_resolve</h4>
<blockquote>
<p>Instruct the logging system to rebuild its dependency graph with new information.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_log_final_resolve</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<p>This function is used to rebuild log streams that use <code>logops</code> that may have not been loaded
yet.  It is called automatically after the <code>mtev_dso</code> system loads a module.</p>
<h4 id="mtevlogflatbufferfrombuffer">mtev_log_flatbuffer_from_buffer</h4>
<blockquote>
<p>Given a <code>flatbuffer</code> serialization of a log line, convert it to the <code>flatcc</code> type.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_LogLine_fb_t
<span class="hljs-title">mtev_log_flatbuffer_from_buffer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buff, size_t buff_len)</span>
</span></code></pre>
<ul>
<li><code>buff</code> a pointer to memory containing the <code>flatbuffer</code> data.</li>
<li><code>buff_len</code> the length of the buffer <code>buff</code></li>
<li><strong>RETURN</strong> a <code>flatcc</code> <code>flatbuffer</code> type</li>
</ul>
<h4 id="mtevlogflatbuffertojson">mtev_log_flatbuffer_to_json</h4>
<blockquote>
<p>Convert a <code>flatcc</code> typed log line into a textual <code>JSON</code> serialization</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_flatbuffer_to_json</span><span class="hljs-params">(mtev_LogLine_fb_t ll, mtev_dyn_buffer_t *tgt)</span>
</span></code></pre>
<ul>
<li><code>ll</code> a <code>flatcc</code> <code>flatbuffer</code> type</li>
<li><code>tgt</code> a target buffer to write the <code>JSON</code> serialization to</li>
</ul>
<h4 id="mtevloggoasynch">mtev_log_go_asynch</h4>
<blockquote>
<p>Instruct the logging system to use asynchronous logging for higher performance.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_go_asynch</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> 0 on success, -1 on failure.</li>
</ul>
<p>The <code>mtev_main</code> helpers system automatically calls this.</p>
<h4 id="mtevloggosynch">mtev_log_go_synch</h4>
<blockquote>
<p>Instruct the logging system to use synchronous logging.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_go_synch</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> 0 on success, -1 on failure.</li>
</ul>
<p>This can be particularly useful when attempting debug a system.</p>
<h4 id="mtevloghasmaterialoutput">mtev_log_has_material_output</h4>
<blockquote>
<p>Determine if writing to a specific stream would materially go anywhere.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_log_has_material_output</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> <code>mtev_true</code> if writing would materialize.</li>
</ul>
<h4 id="mtevloghexdump">mtev_log_hexdump</h4>
<blockquote>
<p>Log a hex dump of memory</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_hexdump</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * addr, <span class="hljs-keyword">const</span> size_t len, uint8_t width)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>addr</code> a memory address</li>
<li><code>len</code> a size in bytes</li>
<li><code>width</code> the number of bytes to show per line.</li>
</ul>
<h4 id="mtevloginit">mtev_log_init</h4>
<blockquote>
<p>Initialize the logging system</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> debug_on)</span>
</span></code></pre>
<ul>
<li><code>debug_on</code> if non-zero the <code>mtev_debug</code> log stream will be enabled.</li>
</ul>
<h4 id="mtevloginitglobals">mtev_log_init_globals</h4>
<blockquote>
<p>Initialize the logging system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_init_globals</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<h4 id="mtevlogleavesighandler">mtev_log_leave_sighandler</h4>
<blockquote>
<p>Instruct the logging system that the current thread has left a signal handler.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_leave_sighandler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<h4 id="mtevloglist">mtev_log_list</h4>
<blockquote>
<p>Retrieve a list of log streams</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_list</span><span class="hljs-params">(mtev_log_stream_t *loggers, <span class="hljs-keyword">int</span> nsize)</span>
</span></code></pre>
<ul>
<li><code>loggers</code> an array of <code>nsize</code> log streams</li>
<li><code>nsize</code> the size of the <code>loggers</code> array</li>
<li><strong>RETURN</strong> The number of log streams placed in the <code>loggers</code> array.  If there was insufficient space, the number of elements required is made negative and returned.</li>
</ul>
<h4 id="mtevlogmemorylines">mtev_log_memory_lines</h4>
<blockquote>
<p>Iterate over a fixed set of &quot;memory&quot; log lines invoking a callback for each.</p>
</blockquote>
<pre><code class="lang-c">int
mtev_log_memory_lines(mtev_log_stream_t ls, int log_lines, int (*cb)(uint64_t logid,
                      const struct timeval *whence, const char *text, size_t text_len,
                      void *closure), void *closure)
</code></pre>
<ul>
<li><code>ls</code> a log stream of type &quot;memory&quot;</li>
<li><code>log_lines</code> the number of most recent log lines to traverse</li>
<li><code>cb</code> a callback to invoke for each log line found</li>
<li><code>closure</code> a user-supplied closure to pass into the callback</li>
<li><strong>RETURN</strong> The number of log lines traversed, -1 on error.</li>
</ul>
<h4 id="mtevlogmemorylinessince">mtev_log_memory_lines_since</h4>
<blockquote>
<p>Iterate over a fixed set of &quot;memory&quot; log lines invoking a callback for each.</p>
</blockquote>
<pre><code class="lang-c">int
mtev_log_memory_lines_since(mtev_log_stream_t ls, uint64_t afterwhich, int (*cb)(uint64_t logid,
                            const struct timeval *whnce, const char *text, size_t text_len, void *closure)
                            void *closure)
</code></pre>
<ul>
<li><code>ls</code> a log stream of type &quot;memory&quot;</li>
<li><code>afterwhich</code> the the log id after which traversal should start (log id is the first argument to the callback)</li>
<li><code>cb</code> a callback to invoke for each log line found</li>
<li><code>closure</code> a user-supplied closure to pass into the callback</li>
<li><strong>RETURN</strong> The number of log lines traversed, -1 on error.</li>
</ul>
<h4 id="mtevlogreopenall">mtev_log_reopen_all</h4>
<blockquote>
<p>Instruct the logging system to reopen all logs if applicable.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_reopen_all</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> 0 on success, -1 on failure.</li>
</ul>
<h4 id="mtevlogreopentype">mtev_log_reopen_type</h4>
<blockquote>
<p>Instruct the logging system to reopen all logs of a specific type.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_reopen_type</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *type)</span>
</span></code></pre>
<ul>
<li><code>type</code> a type matching a logops name.</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure.</li>
</ul>
<h4 id="mtevlogspeculate">mtev_log_speculate</h4>
<blockquote>
<p>Create a new speculative logging buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_log_stream_t</span>
mtev_log_speculate(<span class="hljs-keyword">int</span> nlogs, <span class="hljs-keyword">int</span> nbytes)
</code></pre>
<ul>
<li><code>nlogs</code> store at most <code>nlogs</code> log lines</li>
<li><code>nbytes</code> store at most <code>nbytes</code> bytes.</li>
<li><strong>RETURN</strong> a new log stream</li>
</ul>
<h4 id="mtevlogspeculatefinish">mtev_log_speculate_finish</h4>
<blockquote>
<p>Finish speculation on a speculative log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_speculate_finish</span><span class="hljs-params">(mtev_log_stream_t ls, mtev_log_stream_t speculation)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream to which you wish to commit the speculation, <code>MTEV_LOG_SPECULATE_ROLLBACK</code> to discard</li>
<li><code>speculation</code> a speculative log stream created with <code>mtev_log_speculate</code></li>
</ul>
<h4 id="mtevlogstreamaddstream">mtev_log_stream_add_stream</h4>
<blockquote>
<p>Connect a log stream to another log stream.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_add_stream</span><span class="hljs-params">(mtev_log_stream_t ls, mtev_log_stream_t outlet)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream whose output should be sent to <code>outlet</code></li>
<li><code>outlet</code> a log stream</li>
</ul>
<h4 id="mtevlogstreamaddstreamfiltered">mtev_log_stream_add_stream_filtered</h4>
<blockquote>
<p>Connect a log stream to another log stream with a filter.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_log_stream_add_stream_filtered</span><span class="hljs-params">(mtev_log_stream_t ls, mtev_log_stream_t outlet, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filter)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream whose output should be sent to <code>outlet</code></li>
<li><code>outlet</code> a log stream</li>
<li><code>filter</code> an expression parsable by <code>mtev_logic</code></li>
<li><strong>RETURN</strong> <code>mtev_true</code> if the log streams could be connected with the give filter.</li>
</ul>
<h4 id="mtevlogstreamclose">mtev_log_stream_close</h4>
<blockquote>
<p>Close a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_close</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
</ul>
<h4 id="mtevlogstreamcull">mtev_log_stream_cull</h4>
<blockquote>
<p>Cull old and/or excessive log contents</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_stream_cull</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">int</span> age, ssize_t bytes)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream to cull</li>
<li><code>age</code> the maximum age in seconds to retain, -1 to skip the age assessment</li>
<li><code>bytes</code> the maximum bytes to retain, -1 to skip the size assessment</li>
<li><strong>RETURN</strong> -1 on error, positive if culling occurred, 0 if no action was taken</li>
</ul>
<p>Only certain <code>logops</code> support culling, if the <code>logops</code> do not support it -1 is usually returned.</p>
<h4 id="mtevlogstreamexists">mtev_log_stream_exists</h4>
<blockquote>
<p>Check the existence of a log stream in the logging system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_log_stream_exists</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span>
</span></code></pre>
<ul>
<li><code>name</code> a possible name of a log stream</li>
<li><strong>RETURN</strong> <code>mtev_true</code> if a log stream of name <code>name</code> is configured</li>
</ul>
<h4 id="mtevlogstreamfind">mtev_log_stream_find</h4>
<blockquote>
<p>Find a log stream in the logging system</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_log_stream_t</span>
mtev_log_stream_find(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>name</code> a name of a log stream</li>
<li><strong>RETURN</strong> a log stream, creating a virtual one if no such name already exists.</li>
</ul>
<p>Log streams that are implicitly created will be enabled by default and outlet to
a log stream above it in its slash-delimited hierarchy.  For example: <code>debug/foo/bar</code>
will be implicitly created to outlet to <code>debug/foo</code> which will be implicitly created
to outlet to <code>debug</code>.  If a new top-level stream is implicitly created, it is
enabled but will have no outlets and thus be immaterial until connected.</p>
<h4 id="mtevlogstreamfindf">mtev_log_stream_findf</h4>
<blockquote>
<p>Find a log stream with <code>printf(3)</code> style.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_log_stream
<span class="hljs-title">mtev_log_stream_findf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)</span>
</span></code></pre>
<ul>
<li><code>fmt</code> a <code>printf</code>-style format string with appropriate trailing arguments</li>
<li><strong>RETURN</strong> a log stream</li>
</ul>
<p>This formats the stream and calls <code>mtev_log_string_find</code>.</p>
<h4 id="mtevlogstreamfree">mtev_log_stream_free</h4>
<blockquote>
<p>Free the in-memory resources related to a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_free</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
</ul>
<h4 id="mtevlogstreamgetctx">mtev_log_stream_get_ctx</h4>
<blockquote>
<p>Set the custom context for a log stream.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_get_ctx</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">void</span> *ctx)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>ctx</code> a user-supplied context.</li>
</ul>
<p>This is used by <code>logops</code> implementors to manage context.</p>
<h4 id="mtevlogstreamgetflags">mtev_log_stream_get_flags</h4>
<blockquote>
<p>Get the flags set on a particular log stream.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_stream_get_flags</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> The bitset of flags.</li>
</ul>
<h4 id="mtevlogstreamgetname">mtev_log_stream_get_name</h4>
<blockquote>
<p>Get the name of a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">mtev_log_stream_get_name</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> The name</li>
</ul>
<h4 id="mtevlogstreamgetpath">mtev_log_stream_get_path</h4>
<blockquote>
<p>Get the path from a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">mtev_log_stream_get_path</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> The path, <code>NULL</code> if none</li>
</ul>
<h4 id="mtevlogstreamgetproperty">mtev_log_stream_get_property</h4>
<blockquote>
<p>Retrieve configuration property values from a log stream.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">mtev_log_stream_get_property</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>key</code> the key to look up in the log stream&apos;s options</li>
<li><strong>RETURN</strong> A value associated with the provided key, <code>NULL</code> if not found.</li>
</ul>
<h4 id="mtevlogstreamgettype">mtev_log_stream_get_type</h4>
<blockquote>
<p>Get the type (name of logops) from a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">mtev_log_stream_get_type</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> The name of the <code>logops</code>, <code>NULL</code> if none</li>
</ul>
<h4 id="mtevlogstreamnew">mtev_log_stream_new</h4>
<blockquote>
<p>Create a new log stream of a specific type.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_log_stream_t</span>
mtev_log_stream_new(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">void</span> *ctx
                    mtev_hash_table *options)
</code></pre>
<ul>
<li><code>name</code> a name for the log stream</li>
<li><code>type</code> a type of <code>logops</code></li>
<li><code>path</code> a path appropriate for the selected <code>logops</code></li>
<li><code>ctx</code> a context for the log stream&apos;s selected <code>logops</code></li>
<li><code>options</code> a table of options attached to the log stream</li>
<li><strong>RETURN</strong> a new log stream or <code>NULL</code> on error</li>
</ul>
<p>This will replace a log stream of the same name should one exist.</p>
<h4 id="mtevlogstreamnewonfd">mtev_log_stream_new_on_fd</h4>
<blockquote>
<p>Create a new log stream using appropriate <code>logops</code> attached to output to a file descriptor.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_log_stream_t</span>
mtev_log_stream_new_on_fd(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">int</span> fd, mtev_hash_table *options)
</code></pre>
<ul>
<li><code>name</code> a name for the log stream</li>
<li><code>fd</code> the file descriptor for output</li>
<li><code>options</code> a table of options attached to the log stream</li>
<li><strong>RETURN</strong> a new log stream or <code>NULL</code> on error</li>
</ul>
<p>This will replace a log stream of the same name should one exist.</p>
<h4 id="mtevlogstreamnewonfile">mtev_log_stream_new_on_file</h4>
<blockquote>
<p>Create a new file-based log stream.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_log_stream_t</span>
mtev_log_stream_new_on_file(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, mtev_hash_table *options)
</code></pre>
<ul>
<li><code>path</code> the path to the file. This is also used as the log stream&apos;s name</li>
<li><code>options</code> a table of options attached to the log stream</li>
<li><strong>RETURN</strong> a new log stream, <code>NULL</code> on error</li>
</ul>
<h4 id="mtevlogstreampipeclose">mtev_log_stream_pipe_close</h4>
<blockquote>
<p>Close a log stream pipe that will not be used.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_pipe_close</span><span class="hljs-params">(mtev_log_stream_pipe_t *lp)</span>
</span></code></pre>
<ul>
<li><code>lp</code> a log stream pipe</li>
</ul>
<h4 id="mtevlogstreampipedup2">mtev_log_stream_pipe_dup2</h4>
<blockquote>
<p>Relocate the child end of the log stream pipe to a specific file descriptor</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_stream_pipe_dup2</span><span class="hljs-params">(mtev_log_stream_pipe_t *lp, <span class="hljs-keyword">int</span> fd)</span>
</span></code></pre>
<ul>
<li><code>lp</code> a log stream pipe</li>
<li><code>fd</code> a target file descriptor, it&apos;s atomically closed and replaced</li>
<li><strong>RETURN</strong> The return of the internal <code>dup2(2)</code> system call.</li>
</ul>
<h4 id="mtevlogstreampipenew">mtev_log_stream_pipe_new</h4>
<blockquote>
<p>Create a <code>mtev_log_stream_pipe_t</code> suitable for cross-process logging</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_log_stream_pipe_t</span> *
mtev_log_stream_pipe_new(<span class="hljs-keyword">mtev_log_stream_t</span> ls)
</code></pre>
<ul>
<li><code>ls</code> the target log stream</li>
<li><strong>RETURN</strong> a new log stream pipe</li>
</ul>
<h4 id="mtevlogstreampipepostforkchild">mtev_log_stream_pipe_post_fork_child</h4>
<blockquote>
<p>Prepare a log stream pipe for use in the child process post-fork</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_pipe_post_fork_child</span><span class="hljs-params">(mtev_log_stream_pipe_t *lp)</span>
</span></code></pre>
<ul>
<li><code>lp</code> a log stream pipe</li>
</ul>
<h4 id="mtevlogstreampipepostforkparent">mtev_log_stream_pipe_post_fork_parent</h4>
<blockquote>
<p>Prepare a log stream pipe for use in the parent process post-fork</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_pipe_post_fork_parent</span><span class="hljs-params">(mtev_log_stream_pipe_t *lp)</span>
</span></code></pre>
<ul>
<li><code>lp</code> a log stream pipe</li>
</ul>
<h4 id="mtevlogstreamremove">mtev_log_stream_remove</h4>
<blockquote>
<p>Remove a log stream from the logging system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span>
</span></code></pre>
<ul>
<li><code>name</code> name of a log stream to remove</li>
</ul>
<h4 id="mtevlogstreamremovestream">mtev_log_stream_remove_stream</h4>
<blockquote>
<p>Disconnect a specific outlet by name from a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_log_stream_t</span>
mtev_log_stream_remove_stream(<span class="hljs-keyword">mtev_log_stream_t</span> ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>ls</code> a log stream from which to attempt removing an outlet</li>
<li><code>name</code> the name of the log stream that should no longer be in the outlet list</li>
<li><strong>RETURN</strong> a log stream that was disconnected, NULL if no log stream outlet was disconnected</li>
</ul>
<h4 id="mtevlogstreamremoveallstreams">mtev_log_stream_removeall_streams</h4>
<blockquote>
<p>Remove all outlets from a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_removeall_streams</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
</ul>
<h4 id="mtevlogstreamrename">mtev_log_stream_rename</h4>
<blockquote>
<p>Rename a log stream&apos;s target if supported</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_stream_rename</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>path</code> a new path name, <code>MTEV_LOG_RENAME_AUTOTIME</code> to automatically name it with the current timestamp (required for culling by age)</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure.</li>
</ul>
<p>If called manually, a call to <code>mtev_log_stream_reopen</code> should follow.</p>
<h4 id="mtevlogstreamreopen">mtev_log_stream_reopen</h4>
<blockquote>
<p>Reopen a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_reopen</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream to reopen</li>
</ul>
<h4 id="mtevlogstreamsetflags">mtev_log_stream_set_flags</h4>
<blockquote>
<p>Get the flags set on a particular log stream.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_log_stream_set_flags</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">int</span> flags)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>flags</code> a new set of replacement flags.</li>
<li><strong>RETURN</strong> The bitset of flags that were replaced.</li>
</ul>
<h4 id="mtevlogstreamsetformat">mtev_log_stream_set_format</h4>
<blockquote>
<p>Set the format on a particular log stream.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_log_stream_set_format</span><span class="hljs-params">(mtev_log_stream_t ls, mtev_log_format format)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>format</code> a format identitier</li>
<li><strong>RETURN</strong> <code>mtev_true</code> if successful</li>
</ul>
<p>A log stream without <code>logops</code> cannot have a format set.</p>
<h4 id="mtevlogstreamsetproperty">mtev_log_stream_set_property</h4>
<blockquote>
<p>Set or replace a key-value property on a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_log_stream_set_property</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *value)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>key</code> a key</li>
<li><code>value</code> a value, <code>NULL</code> is allowed.</li>
</ul>
<h4 id="mtevlogstreamsize">mtev_log_stream_size</h4>
<blockquote>
<p>Determine the space occupied by a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_log_stream_size(<span class="hljs-keyword">mtev_log_stream_t</span> ls)
</code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> A size in bytes, if the <code>logops</code> of the given stream supports size assessment, 0 otherwise.</li>
</ul>
<h4 id="mtevlogstreamstatsenable">mtev_log_stream_stats_enable</h4>
<blockquote>
<p>Request that the log stream register statistics with the <code>mtev_stats</code> system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_log_stream_stats_enable</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> <code>mtev_true</code> is successfully registered with the stats system.</li>
</ul>
<h4 id="mtevlogstreamtojson">mtev_log_stream_to_json</h4>
<blockquote>
<p>Get a JSON description of a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_json_object *
<span class="hljs-title">mtev_log_stream_to_json</span><span class="hljs-params">(mtev_log_stream_t ls)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> A mtev_json_object describing the log stream</li>
</ul>
<h4 id="mtevlogstreamwritten">mtev_log_stream_written</h4>
<blockquote>
<p>Report the number of bytes written to a log stream</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_log_stream_written(<span class="hljs-keyword">mtev_log_stream_t</span> ls)
</code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><strong>RETURN</strong> A size in bytes since the application started.</li>
</ul>
<h4 id="mtevlualmcalloc">mtev_lua_lmc_alloc</h4>
<blockquote>
<p>Allocated and initialize a <code>lua_module_closure_t</code> for a new runtime.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">lua_module_closure_t</span> *
mtev_lua_lmc_alloc(<span class="hljs-keyword">mtev_dso_generic_t</span> *self, <span class="hljs-keyword">mtev_lua_resume_info_t</span> *resume)
</code></pre>
<ul>
<li><code>self</code> the module implementing a custom lua runtime environment</li>
<li><code>resume</code> the custom resume function for this environment</li>
<li><strong>RETURN</strong> a new allocated and initialized <code>lua_module_closure</code></li>
</ul>
<blockquote>
<p>Note these are not thread safe because lua is not thread safe. If you are managing multiple
C threads, you should have a <code>lua_module_closure_t</code> for each thread and maintain them in a
thread-local fashion.  Also ensure that any use of the eventer does not migrate cross thread.</p>
</blockquote>
<h4 id="mtevlualmcfree">mtev_lua_lmc_free</h4>
<blockquote>
<p>Free a <code>lua_module_closure_t</code> structure that has been allocated.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_lua_lmc_free</span><span class="hljs-params">(lua_module_closure_t *lmc)</span>
</span></code></pre>
<ul>
<li><code>lmc</code> The <code>lua_module_closure_t</code> to be freed.</li>
</ul>
<h4 id="mtevlualmcl">mtev_lua_lmc_L</h4>
<blockquote>
<p>Get the <code>lua_State *</code> for this module closure.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">lua_State *
<span class="hljs-title">mtev_lua_lmc_L</span><span class="hljs-params">(lua_module_closure_t *lmc)</span>
</span></code></pre>
<ul>
<li><code>lmc</code> the <code>lua_module_closure_t</code> that was allocated for this runtime.</li>
<li><strong>RETURN</strong> a Lua state</li>
</ul>
<h4 id="mtevlualmcresume">mtev_lua_lmc_resume</h4>
<blockquote>
<p>Invoke lua_resume with the correct context based on the <code>lua_module_closure_t</code></p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_lua_lmc_resume</span><span class="hljs-params">(lua_module_closure_t *lmc, mtev_lua_resume_info_t *ri, <span class="hljs-keyword">int</span> nargs)</span>
</span></code></pre>
<ul>
<li><code>lmc</code> the <code>lua_module_closure_t</code> associated with the current lua runtime.</li>
<li><code>ri</code> resume meta information</li>
<li><code>nargs</code> the number of arguments on the lua stack to return</li>
<li><strong>RETURN</strong> the return value of the underlying <code>lua_resume</code> call.</li>
</ul>
<h4 id="mtevlualmcsetl">mtev_lua_lmc_setL</h4>
<blockquote>
<p>Set the <code>lua_State *</code> for this module closure, returning the previous value.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">lua_State *
<span class="hljs-title">mtev_lua_lmc_setL</span><span class="hljs-params">(lua_module_closure_t *lmc)</span>
</span></code></pre>
<ul>
<li><code>lmc</code> the <code>lua_module_closure_t</code> that was allocated for this runtime.</li>
<li><code>lmc</code> the <code>lua_State *</code> that should be placed in this closure.</li>
<li><strong>RETURN</strong> the previous lua Lua state associated with this closure</li>
</ul>
<h3 id="m">M</h3>
<h4 id="mtevmain">mtev_main</h4>
<blockquote>
<p>Run a comprehensive mtev setup followed by a &quot;main&quot; routine.</p>
</blockquote>
<pre><code class="lang-c">int
mtev_main(const char *appname, const char *config_filename, int debug, int foreground,
          mtev_log_op_t lock, const char *glider, const char *drop_to_user,
          const char *drop_to_group, int (*passed_child_main)(void))
</code></pre>
<ul>
<li><code>appname</code> The application name (should be the config root node name).</li>
<li><code>config_filename</code> The path the the config file.</li>
<li><code>debug</code> Enable debugging (logging).</li>
<li><code>foreground</code> 0 to daemonize with watchdog, 1 to foreground, 2 to foreground with watchdog.</li>
<li><code>lock</code> Specifies where to not lock, try lock or exit, or lock or wait.</li>
<li><code>glider</code> A path to an executable to invoke against the process id on crash. May be NULL.</li>
<li><code>drop_to_user</code> A target user for dropping privileges when under watchdog. May be NULL.</li>
<li><code>drop_to_group</code> A target group for dropping privileges when under watchdog. May be NULL.</li>
<li><code>passed_child_main</code> A programmers supplied main function.</li>
<li><strong>RETURN</strong> -1 on failure, 0 on success if <code>foreground==1</code>, or the return value of <code>main</code> if run in the foreground.</li>
</ul>
<h4 id="mtevmaineventerconfig">mtev_main_eventer_config</h4>
<blockquote>
<p>Set <eventer><config> options for an app that need not be specified explicitly in a config.</config></eventer></p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_main_eventer_config</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *value)</span>
</span></code></pre>
<ul>
<li><code>name</code> The config key name</li>
<li><code>value</code> The value of the config option</li>
</ul>
<h4 id="mtevmainstatus">mtev_main_status</h4>
<blockquote>
<p>Determine if that application is already running under this configuration.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_main_status</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *appname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *config_filename, <span class="hljs-keyword">int</span> debug, pid_t *pid
                 pid_t *pgid)</span>
</span></code></pre>
<ul>
<li><code>appname</code> The application name (should be the config root node name).</li>
<li><code>config_filename</code> The path the the config file.</li>
<li><code>debug</code> Enable debugging (logging).</li>
<li><code>pid</code> If not null, it is populated with the process id of the running instance.</li>
<li><code>pgid</code> If not null, it is populated with the process group id of the running instance.</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure.</li>
</ul>
<h4 id="mtevmainterminate">mtev_main_terminate</h4>
<blockquote>
<p>Terminate an already running application under the same configuration.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_main_terminate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *appname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *config_filename, <span class="hljs-keyword">int</span> debug)</span>
</span></code></pre>
<ul>
<li><code>appname</code> The application name (should be the config root node name).</li>
<li><code>config_filename</code> The path the the config file.</li>
<li><code>debug</code> Enable debugging (logging).</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure.  If the application is not running at the time of invocation, termination is considered successful.</li>
</ul>
<h4 id="mtevmaybedecl">MTEV_MAYBE_DECL</h4>
<blockquote>
<p>C Macro for declaring a &quot;maybe&quot; buffer.</p>
</blockquote>
<pre><code class="lang-c">MTEV_MAYBE_DECL(type, name, cnt)
</code></pre>
<ul>
<li><code>type</code> A C type (e.g. char)</li>
<li><code>name</code> The name of the C variable to declare.</li>
<li><code>cnt</code> The number of type elements initially declared.</li>
</ul>
<p>A &quot;maybe&quot; buffer is a buffer that is allocated on-stack, but
if more space is required can be reallocated off stack (malloc).
One should always call <code>MTEV_MAYBE_FREE</code> on any allocated
maybe buffer.</p>
<h4 id="mtevmaybedeclvars">MTEV_MAYBE_DECL_VARS</h4>
<blockquote>
<p>C Macro for declaring a &quot;maybe&quot; buffer.</p>
</blockquote>
<pre><code class="lang-c">MTEV_MAYBE_DECL_VARS(type, name, cnt)
</code></pre>
<ul>
<li><code>type</code> A C type (e.g. char)</li>
<li><code>name</code> The name of the C variable to declare.</li>
<li><code>cnt</code> The number of type elements initially declared.</li>
</ul>
<h4 id="mtevmaybefree">MTEV_MAYBE_FREE</h4>
<blockquote>
<p>C Macro to free any heap space associated with a &quot;maybe&quot; buffer.</p>
</blockquote>
<pre><code class="lang-c">MTEV_MAYBE_FREE(name)
</code></pre>
<ul>
<li><code>name</code> The name of the &quot;maybe&quot; buffer.</li>
</ul>
<h4 id="mtevmaybeinitvars">MTEV_MAYBE_INIT_VARS</h4>
<blockquote>
<p>C Macro for initializing a &quot;maybe&quot; buffer</p>
</blockquote>
<pre><code class="lang-c">MTEV_MAYBE_INIT_VARS(name)
</code></pre>
<ul>
<li><code>name</code> The name of &quot;maybe&quot; buffer.</li>
</ul>
<h4 id="mtevmayberealloc">MTEV_MAYBE_REALLOC</h4>
<blockquote>
<p>C Macro to ensure a maybe buffer has at least cnt elements allocated.</p>
</blockquote>
<pre><code class="lang-c">MTEV_MAYBE_REALLOC(name, cnt)
</code></pre>
<ul>
<li><code>name</code> The name of the &quot;maybe&quot; buffer.</li>
<li><code>cnt</code> The total number of elements expected in the allocation.</li>
</ul>
<p>This macro will never reduce the size and is a noop if a size smaller
than or equal to the current allocation size is specified.  It is safe
to simply run this macro prior to each write to the buffer.</p>
<h4 id="mtevmaybereallocwithtype">MTEV_MAYBE_REALLOC_WITH_TYPE</h4>
<blockquote>
<p>C/C++ Macro to ensure a maybe buffer has at least cnt elements allocated.</p>
</blockquote>
<pre><code class="lang-c">MTEV_MAYBE_REALLOC_WITH_TYPE(name, type, cnt)
</code></pre>
<ul>
<li><code>name</code> The name of the &quot;maybe&quot; buffer.</li>
<li><code>type</code> The type of the &quot;maybe&quot; buffer.</li>
<li><code>cnt</code> The total number of elements expected in the allocation.</li>
</ul>
<p>This macro will never reduce the size and is a noop if a size smaller
than or equal to the current allocation size is specified.  It is safe
to simply run this macro prior to each write to the buffer.
NOTE: this version is separate to avoid breaking existing code that uses the
older macro.  It allows usage with C++, which requires the memory allocation
pointer to be cast to the correct type before assignment.</p>
<h4 id="mtevmaybesize">MTEV_MAYBE_SIZE</h4>
<blockquote>
<p>C Macro for number of bytes available in this buffer.</p>
</blockquote>
<pre><code class="lang-c">MTEV_MAYBE_SIZE(name)
</code></pre>
<ul>
<li><code>name</code> The name of the &quot;maybe&quot; buffer.</li>
</ul>
<h4 id="mtevmergesort">mtev_merge_sort</h4>
<blockquote>
<p>Merge sort data starting at head_ptr_ptr, iteratively</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">void</span> **head_ptr_ptr, mtev_sort_next_function next,
                mtev_sort_set_next_function set_next, mtev_sort_compare_function compare)</span>
</span></code></pre>
<ul>
<li><code>next</code> the function to call to get the next pointer from a node</li>
<li><code>set_next</code> the function to call to alter the item directly after current</li>
<li><code>compare</code> the function to call to compare 2 nodes</li>
</ul>
<h4 id="mkdirforfile">mkdir_for_file</h4>
<blockquote>
<p>Create directories along a path.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mkdir_for_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, mode_t m)</span>
</span></code></pre>
<ul>
<li><code>file</code> a filename for which a directory is desired.</li>
<li><code>m</code> the mode used for creating directories.</li>
<li><strong>RETURN</strong> Returns 0 on success, -1 on error.</li>
</ul>
<p>Creates all directories from / (as needed) to hold a named file.</p>
<h4 id="mtevassert">mtevAssert</h4>
<blockquote>
<p>MACRO that calls <code>mtevFatal</code> if the condition evaluates to false.</p>
</blockquote>
<pre><code class="lang-c">mtevAssert(condition)
</code></pre>
<h4 id="mtevel">mtevEL</h4>
<blockquote>
<p>MACRO write to a log stream</p>
</blockquote>
<pre><code class="lang-c">mtevEL(<span class="hljs-keyword">mtev_log_stream_t</span> ls, <span class="hljs-keyword">mtev_log_kv_t</span> *meta, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)
</code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>meta</code> extra metadata</li>
<li><code>fmt</code> a <code>printf</code>-style format string</li>
<li><code>...</code> <code>printf</code> arguments</li>
</ul>
<p>This calls <code>mtevELT</code> with <code>NULL</code> as the time argument such that the current time is determined
in the logging system.  These short-form macros should almost always be used as they will
make efforts to skip evaluation of the arguments if the logging would not materialize anywhere.</p>
<p>Example: <code>mtevEL(mtev_error, MLKV{ MLKV_NUM(&quot;answer&quot;, 42&quot;), MLKV_STR(&quot;question&quot;, &quot;what?&quot;), MLKV_END }, &quot;hello %s\n&quot;, name);</code></p>
<h4 id="mtevelt">mtevELT</h4>
<blockquote>
<p>MACRO write to a log stream</p>
</blockquote>
<pre><code class="lang-c">mtevELT(<span class="hljs-keyword">mtev_log_stream_t</span> ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">mtev_log_kv_t</span> *meta,
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)
</code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>now</code> a timeval representing the current time</li>
<li><code>meta</code> extra metadata</li>
<li><code>fmt</code> a <code>printf</code>-style format string</li>
<li><code>...</code> <code>printf</code> arguments</li>
</ul>
<h4 id="mtevevalassert">mtevEvalAssert</h4>
<blockquote>
<p>MACRO that calls <code>mtevFatal</code> if the condition evaluates to false.</p>
</blockquote>
<pre><code class="lang-c">mtevEvalAssert(condition)
</code></pre>
<h4 id="mtevfatal">mtevFatal</h4>
<blockquote>
<p>MACRO to abort after logging.</p>
</blockquote>
<pre><code class="lang-c">mtevFatal(<span class="hljs-keyword">mtev_log_stream_t</span> ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)
</code></pre>
<p>This function will force the logging system into synchronous behavior, log with <code>mtevL</code>, and abort.</p>
<h4 id="mtevl">mtevL</h4>
<blockquote>
<p>MACRO write to a log stream</p>
</blockquote>
<pre><code class="lang-c">mtevL(<span class="hljs-keyword">mtev_log_stream_t</span> ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)
</code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>fmt</code> a <code>printf</code>-style format string</li>
<li><code>...</code> <code>printf</code> arguments</li>
</ul>
<h4 id="mtevlt">mtevLT</h4>
<blockquote>
<p>MACRO write to a log stream</p>
</blockquote>
<pre><code class="lang-c">mtevLT(<span class="hljs-keyword">mtev_log_stream_t</span> ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)
</code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>now</code> a timeval representing the current time</li>
<li><code>fmt</code> a <code>printf</code>-style format string</li>
<li><code>...</code> <code>printf</code> arguments</li>
</ul>
<h4 id="mtevterminate">mtevTerminate</h4>
<blockquote>
<p>MACRO to abort after logging.</p>
</blockquote>
<pre><code class="lang-c">mtevTerminate(<span class="hljs-keyword">mtev_log_stream_t</span> ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)
</code></pre>
<p>This function will force the logging system into synchronous behavior, log with <code>mtevL</code>, and <code>exit(2)</code>.</p>
<h3 id="n">N</h3>
<h4 id="mtevnowms">mtev_now_ms</h4>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span>
mtev_now_ms()
</code></pre>
<blockquote>
<p>the current system time in milliseconds</p>
</blockquote>
<pre><code>* **RETURN** mtev_gettimeofday() in milliseconds since epoch
</code></pre><h4 id="mtevnowus">mtev_now_us</h4>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span>
mtev_now_us()
</code></pre>
<blockquote>
<p>the current system time in microseconds</p>
</blockquote>
<pre><code>* **RETURN** mtev_gettimeofday() in microseconds since epoch
</code></pre><h3 id="r">R</h3>
<h4 id="mtevrand">mtev_rand</h4>
<blockquote>
<p>Generate a pseudo-random number between [0,2^64)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span>
mtev_rand(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><strong>RETURN</strong> A pseudo-random number in the range [0,2^64)</li>
</ul>
<h4 id="mtevrandbuf">mtev_rand_buf</h4>
<blockquote>
<p>Fill a buffer with pseudo-random bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_rand_buf(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len)
</code></pre>
<ul>
<li><code>buf</code> A buffer to fill.</li>
<li><code>len</code> The number of bytes to populate.</li>
<li><strong>RETURN</strong> The number of bytes written to <code>buf</code> (always <code>len</code>).</li>
</ul>
<h4 id="mtevrandbufsecure">mtev_rand_buf_secure</h4>
<blockquote>
<p>Fill a buffer with securely random bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_rand_buf_secure(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len)
</code></pre>
<ul>
<li><code>buf</code> A buffer to fill.</li>
<li><code>len</code> The number of bytes to populate.</li>
<li><strong>RETURN</strong> The number of bytes written to <code>buf</code> (&lt; len if insufficient entropy).</li>
</ul>
<h4 id="mtevrandbuftrysecure">mtev_rand_buf_trysecure</h4>
<blockquote>
<p>Fill a buffer with likely secure, but possibly pseudo-random bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_rand_buf_trysecure(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len)
</code></pre>
<ul>
<li><code>buf</code> A buffer to fill.</li>
<li><code>len</code> The number of bytes to populate.</li>
<li><strong>RETURN</strong> The number of bytes written to <code>buf</code> (always <code>len</code>).</li>
</ul>
<h4 id="mtevrandsecure">mtev_rand_secure</h4>
<blockquote>
<p>Generate a secure random number.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_rand_secure</span><span class="hljs-params">(uint64_t *out)</span>
</span></code></pre>
<ul>
<li><code>out</code> A pointer to a <code>uint64_t</code> in which a securely generated random number will be stored.</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure (not enough entropy available).</li>
</ul>
<h4 id="mtevrandtrysecure">mtev_rand_trysecure</h4>
<blockquote>
<p>Generate a likely secure, but possibly pseudo-random number between [0,2^64)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span>
mtev_rand_trysecure(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><strong>RETURN</strong> A random pseudo-random number in the range [0,2^64)</li>
</ul>
<h4 id="mtevregisterlogops">mtev_register_logops</h4>
<blockquote>
<p>Register a new set of named logging operations.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_register_logops</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *type, logops_t *ops)</span>
</span></code></pre>
<ul>
<li><code>type</code> a type naming this type of logging</li>
<li><code>ops</code> a structure with callbacks to drive logging operations.</li>
</ul>
<p>This operation will not replace an existing <code>logops</code> of the same name.</p>
<h3 id="s">S</h3>
<h4 id="mtevsecuritychroot">mtev_security_chroot</h4>
<blockquote>
<p>chroot(2) to the specified directory.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_security_chroot</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span>
</span></code></pre>
<ul>
<li><code>path</code> The path to chroot to.</li>
<li><strong>RETURN</strong> Zero is returned on success.</li>
</ul>
<p>mtev_security_chroot placing the calling application into a chroot
environment.</p>
<h4 id="mtevsecuritysetcaps">mtev_security_setcaps</h4>
<blockquote>
<p>change the capabilities of the process</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_security_setcaps</span><span class="hljs-params">(mtev_security_captype_t type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *capstring)</span>
</span></code></pre>
<ul>
<li><code>which</code> the effective, inherited or both</li>
<li><code>capstring</code> alteration to the capabilities</li>
<li><strong>RETURN</strong> Zero is returned on success.</li>
</ul>
<p>mtev_security_setcaps will change the capability set of the current
process.</p>
<h4 id="mtevsecurityusergroup">mtev_security_usergroup</h4>
<blockquote>
<p>change the effective or real, effective and saved user and group</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_security_usergroup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *group, mtev_boolean effective)</span>
</span></code></pre>
<ul>
<li><code>user</code> The user name as either a login or a userid in string form.</li>
<li><code>group</code> The group name as either a login or a groupid in string form.</li>
<li><code>effective</code> If true then only effective user and group are changed.</li>
<li><strong>RETURN</strong> Zero is returned on success.</li>
</ul>
<p>mtev_security_usergroup will change the real, effective, and saved
user and group for the calling process.  This is thread-safe.</p>
<h4 id="mtevsemdestroy">mtev_sem_destroy</h4>
<blockquote>
<p>releases all resources related to a semaphore</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_sem_destroy</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore to destroy</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsemgetvalue">mtev_sem_getvalue</h4>
<blockquote>
<p>retrieves the current value of a semaphore, placing it in *value</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_sem_getvalue</span><span class="hljs-params">(mtev_sem_t *s, <span class="hljs-keyword">int</span> *value)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to operate</li>
<li><code>value</code> a pointer an integer that will be populated with the current value of the semaphore</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevseminit">mtev_sem_init</h4>
<blockquote>
<p>initializes a counting semaphore for first time use.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_sem_init</span><span class="hljs-params">(mtev_sem_t *s, <span class="hljs-keyword">int</span> unused, <span class="hljs-keyword">int</span> value)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore to be initialized</li>
<li><code>unused</code> is unused (keeps API combatibility with sem_init()</li>
<li><code>value</code> sets the initial value of the semaphore</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsempost">mtev_sem_post</h4>
<blockquote>
<p>increments the value of the semaphore releasing any waiters.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_sem_post</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to wait</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsemtrywait">mtev_sem_trywait</h4>
<blockquote>
<p>decrements the value of the semaphore if greater than 0 or fails</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_sem_trywait</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to wait</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsemwait">mtev_sem_wait</h4>
<blockquote>
<p>decrements the value of the semaphore waiting if required.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_sem_wait</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to wait</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsemwaitnoeintr">mtev_sem_wait_noeintr</h4>
<blockquote>
<p>Convenience function that delegates to sem_wait, swallowing EINTR errors.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_sem_wait_noeintr</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to wait</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<p>This function is built on sem_wait, and sem_wait can fail in other ways besides
EINTR, such as due to EINVAL. These other failures will be due to mis-use of the
semaphore API -- e.g., by trying to <code>sem_wait</code> on a structure that was never
initialized with <code>sem_init</code>. Mis-using thread-synchronization primitives will
often lead to subtle, serious, and hard-to-reproduce bugs, so this function will
mtevFatal on other errors, rather than forcing clients to deal with (likely)
un-handlable errors. If your client code can handle these other errors, use
sem_wait directly, do not use this function.</p>
<h4 id="mtevsortcomparefunction">mtev_sort_compare_function</h4>
<blockquote>
<p>Function definition to compare sortable entries</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_sort_compare_function</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *left, <span class="hljs-keyword">void</span> *right)</span>
</span></code></pre>
<ul>
<li><code>left</code> one object to compare</li>
<li><code>right</code> the other object to compare</li>
<li><strong>RETURN</strong> less than zero, zero, or greater than zero if left is less than, equal, or greater than right.</li>
</ul>
<h4 id="mtevsortnextfunction">mtev_sort_next_function</h4>
<blockquote>
<p>Function definition to get the next item from current</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">mtev_sort_next_function</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *current)</span>
</span></code></pre>
<ul>
<li><code>current</code> the current node</li>
<li><strong>RETURN</strong> the item after current</li>
</ul>
<h4 id="mtevsortsetnextfunction">mtev_sort_set_next_function</h4>
<blockquote>
<p>Function definition to re-order objects</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_sort_set_next_function</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *current, <span class="hljs-keyword">void</span> *value)</span>
</span></code></pre>
<ul>
<li><code>current</code> the current node</li>
<li><code>value</code> the value that should be directly after current</li>
</ul>
<h4 id="mtevsysgethrtime">mtev_sys_gethrtime</h4>
<blockquote>
<p>Exposes the system gethrtime() or equivalent impl</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_hrtime_t</span>
mtev_sys_gethrtime(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><strong>RETURN</strong> mtev_hrtime_t the system high-res time</li>
</ul>
<h3 id="t">T</h3>
<h4 id="mtevtimefastmode">mtev_time_fast_mode</h4>
<blockquote>
<p>check to see if fast mode is enabled</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_time_fast_mode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **reason)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> true if fast mode is on, false otherwise, the reason param will contain a text description</li>
</ul>
<h4 id="mtevtimemaintain">mtev_time_maintain</h4>
<blockquote>
<p>Usually this is managed for you, but this is safe to call at any time</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_time_maintain</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> mtev_true if it was successful in parameterizing the CPU for rdtsc, mtev_false otherwise</li>
</ul>
<p>Safe to call at any time but if you start_tsc, you should never need to call this
as the maintenance system can do it for you. However, if you find you need to call it
you must be bound to a thread using the mtev_thread APIs and the function will return
whether it was successful in parameterizing the CPU for rdtsc use.</p>
<h4 id="mtevtimestarttsc">mtev_time_start_tsc</h4>
<blockquote>
<p>use TSC clock if possible for this CPU num</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_time_start_tsc</span><span class="hljs-params">()</span>
</span></code></pre>
<p>   This will remain active in the thread until you call stop</p>
<h4 id="mtevtimestoptsc">mtev_time_stop_tsc</h4>
<blockquote>
<p>Turn off TSC usage for the current cpu of this thread (from when start_tsc was called)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_time_stop_tsc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<h4 id="mtevtimetogglerequireinvarianttsc">mtev_time_toggle_require_invariant_tsc</h4>
<blockquote>
<p>will switch on/off the requirement of an invariant tsc.  This must be run before any call to mtev_time_toggle_tsc() or mtev_time_tsc_start() and is a one time call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_time_toggle_require_invariant_tsc</span><span class="hljs-params">(mtev_boolean enable)</span>
</span></code></pre>
<p>   Defaults to enabled.</p>
<h4 id="mtevtimetoggletsc">mtev_time_toggle_tsc</h4>
<blockquote>
<p>will switch on/off rdtsc usage across all cores regardless of detected state of rdtsc or start/stop usage.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_time_toggle_tsc</span><span class="hljs-params">(mtev_boolean enable)</span>
</span></code></pre>
<p>   Defaults to enabled.</p>
<p>   This is independent of start_tsc/stop_tsc.  You can disable all and then reenable and the thread
   will keep going using the state from the last start/stop_tsc</p>
<h3 id="u">U</h3>
<h4 id="mtevurldecode">mtev_url_decode</h4>
<blockquote>
<p>Decode a url encoded input buffer into the provided output buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_url_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the encoded content.</li>
<li><code>src_len</code> The size (in bytes) of the encoded data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the decoded output.  Returns zero is dest_len is too small.</li>
</ul>
<p>mtev_url_decode decodes input until an the entire input is consumed or until an invalid url-encoded character is encountered. If any error occurs, 0 is returned.</p>
<h4 id="mtevurlencode">mtev_url_encode</h4>
<blockquote>
<p>Encode raw data as url encoded output into the provided buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_url_encode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the raw data.</li>
<li><code>src_len</code> The size (in bytes) of the raw data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the encoded output.  Returns zero is out_sz is too small.</li>
</ul>
<h4 id="mtevurlencodelen">mtev_url_encode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain the url encoding for a given number of bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_url_encode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the raw data buffer that might be encoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to store an encoded version of an input string.</li>
</ul>
<h4 id="mtevurlmaxdecodelen">mtev_url_max_decode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain a decoded url-encoded string of a given length.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_url_max_decode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the url-encoded string that might be decoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to decode the input string.</li>
</ul>
<h4 id="mtevuuidclear">mtev_uuid_clear</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_uuid_clear</span><span class="hljs-params">(uuid_t uu)</span>
</span></code></pre>
<blockquote>
<p>Set a uuid to the null uuid.</p>
</blockquote>
<p> Follows the same semantics of uuid_clear from libuuid</p>
<h4 id="mtevuuidcompare">mtev_uuid_compare</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_uuid_compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uuid_t uu1, <span class="hljs-keyword">const</span> uuid_t uu2)</span>
</span></code></pre>
<blockquote>
<p>Compare to uuids</p>
</blockquote>
<ul>
<li><p><strong>RETURN</strong> 0 if equal, -1 if uu1 is less than uu2, 1 otherwise.</p>
<p>Follows the same semantics of uuid_compare from libuuid</p>
</li>
</ul>
<h4 id="mtevuuidcopy">mtev_uuid_copy</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_uuid_copy</span><span class="hljs-params">(uuid_t dst, <span class="hljs-keyword">const</span> uuid_t src)</span>
</span></code></pre>
<blockquote>
<p>Copy src to dst.</p>
</blockquote>
<p> Follows the same semantics of uuid_copy from libuuid</p>
<h4 id="mtevuuidgenerate">mtev_uuid_generate</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_uuid_generate</span><span class="hljs-params">(uuid_t uu)</span>
</span></code></pre>
<blockquote>
<p>Generate a V4 uuid.</p>
</blockquote>
<p> Follows the same semantics of uuid_generate from libuuid</p>
<h4 id="mtevuuidisnull">mtev_uuid_is_null</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_uuid_is_null</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uuid_t uu)</span>
</span></code></pre>
<blockquote>
<p>Determine if the supplied uuid is the null uuid.</p>
</blockquote>
<ul>
<li><p><strong>RETURN</strong> 0 if not null, 1 if null.</p>
<p>Follows the same semantics of uuid_is_null from libuuid</p>
</li>
</ul>
<h4 id="mtevuuidparse">mtev_uuid_parse</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_uuid_parse</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in, uuid_t uu)</span>
</span></code></pre>
<blockquote>
<p>Parse &quot;in&quot; in UUID format into &quot;uu&quot;.</p>
</blockquote>
<ul>
<li><p><strong>RETURN</strong> 0 on success, non-zero on parse error</p>
<p>Follows the same semantics of uuid_parse from libuuid</p>
</li>
</ul>
<h4 id="mtevuuidunparse">mtev_uuid_unparse</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_uuid_unparse</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uuid_t uu, <span class="hljs-keyword">char</span> *out)</span>
</span></code></pre>
<blockquote>
<p>Unparse &quot;uu&quot; into &quot;out&quot;.</p>
</blockquote>
<p>  Follows the same semantics of uuid_unparse_lower from libuuid.</p>
<p>  There is no bounds checking of &quot;out&quot;, caller must ensure that &quot;out&quot;
  is at least UUID_STR_LEN in size.  This also does not NULL terminate
  &quot;out&quot;.  That is also up to the caller.</p>
<h4 id="mtevuuidunparselower">mtev_uuid_unparse_lower</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_uuid_unparse_lower</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uuid_t uu, <span class="hljs-keyword">char</span> *out)</span>
</span></code></pre>
<blockquote>
<p>Unparse &quot;uu&quot; into &quot;out&quot;.</p>
</blockquote>
<p>  Follows the same semantics of uuid_unparse_lower from libuuid.</p>
<p>  There is no bounds checking of &quot;out&quot;, caller must ensure that &quot;out&quot;
  is at least UUID_STR_LEN in size.  This also does not NULL terminate
  &quot;out&quot;.  That is also up to the caller.</p>
<h4 id="mtevuuidunparseupper">mtev_uuid_unparse_upper</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_uuid_unparse_upper</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uuid_t uu, <span class="hljs-keyword">char</span> *out)</span>
</span></code></pre>
<blockquote>
<p>Unparse &quot;uu&quot; into &quot;out&quot;.</p>
</blockquote>
<p>  Follows the same semantics of uuid_unparse_upper from libuuid.</p>
<p>  There is no bounds checking of &quot;out&quot;, caller must ensure that &quot;out&quot;
  is at least UUID_STR_LEN in size.  This also does not NULL terminate
  &quot;out&quot;.  That is also up to the caller.</p>
<h3 id="v">V</h3>
<h4 id="mtevvlog">mtev_vlog</h4>
<blockquote>
<p>Log to a log stream (metadata, <code>va_list</code>)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_vlog</span><span class="hljs-params">(mtev_log_stream_t ls, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">int</span> line,
          <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span>
</span></code></pre>
<ul>
<li><code>ls</code> a log stream</li>
<li><code>now</code> the current time</li>
<li><code>file</code> a source file name</li>
<li><code>line</code> a source file line number</li>
<li><code>format</code> a <code>printf</code>-style format string</li>
<li><code>arg</code> a <code>varargs</code> list</li>
<li><strong>RETURN</strong> The number of bytes written or an approximation</li>
</ul>
<p>See mtev_ex_log.</p>
<h3 id="w">W</h3>
<h4 id="mtevwatchdogchildeventerheartbeat">mtev_watchdog_child_eventer_heartbeat</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_watchdog_child_eventer_heartbeat</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> Returns zero on success</li>
</ul>
<p>mtev_watchdog_child_eventer_heartbeat registers a periodic heartbeat through the eventer subsystem.  The eventer must be initialized before calling this function.</p>
<h4 id="mtevwatchdogchildheartbeat">mtev_watchdog_child_heartbeat</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_watchdog_child_heartbeat</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> Returns zero on success</li>
</ul>
<p>mtev_watchdog_child_heartbeat is called within the child function to alert the parent that the child is still alive and functioning correctly.</p>
<h4 id="mtevwatchdogcreate">mtev_watchdog_create</h4>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_watchdog_t</span> *
mtev_watchdog_create()
</code></pre>
<ul>
<li><strong>RETURN</strong> a new heartbeat identifier (or null, if none could be allocated)</li>
</ul>
<p>mtev_watchdog_create creates a new heartbeat that must be assessed for liveliness by the parent.</p>
<h4 id="mtevwatchdogdisable">mtev_watchdog_disable</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_watchdog_disable</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart on which to act</li>
</ul>
<p>mtev_watchdog_disable will make the parent ignore failed heartbeats.</p>
<h4 id="mtevwatchdogdisableasynchcoredump">mtev_watchdog_disable_asynch_core_dump</h4>
<blockquote>
<p>Disable asynchronous core dumps.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_watchdog_disable_asynch_core_dump</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<p>Disable starting a new child while a faulting prior child is still dumping.  This must be called
before <code>mtev_main</code> and will be overridden by the MTEV_ASYNCH_CORE_DUMP environment variable.</p>
<h4 id="mtevwatchdogenable">mtev_watchdog_enable</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_watchdog_enable</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart on which to act</li>
</ul>
<p>mtev_watchdog_enable will make the parent respect and act on failed heartbeats.</p>
<h4 id="mtevwatchdoggetname">mtev_watchdog_get_name</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">mtev_watchdog_get_name</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart from which to retrieve a name</li>
<li><strong>RETURN</strong> the name of the heart (or NULL)</li>
</ul>
<h4 id="mtevwatchdoggettimeout">mtev_watchdog_get_timeout</h4>
<blockquote>
<p>returns the timeout configured for this watchdog.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">double</span>
<span class="hljs-title">mtev_watchdog_get_timeout</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart on which to act</li>
<li><strong>RETURN</strong> A timeout in seconds, 0 if hb is NULL.</li>
</ul>
<h4 id="mtevwatchdoggettimeouttimeval">mtev_watchdog_get_timeout_timeval</h4>
<blockquote>
<p>returns the timeout configured for this watchdog.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">struct</span> timeval
<span class="hljs-title">mtev_watchdog_get_timeout_timeval</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart on which to act</li>
<li><code>dur</code> a struct timeval to populate with the timeout</li>
<li><strong>RETURN</strong> mtev_true if there is a watchog, mtev_false if not.</li>
</ul>
<h4 id="mtevwatchdogglider">mtev_watchdog_glider</h4>
<blockquote>
<p>Sets a glider command.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_watchdog_glider</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span>
</span></code></pre>
<ul>
<li><code>path</code> the full path to the executable.</li>
<li><strong>RETURN</strong> 0 on success, non-zero on failure.</li>
</ul>
<p><code>path</code> is invoked with two parameters, the process id of the faulting child, and the reason for the fault (one of <code>crash</code>, <code>watchdog</code>, or <code>unknown</code>.</p>
<h4 id="mtevwatchdogglidertracedir">mtev_watchdog_glider_trace_dir</h4>
<blockquote>
<p>Set the directory to store glider output.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_watchdog_glider_trace_dir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span>
</span></code></pre>
<ul>
<li><code>path</code> a full path to a directory.</li>
<li><strong>RETURN</strong> 0 on success, non-zero on failure.</li>
</ul>
<h4 id="mtevwatchdogheartbeat">mtev_watchdog_heartbeat</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_watchdog_heartbeat</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> is the heart on which to pulse.  If null, the default heart is used.</li>
<li><strong>RETURN</strong> Returns zero on success</li>
</ul>
<p>mtev_watchdog_heartbeat will pulse on the specified heart.</p>
<h4 id="mtevwatchdogmanage">mtev_watchdog_manage</h4>
<blockquote>
<p>Ask the watchdog to manage a child process</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_watchdog_manage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp, mtev_log_stream_t out
                     mtev_log_stream_t err)</span>
</span></code></pre>
<ul>
<li><code>file</code> The process executable</li>
<li><code>argv</code> The arguments to the process</li>
<li><code>envp</code> The environment of the process</li>
<li><code>user</code> The user (if not NULL) to setuid to.</li>
<li><code>group</code> The user (if not NULL) to setgid to.</li>
<li><code>dir</code> The directory (if not NULL) to chdir to.</li>
<li><code>out</code> A log stream for capturing stdout</li>
<li><code>err</code> A log stream for capturing stderr</li>
</ul>
<p>An auto-restarting execve(...)</p>
<h4 id="mtevwatchdognumberofstarts">mtev_watchdog_number_of_starts</h4>
<blockquote>
<p>Determine the number of times a child has been lauched.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint32_t</span>
mtev_watchdog_number_of_starts(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><strong>RETURN</strong> The number of times fork has returned in the parent.  In a running server, 0 means you&apos;re the first generation.</li>
</ul>
<h4 id="mtevwatchdogoverridetimeout">mtev_watchdog_override_timeout</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_watchdog_override_timeout</span><span class="hljs-params">(mtev_watchdog_t *hb, <span class="hljs-keyword">double</span> timeout)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart on which to act</li>
<li><code>timeout</code> the timeout in seconds for this heart (0 for default)</li>
</ul>
<p>mtev_watchdog_override_timeout will allow the caller to override the timeout
for a specific heart in the system.</p>
<h4 id="mtevwatchdogpreforkinit">mtev_watchdog_prefork_init</h4>
<blockquote>
<p>Prepare the program to split into a child/parent-monitor relationship.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">mtev_watchdog_prefork_init</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> Returns zero on success.</li>
</ul>
<p>mtev_watchdog_prefork_init sets up the necessary plumbing to bridge across a
child to instrument watchdogs.</p>
<h4 id="mtevwatchdogratelimit">mtev_watchdog_ratelimit</h4>
<blockquote>
<p>Set rate limiting for child restarting.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_watchdog_ratelimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> retry_val, <span class="hljs-keyword">int</span> span_val)</span>
</span></code></pre>
<ul>
<li><code>retry_val</code> the number of times to retry in the given <code>span_val</code></li>
<li><code>span_val</code> the number of seconds over which to attempt retries.</li>
</ul>
<h4 id="mtevwatchdogrecurrentheartbeat">mtev_watchdog_recurrent_heartbeat</h4>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span>
mtev_watchdog_recurrent_heartbeat(<span class="hljs-keyword">mtev_watchdog_t</span> *hb)
</code></pre>
<ul>
<li><code>hb</code> is the heart on which to beat.</li>
<li><strong>RETURN</strong> Returns and event that the caller must schedule.</li>
</ul>
<p>mtev_watchdog_recurrent_heartbeat creates a recurrent eventer_t to beat a heart.</p>
<h4 id="mtevwatchdogsetname">mtev_watchdog_set_name</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_watchdog_set_name</span><span class="hljs-params">(mtev_watchdog_t *hb, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart to name</li>
<li><code>name</code> a new name for this heart</li>
</ul>
<h4 id="mtevwatchdogstartchild">mtev_watchdog_start_child</h4>
<blockquote>
<p>Starts a function as a separate child under close watch.</p>
</blockquote>
<pre><code class="lang-c">int
mtev_watchdog_start_child(const char *app, int (*func)(), int child_watchdog_timeout)
</code></pre>
<ul>
<li><code>app</code> The name of the application (for error output).</li>
<li><code>func</code> The function that will be the child process.</li>
<li><code>child_watchdog_timeout</code> The number of seconds of lifelessness before the parent reaps and restarts the child.</li>
<li><strong>RETURN</strong> Returns on program termination.</li>
</ul>
<p>mtev_watchdog_start_child will fork and run the specified function in the child process.  The parent will watch.  The child process must initialize the eventer system and then call mtev_watchdog_child_hearbeat to let the parent know it is alive.  If the eventer system is being used to drive the child process, mtev_watchdog_child_eventer_heartbeat may be called once after the eventer is initalized.  This will induce a regular heartbeat.</p>
<h4 id="mtevwebsocketclientfree">mtev_websocket_client_free</h4>
<blockquote>
<p>Free a client</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_websocket_client_free</span><span class="hljs-params">(mtev_websocket_client_t *client)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to be freed</li>
</ul>
<p>This function will cleanup the client(and hence trigger any set cleanup_callback) first.
This function does nothing if called with NULL.</p>
<h4 id="mtevwebsocketclientgetclosure">mtev_websocket_client_get_closure</h4>
<blockquote>
<p>Access the currently set closure, if any</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">mtev_websocket_client_get_closure</span><span class="hljs-params">(mtev_websocket_client_t *client)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to be accessed</li>
<li><strong>RETURN</strong> most recently set closure, or NULL if never set</li>
</ul>
<h4 id="mtevwebsocketclientinitlogs">mtev_websocket_client_init_logs</h4>
<blockquote>
<p>Enable debug logging to &quot;debug/websocket_client&quot;</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_websocket_client_init_logs</span><span class="hljs-params">()</span>
</span></code></pre>
<p>Error logging is always active to &quot;error/websocket_client&quot;.</p>
<h4 id="mtevwebsocketclientisclosed">mtev_websocket_client_is_closed</h4>
<blockquote>
<p>Check if a client has closed and can no longer send or receive</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_websocket_client_is_closed</span><span class="hljs-params">(mtev_websocket_client_t *client)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to be checked</li>
<li><strong>RETURN</strong> boolean indicating whether the client is closed</li>
</ul>
<p>Only a return value of mtev_true can be trusted(once closed, a client
cannot re-open). Because the caller is unable to check this status inside
of a locked section, it is possible that the client closes and invalidates
the result of this function call before the caller can act on it.</p>
<h4 id="mtevwebsocketclientisready">mtev_websocket_client_is_ready</h4>
<blockquote>
<p>Check if a client has completed its handshake and is ready to send messages</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_websocket_client_is_ready</span><span class="hljs-params">(mtev_websocket_client_t *client)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to be checked</li>
<li><strong>RETURN</strong> boolean indicating whether the client is ready</li>
</ul>
<p>This function will continue to return true after the client has closed.</p>
<h4 id="mtevwebsocketclientnew">mtev_websocket_client_new</h4>
<blockquote>
<p>Construct a new websocket client</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_websocket_client_t</span> *
mtev_websocket_client_new(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service,
                          mtev_websocket_client_callbacks *callbacks, <span class="hljs-keyword">void</span> *closure,
                          <span class="hljs-keyword">eventer_pool_t</span> *pool, mtev_hash_table *sslconfig)
</code></pre>
<ul>
<li><code>host</code> required, host to connect to(ipv4 or ipv6 address)</li>
<li><code>port</code> required, port to connect to on host</li>
<li><code>path</code> required, path portion of URI</li>
<li><code>service</code> required, protocol to connect with</li>
<li><code>callbacks</code> required, struct containing a msg_callback and optionally ready_callback and cleanup_callback</li>
<li><code>closure</code> optional, an opaque pointer that is passed through to the callbacks</li>
<li><code>pool</code> optional, specify an eventer pool; thread will be chosen at random from the pool</li>
<li><code>sslconfig</code> optional, enables SSL using the contained config</li>
<li><strong>RETURN</strong> a newly constructed mtev_websocket_client_t on success, NULL on failure</li>
</ul>
<p>ready_callback will be called immediately upon successful completion of the websocket handshake.
msg_callback is called with the complete contents of each non-control frame received.
cleanup_callback is called as the last step of cleaning up the client, after the connection has been torn down.
A client returned from this constructor must be freed with <code>mtev_websocket_client_free</code>.</p>
<h4 id="mtevwebsocketclientnewnoref">mtev_websocket_client_new_noref</h4>
<blockquote>
<p>Construct a new websocket client that will be freed automatically after cleanup</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_websocket_client_new_noref</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service,
                                mtev_websocket_client_callbacks *callbacks, <span class="hljs-keyword">void</span> *closure,
                                eventer_pool_t *pool, mtev_hash_table *sslconfig)</span>
</span></code></pre>
<ul>
<li><code>host</code> required, host to connect to(ipv4 or ipv6 address)</li>
<li><code>port</code> required, port to connect to on host</li>
<li><code>path</code> required, path portion of URI</li>
<li><code>service</code> required, protocol to connect with</li>
<li><code>callbacks</code> required, struct containing a msg_callback and optionally ready_callback and cleanup_callback</li>
<li><code>closure</code> optional, an opaque pointer that is passed through to the callbacks</li>
<li><code>pool</code> optional, specify an eventer pool; thread will be chosen at random from the pool</li>
<li><code>sslconfig</code> optional, enables SSL using the contained config</li>
<li><strong>RETURN</strong> boolean indicating success/failure</li>
</ul>
<p>Clients allocated by this function are expected to be interacted with solely through the provided callbacks. There are two guarantees the caller must make:</p>
<ol>
<li>The caller must not let a reference to the client escape from the provided callbacks.</li>
<li>The caller must not call <code>mtev_websocket_client_free()</code> with a reference to this client.</li>
</ol>
<h4 id="mtevwebsocketclientsend">mtev_websocket_client_send</h4>
<blockquote>
<p>Enqueue a message</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean
<span class="hljs-title">mtev_websocket_client_send</span><span class="hljs-params">(mtev_websocket_client_t *client, <span class="hljs-keyword">int</span> opcode, <span class="hljs-keyword">void</span> *buf, size_t len)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to send message over</li>
<li><code>opcode</code> opcode as defined in RFC 6455 and referenced in wslay.h</li>
<li><code>buf</code> pointer to buffer containing data to send</li>
<li><code>len</code> number of bytes of buf to send</li>
<li><strong>RETURN</strong> boolean indicating success/failure</li>
</ul>
<p>This function makes a copy of buf of length len.
This function may fail for the following reasons:</p>
<ol>
<li>The client was not ready. See mtev_websocket_client_is_ready.</li>
<li>The client was already closed. See mtev_websocket_client_is_closed.</li>
<li>Out of memory.</li>
</ol>
<h4 id="mtevwebsocketclientsetcleanupcallback">mtev_websocket_client_set_cleanup_callback</h4>
<blockquote>
<p>Set a new cleanup_callback on an existing client</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_websocket_client_set_cleanup_callback</span><span class="hljs-params">(mtev_websocket_client_t *client
                                           mtev_websocket_client_cleanup_callback cleanup_callback)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to modify</li>
<li><code>cleanup_callback</code> new cleanup_callback to set</li>
</ul>
<h4 id="mtevwebsocketclientsetclosure">mtev_websocket_client_set_closure</h4>
<blockquote>
<p>Set a new closure</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_websocket_client_set_closure</span><span class="hljs-params">(mtev_websocket_client_t *client, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to be modified</li>
<li><code>closure</code> closure to be set</li>
</ul>
<p>If closure is NULL, this has the effect of removing a previously set closure.</p>
<h4 id="mtevwebsocketclientsetmsgcallback">mtev_websocket_client_set_msg_callback</h4>
<blockquote>
<p>Set a new msg_callback on an existing client</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_websocket_client_set_msg_callback</span><span class="hljs-params">(mtev_websocket_client_t *client
                                       mtev_websocket_client_msg_callback msg_callback)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to modify</li>
<li><code>msg_callback</code> new msg_callback to set</li>
</ul>
<h4 id="mtevwebsocketclientsetreadycallback">mtev_websocket_client_set_ready_callback</h4>
<blockquote>
<p>Set a new ready_callback on an existing client</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_websocket_client_set_ready_callback</span><span class="hljs-params">(mtev_websocket_client_t *client
                                         mtev_websocket_client_ready_callback ready_callback)</span>
</span></code></pre>
<ul>
<li><code>client</code> client to modify</li>
<li><code>ready_callback</code> new ready_callback to set</li>
</ul>
<h3 id="z">Z</h3>
<h4 id="mtevzipkinacoswapspan">mtev_zipkin_aco_swap_span</h4>
<blockquote>
<p>Swap an existing ACO&apos;s span for a new one, returning old</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_Span *
<span class="hljs-title">mtev_zipkin_aco_swap_span</span><span class="hljs-params">(Zipkin_Span *span)</span>
</span></code></pre>
<ul>
<li><code>span</code> The new span</li>
<li><strong>RETURN</strong> The old span</li>
</ul>
<h4 id="mtevzipkinactivespan">mtev_zipkin_active_span</h4>
<blockquote>
<p>Find the currently active span of work.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_Span *
<span class="hljs-title">mtev_zipkin_active_span</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
<li><strong>RETURN</strong> A span or NULL if no span is currently active.</li>
</ul>
<h4 id="mtevzipkinannotationsetendpoint">mtev_zipkin_annotation_set_endpoint</h4>
<blockquote>
<p>Sets the endpoint for an annotation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_annotation_set_endpoint</span><span class="hljs-params">(Zipkin_Annotation *annotation, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name,
                                    <span class="hljs-keyword">bool</span> service_name_copy, <span class="hljs-keyword">struct</span> in_addr host, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port)</span>
</span></code></pre>
<ul>
<li><code>annotation</code> The annotation to update.</li>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
<li><code>host</code> The IPv4 host address of theservice.</li>
<li><code>port</code> The IP port of the service.</li>
</ul>
<p>mtev_zipkin_annotation_set_endpoint sets an endpoint for the provided annotation.</p>
<h4 id="mtevzipkinattachnamedtoaco">mtev_zipkin_attach_named_to_aco</h4>
<blockquote>
<p>Attach a new child span to an aco thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_attach_named_to_aco</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *child_name
                                mtev_zipkin_event_trace_level_t *track)</span>
</span></code></pre>
<ul>
<li><code>span</code> An existing zipkin span.</li>
<li><code>child_name</code> The name of the new child span.</li>
<li><code>track</code> Specifies how event activity should be tracked.</li>
</ul>
<h4 id="mtevzipkinattachtoaco">mtev_zipkin_attach_to_aco</h4>
<blockquote>
<p>Attach an active span (or new child span) to an aco thread.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_attach_to_aco</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">bool</span> new_child, mtev_zipkin_event_trace_level_t *track)</span>
</span></code></pre>
<ul>
<li><code>span</code> An existing zipkin span.</li>
<li><code>new_child</code> Whether or not a child should be created under the provided span.</li>
<li><code>track</code> Specifies how event activity should be tracked.</li>
</ul>
<h4 id="mtevzipkinattachtoeventer">mtev_zipkin_attach_to_eventer</h4>
<blockquote>
<p>Attach an active span (or new child span) to an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_attach_to_eventer</span><span class="hljs-params">(eventer_t e, Zipkin_Span *span, <span class="hljs-keyword">bool</span> new_child
                              mtev_zipkin_event_trace_level_t *track)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
<li><code>span</code> An existing zipkin span.</li>
<li><code>new_child</code> Whether or not a child should be created under the provided span.</li>
<li><code>track</code> Specifies how event activity should be tracked.</li>
</ul>
<h4 id="mtevzipkinbannotationsetendpoint">mtev_zipkin_bannotation_set_endpoint</h4>
<blockquote>
<p>Sets the endpoint for an annotation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_bannotation_set_endpoint</span><span class="hljs-params">(Zipkin_BinaryAnnotation *annotation, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name,
                                     <span class="hljs-keyword">bool</span> service_name_copy, <span class="hljs-keyword">struct</span> in_addr host, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port)</span>
</span></code></pre>
<ul>
<li><code>annotation</code> The annotation to update.</li>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
<li><code>host</code> The IPv4 host address of theservice.</li>
<li><code>port</code> The IP port of the service.</li>
</ul>
<p>mtev_zipkin_bannotation_set_endpoint sets an endpoint for the provided annotation.</p>
<h4 id="mtevzipkinclientdrop">mtev_zipkin_client_drop</h4>
<blockquote>
<p>Discard a client span if one exists.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_client_drop</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
</ul>
<h4 id="mtevzipkinclientnew">mtev_zipkin_client_new</h4>
<blockquote>
<p>Create a new span for client user (remote calling)</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_client_new</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">bool</span> name_copy)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
<li><code>name</code> A string to name the span</li>
<li><code>name_copy</code> Whether name should be allocated (copied) within the span.</li>
</ul>
<h4 id="mtevzipkinclientparenthdr">mtev_zipkin_client_parent_hdr</h4>
<blockquote>
<p>Format a parent span HTTP header for an HTTP request.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">bool</span>
<span class="hljs-title">mtev_zipkin_client_parent_hdr</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">char</span> *buf, size_t len)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
<li><code>buf</code> An output buffer for &quot;Header: Value&quot;</li>
<li><code>len</code> The available space in <code>buf</code></li>
<li><strong>RETURN</strong> True if successful, false if no trace is available of len is too short.</li>
</ul>
<h4 id="mtevzipkinclientpublish">mtev_zipkin_client_publish</h4>
<blockquote>
<p>Publish a client span if one exists.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_client_publish</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
</ul>
<h4 id="mtevzipkinclientsampledhdr">mtev_zipkin_client_sampled_hdr</h4>
<blockquote>
<p>Format a sampled HTTP header for an HTTP request.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">bool</span>
<span class="hljs-title">mtev_zipkin_client_sampled_hdr</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">char</span> *buf, size_t len)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
<li><code>buf</code> An output buffer for &quot;Header: Value&quot;</li>
<li><code>len</code> The available space in <code>buf</code></li>
<li><strong>RETURN</strong> True if successful, false if no trace is available of len is too short.</li>
</ul>
<h4 id="mtevzipkinclientspan">mtev_zipkin_client_span</h4>
<blockquote>
<p>Retrieve the current client span should one exist.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_Span *
<span class="hljs-title">mtev_zipkin_client_span</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
<li><strong>RETURN</strong> A span for client actions or NULL is no span exists.</li>
</ul>
<h4 id="mtevzipkinclientspanhdr">mtev_zipkin_client_span_hdr</h4>
<blockquote>
<p>Format a span HTTP header for an HTTP request.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">bool</span>
<span class="hljs-title">mtev_zipkin_client_span_hdr</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">char</span> *buf, size_t len)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
<li><code>buf</code> An output buffer for &quot;Header: Value&quot;</li>
<li><code>len</code> The available space in <code>buf</code></li>
<li><strong>RETURN</strong> True if successful, false if no trace is available of len is too short.</li>
</ul>
<h4 id="mtevzipkinclienttracehdr">mtev_zipkin_client_trace_hdr</h4>
<blockquote>
<p>Format a trace HTTP header for an HTTP request.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">bool</span>
<span class="hljs-title">mtev_zipkin_client_trace_hdr</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">char</span> *buf, size_t len)</span>
</span></code></pre>
<ul>
<li><code>e</code> An event object (or NULL for the current event)</li>
<li><code>buf</code> An output buffer for &quot;Header: Value&quot;</li>
<li><code>len</code> The available space in <code>buf</code></li>
<li><strong>RETURN</strong> True if successful, false if no trace is available of len is too short.</li>
</ul>
<h4 id="mtevzipkindefaultendpoint">mtev_zipkin_default_endpoint</h4>
<blockquote>
<p>Sets the default endpoint used for new spans.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_default_endpoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name, <span class="hljs-keyword">bool</span> service_name_copy, <span class="hljs-keyword">struct</span> in_addr host
                             <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port)</span>
</span></code></pre>
<ul>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
<li><code>host</code> The IPv4 host address of theservice.</li>
<li><code>port</code> The IP port of the service.</li>
</ul>
<p>mtev_zipkin_default_endpoint sets a default endpoint for any new spans created without their own default.  Use this with care, it is application global.  You should likely only call this once at startup.</p>
<h4 id="mtevzipkindefaultservicename">mtev_zipkin_default_service_name</h4>
<blockquote>
<p>Sets the default service name used for new spans.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_default_service_name</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name, <span class="hljs-keyword">bool</span> service_name_copy)</span>
</span></code></pre>
<ul>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
</ul>
<p>mtev_zipkin_default_service_name sets a default service name for endpoints for any new spans created without their own default.  Use this with care, it is application global.  You should likely only call this once at startup.</p>
<h4 id="mtevzipkinencode">mtev_zipkin_encode</h4>
<blockquote>
<p>Encode a span into the specified buffer for Zipkin.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_zipkin_encode(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *buffer, <span class="hljs-keyword">size_t</span> len, Zipkin_Span *span)
</code></pre>
<ul>
<li><code>buffer</code> The target buffer.</li>
<li><code>len</code> The target buffer&apos;s size.</li>
<li><code>span</code> The span to encode.</li>
<li><strong>RETURN</strong> The length of a successful encoding.</li>
</ul>
<p>mtev_zipkin_encode will take a span and encode it for Zipkin using the Thift BinaryProtocol.  The return value is always the length of a successful encoding, even if the buffer supplied is too small.  The caller must check the the returned length is less than or equal to the provided length to determine whether the encoding was successful.  The caller may provide a NULL buffer if and only if the provided len is 0.</p>
<h4 id="mtevzipkinencodelist">mtev_zipkin_encode_list</h4>
<blockquote>
<p>Encode a span into the specified buffer for Zipkin.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span>
mtev_zipkin_encode_list(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *buffer, <span class="hljs-keyword">size_t</span> len, Zipkin_Span **spans, <span class="hljs-keyword">int</span> cnt)
</code></pre>
<ul>
<li><code>buffer</code> The target buffer.</li>
<li><code>len</code> The target buffer&apos;s size.</li>
<li><code>spans</code> The array of spans to encode.</li>
<li><code>cnt</code> The number of spans in <code>spans</code>.</li>
<li><strong>RETURN</strong> The length of a successful encoding.</li>
</ul>
<p>mtev_zipkin_encode_list will take a list of spans and encode it for Zipkin using the Thift BinaryProtocol.  The return value is always the length of a successful encoding, even if the buffer supplied is too small.  The caller must check the the returned length is less than or equal to the provided length to determine whether the encoding was successful.  The caller may provide a NULL buffer if and only if the provided len is 0.</p>
<h4 id="mtevzipkineventtracelevel">mtev_zipkin_event_trace_level</h4>
<blockquote>
<p>Globally set the default event trace level.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_event_trace_level</span><span class="hljs-params">(mtev_zipkin_event_trace_level_t level)</span>
</span></code></pre>
<ul>
<li><code>level</code> The new global default level for event tracing.</li>
</ul>
<h4 id="mtevzipkineventerinit">mtev_zipkin_eventer_init</h4>
<blockquote>
<p>Initialize zipkin contexts for the eventer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_eventer_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<h4 id="mtevzipkingetsampling">mtev_zipkin_get_sampling</h4>
<blockquote>
<p>Get sampling probabilities for different types of traces.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_get_sampling</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *new_traces, <span class="hljs-keyword">double</span> *parented_traces, <span class="hljs-keyword">double</span> *debug_traces)</span>
</span></code></pre>
<ul>
<li><code>new_traces</code> probability pointer to populate</li>
<li><code>parented_traces</code> probability pointer to populate</li>
<li><code>debug_traces</code> probability pointer to populate</li>
</ul>
<p>mtev_zipkin_get_sampling gets sampling probabilities for creating new traces.  See <code>mtev_zipkin_sampling</code> and the opentracing specification for more details on what each probability means.</p>
<h4 id="mtevzipkinnewchild">mtev_zipkin_new_child</h4>
<blockquote>
<p>Create a new child span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_Span *
<span class="hljs-title">mtev_zipkin_new_child</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span>
</span></code></pre>
<ul>
<li><code>span</code> The parent</li>
<li><code>name</code> The name of the new span</li>
<li><strong>RETURN</strong> A new span</li>
</ul>
<h4 id="mtevzipkinsampling">mtev_zipkin_sampling</h4>
<blockquote>
<p>Set sampling probabilities for different types of traces.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_sampling</span><span class="hljs-params">(<span class="hljs-keyword">double</span> new_traces, <span class="hljs-keyword">double</span> parented_traces, <span class="hljs-keyword">double</span> debug_traces)</span>
</span></code></pre>
<ul>
<li><code>new_traces</code> probability of createing a new trace (trace_id == NULL)</li>
<li><code>parented_traces</code> probability of createing a parented trace (parent_span_id == NULL)</li>
<li><code>debug_traces</code> probability of createing a debug trace (debug != NULL &amp;&amp; *debug)</li>
</ul>
<p>mtev_zipkin_sampling sets sampling probabilities for creating new traces. Default values are 1.0</p>
<h4 id="mtevzipkinspanannotate">mtev_zipkin_span_annotate</h4>
<blockquote>
<p>Annotate a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_Annotation *
<span class="hljs-title">mtev_zipkin_span_annotate</span><span class="hljs-params">(Zipkin_Span *span, int64_t *timestamp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *value, <span class="hljs-keyword">bool</span> value_copy)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to annotate.</li>
<li><code>timestamp</code> A pointer the number of microseconds since epoch. NULL means now.</li>
<li><code>value</code> The annotation value itself.</li>
<li><code>value_copy</code> Whether value should be allocated (copied) within the span.</li>
<li><strong>RETURN</strong> A new annotation.</li>
</ul>
<p>mtev_zipkin_span_annotate make an annotation on the provided span.  The returned resource is managed by the span and will be released with it.</p>
<h4 id="mtevzipkinspanattachlogs">mtev_zipkin_span_attach_logs</h4>
<blockquote>
<p>Enable mtev_log appending if span is active.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_span_attach_logs</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">bool</span> on)</span>
</span></code></pre>
<ul>
<li><code>span</code> A zipkin span (NULL allowed)</li>
<li><code>on</code> Wether to enable or disable log appending.</li>
</ul>
<h4 id="mtevzipkinspanbannotate">mtev_zipkin_span_bannotate</h4>
<blockquote>
<p>Annotate a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_BinaryAnnotation *
<span class="hljs-title">mtev_zipkin_span_bannotate</span><span class="hljs-params">(Zipkin_Span *span, Zipkin_AnnotationType annotation_type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key,
                           <span class="hljs-keyword">bool</span> key_copy, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *value, int32_t value_len, <span class="hljs-keyword">bool</span> value_copy)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to annotate.</li>
<li><code>annotation_type</code> The type of the value being passed in.</li>
<li><code>key</code> The key for the annotation</li>
<li><code>key_copy</code> Whether key should be allocated (copied) within the span.</li>
<li><code>value</code> The pointer to a value for the annotation.</li>
<li><code>value_len</code> The length (in memory) of the binary value.</li>
<li><code>value_copy</code> Whether value should be allocated (copied) within the span.</li>
<li><strong>RETURN</strong> A new binary annotation.</li>
</ul>
<p>mtev_zipkin_span_bannotate make a binary annotation on the provided span.  The returned resource is managed by the span and will be released with it.</p>
<h4 id="mtevzipkinspanbannotatedouble">mtev_zipkin_span_bannotate_double</h4>
<blockquote>
<p>Annotate a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_BinaryAnnotation *
<span class="hljs-title">mtev_zipkin_span_bannotate_double</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">bool</span> key_copy, <span class="hljs-keyword">double</span> value)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to annotate.</li>
<li><code>annotation_type</code> The type of the value being passed in.</li>
<li><code>key</code> The key for the annotation</li>
<li><code>key_copy</code> Whether key should be allocated (copied) within the span.</li>
<li><code>value</code> The value for the annotation.</li>
<li><strong>RETURN</strong> A new binary annotation.</li>
</ul>
<h4 id="mtevzipkinspanbannotatei32">mtev_zipkin_span_bannotate_i32</h4>
<blockquote>
<p>Annotate a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_BinaryAnnotation *
<span class="hljs-title">mtev_zipkin_span_bannotate_i32</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">bool</span> key_copy, int32_t value)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to annotate.</li>
<li><code>annotation_type</code> The type of the value being passed in.</li>
<li><code>key</code> The key for the annotation</li>
<li><code>key_copy</code> Whether key should be allocated (copied) within the span.</li>
<li><code>value</code> The value for the annotation.</li>
<li><strong>RETURN</strong> A new binary annotation.</li>
</ul>
<h4 id="mtevzipkinspanbannotatei64">mtev_zipkin_span_bannotate_i64</h4>
<blockquote>
<p>Annotate a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_BinaryAnnotation *
<span class="hljs-title">mtev_zipkin_span_bannotate_i64</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">bool</span> key_copy, int64_t value)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to annotate.</li>
<li><code>annotation_type</code> The type of the value being passed in.</li>
<li><code>key</code> The key for the annotation</li>
<li><code>key_copy</code> Whether key should be allocated (copied) within the span.</li>
<li><code>value</code> The value for the annotation.</li>
<li><strong>RETURN</strong> A new binary annotation.</li>
</ul>
<h4 id="mtevzipkinspanbannotatestr">mtev_zipkin_span_bannotate_str</h4>
<blockquote>
<p>Annotate a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_BinaryAnnotation *
<span class="hljs-title">mtev_zipkin_span_bannotate_str</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">bool</span> key_copy, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *value
                               <span class="hljs-keyword">bool</span> value_copy)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to annotate.</li>
<li><code>annotation_type</code> The type of the value being passed in.</li>
<li><code>key</code> The key for the annotation</li>
<li><code>key_copy</code> Whether key should be allocated (copied) within the span.</li>
<li><code>value</code> The value for the annotation.</li>
<li><code>value_copy</code> Whether value should be allocated (copied) within the span.</li>
<li><strong>RETURN</strong> A new binary annotation.</li>
</ul>
<h4 id="mtevzipkinspandefaultendpoint">mtev_zipkin_span_default_endpoint</h4>
<blockquote>
<p>Sets the default endpoint used for new annotations within the span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_span_default_endpoint</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name, <span class="hljs-keyword">bool</span> service_name_copy,
                                  <span class="hljs-keyword">struct</span> in_addr host, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to update.</li>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
<li><code>host</code> The IPv4 host address of theservice.</li>
<li><code>port</code> The IP port of the service.</li>
</ul>
<p>mtev_zipkin_span_default_endpoint sets a default endpoint for any annotations or binary_annotations added to the span.  All annotations added without an endpoint will use the last default set on the span.</p>
<h4 id="mtevzipkinspandrop">mtev_zipkin_span_drop</h4>
<blockquote>
<p>Release resources allociated with span without publishing.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_span_drop</span><span class="hljs-params">(Zipkin_Span *span)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to release.</li>
</ul>
<p>mtev_zipkin_span_drop releases all resources associated with the span.</p>
<h4 id="mtevzipkinspangetids">mtev_zipkin_span_get_ids</h4>
<blockquote>
<p>Fetch the various IDs from a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">bool</span>
<span class="hljs-title">mtev_zipkin_span_get_ids</span><span class="hljs-params">(Zipkin_Span *span, int64_t *traceid, int64_t *parent_id, int64_t *id)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span on which to operate.</li>
<li><code>traceid</code> A pointer to a trace id to populate.</li>
<li><code>parent_id</code> A pointer to a parent span id to populate.</li>
<li><code>span_id</code> A pointer to a span id to populate.</li>
<li><strong>RETURN</strong> True if the span has a parent, false otherwise.</li>
</ul>
<h4 id="mtevzipkinspanlogsattached">mtev_zipkin_span_logs_attached</h4>
<blockquote>
<p>Report whether a span should have logs attached.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">bool</span>
<span class="hljs-title">mtev_zipkin_span_logs_attached</span><span class="hljs-params">(Zipkin_Span *span)</span>
</span></code></pre>
<ul>
<li><code>span</code> A zipkin span to report on.</li>
</ul>
<h4 id="mtevzipkinspannew">mtev_zipkin_span_new</h4>
<blockquote>
<p>Allocate a new tracing span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_Span *
<span class="hljs-title">mtev_zipkin_span_new</span><span class="hljs-params">(int64_t *trace_id, int64_t *parent_span_id, int64_t *span_id,
                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">bool</span> name_copy, <span class="hljs-keyword">bool</span> debug, <span class="hljs-keyword">bool</span> force)</span>
</span></code></pre>
<ul>
<li><code>trace_id</code> A pointer to the trace_id, if NULL, one will be assigned.</li>
<li><code>parent_span_id</code> A point to the span&apos;s parent_id (NULL is originating).</li>
<li><code>span_id</code> A pointer to the span&apos;s id (NULL will imply that trace_id should be used).</li>
<li><code>name</code> A name for this span.</li>
<li><code>name_copy</code> Wether the name should be allocated (copied) within the span.</li>
<li><code>debug</code> Pointer to whether this is a debug span (bypasses any sampling), NULL allowed.</li>
<li><code>force</code> force the span to be created as if all probabilities were 1.</li>
<li><strong>RETURN</strong> A new span.</li>
</ul>
<p>mtev_zipkin_span_new allocates a new span in the system. The caller must eventually release the span via a call to either mtev_zipkin_span_drop or mtev_zipkin_span_publish.</p>
<h4 id="mtevzipkinspanpublish">mtev_zipkin_span_publish</h4>
<blockquote>
<p>Pulish then release resources allociated with span without publishing.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_span_publish</span><span class="hljs-params">(Zipkin_Span *span)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to publish and release.</li>
</ul>
<p>mtev_zipkin_span_publish first publishes, then releases all resources associated with the span.</p>
<h4 id="mtevzipkinspanref">mtev_zipkin_span_ref</h4>
<blockquote>
<p>Increase the reference count to a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_span_ref</span><span class="hljs-params">(Zipkin_Span *span)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to reference.</li>
</ul>
<h4 id="mtevzipkinspanrename">mtev_zipkin_span_rename</h4>
<blockquote>
<p>Rename a span after it has been created, but before publishing.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mtev_zipkin_span_rename</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">bool</span> name_copy)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to rename.</li>
<li><code>name</code> The new name for the span.</li>
<li><code>name_copy</code> If the passed name will be freed or lost (copy required).</li>
</ul>
<h4 id="mtevzipkinstrtoid">mtev_zipkin_str_to_id</h4>
<blockquote>
<p>Convert a string Id to an int64_t Id.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span> *
mtev_zipkin_str_to_id(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in, <span class="hljs-keyword">int64_t</span> *buf)
</code></pre>
<ul>
<li><code>in</code> Id in string form</li>
<li><code>buf</code> working buffer (must not be NULL)</li>
<li><strong>RETURN</strong> pointer to translated id</li>
</ul>
<p>mtev_zipkin_str_to_id will take string form id (trace_id, parent_span_id, or span_id) and convert it to an int64_t.  If conversion fails, the function will return NULL.</p>
<h4 id="mtevzipkintimevaltotimestamp">mtev_zipkin_timeval_to_timestamp</h4>
<blockquote>
<p>Convert a struct timeval to a timestamp.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span>
mtev_zipkin_timeval_to_timestamp(<span class="hljs-keyword">struct</span> timeval *tv)
</code></pre>
<ul>
<li><code>tv</code> A point to a struct timeval representing the time in question.</li>
<li><strong>RETURN</strong> a timestamp suitable for use in annotations.</li>
</ul>
<p>mtev_zipkin_timeval_to_timestamp wil convert a struct timeval (e.g. from gettimeofday) to a the &quot;microseconds since epoch&quot; format expected by Zipkin.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Reference">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="lua.html" class="navigation navigation-next " aria-label="Next page: Lua API">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"C API","level":"1.7.1","depth":2,"next":{"title":"Lua API","level":"1.7.2","depth":2,"path":"apireference/lua.md","ref":"apireference/lua.md","articles":[]},"previous":{"title":"Reference","level":"1.7","depth":1,"path":"apireference/README.md","ref":"apireference/README.md","articles":[{"title":"C API","level":"1.7.1","depth":2,"path":"apireference/c.md","ref":"apireference/c.md","articles":[]},{"title":"Lua API","level":"1.7.2","depth":2,"path":"apireference/lua.md","ref":"apireference/lua.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["collapsible-menu","callouts","anchorjs"],"root":"./docs-md","styles":{"website":"styles/website.css"},"pluginsConfig":{"collapsible-menu":{},"callouts":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"fontSettings":{"theme":"night","family":"sans"},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"apireference/c.md","mtime":"","type":"markdown"},"gitbook":{"version":"3.2.3","time":""},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-collapsible-menu/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

