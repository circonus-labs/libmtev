
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>C API Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-callouts/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="lua.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Mount Everest</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../config/">
            
                <a href="../config/">
            
                    
                    Configuration
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../config/inherit.html">
            
                <a href="../config/inherit.html">
            
                    
                    Inheritance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../config/includes.html">
            
                <a href="../config/includes.html">
            
                    
                    Includes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../config/watchdog.html">
            
                <a href="../config/watchdog.html">
            
                    
                    Watchdog
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../config/eventer.html">
            
                <a href="../config/eventer.html">
            
                    
                    Eventer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../config/logging.html">
            
                <a href="../config/logging.html">
            
                    
                    Logging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../config/listeners.html">
            
                <a href="../config/listeners.html">
            
                    
                    Listeners
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../config/modules.html">
            
                <a href="../config/modules.html">
            
                    
                    Modules
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.7.1" data-path="../config/modules/amqp.html">
            
                <a href="../config/modules/amqp.html">
            
                    
                    amqp
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7.2" data-path="../config/modules/fq.html">
            
                <a href="../config/modules/fq.html">
            
                    
                    fq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7.3" data-path="../config/modules/lua_general.html">
            
                <a href="../config/modules/lua_general.html">
            
                    
                    lua_general
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7.4" data-path="../config/modules/lua_web.html">
            
                <a href="../config/modules/lua_web.html">
            
                    
                    lua_web
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7.5" data-path="../config/modules/zipkin_fq.html">
            
                <a href="../config/modules/zipkin_fq.html">
            
                    
                    zipkin_fq
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../development/">
            
                <a href="../development/">
            
                    
                    Development
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../development/important.html">
            
                <a href="../development/important.html">
            
                    
                    Important Starting Notes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../development/mtev_main.html">
            
                <a href="../development/mtev_main.html">
            
                    
                    mtev_main
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../development/eventer.html">
            
                <a href="../development/eventer.html">
            
                    
                    Eventer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../development/rest.html">
            
                <a href="../development/rest.html">
            
                    
                    REST and HTTP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../development/logging.html">
            
                <a href="../development/logging.html">
            
                    
                    Logging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../development/hooks.html">
            
                <a href="../development/hooks.html">
            
                    
                    Hooks
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../operations/">
            
                <a href="../operations/">
            
                    
                    Operations
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../operations/rest.html">
            
                <a href="../operations/rest.html">
            
                    
                    REST
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../operations/telnet_console.html">
            
                <a href="../operations/telnet_console.html">
            
                    
                    Telnet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../operations/dtrace.html">
            
                <a href="../operations/dtrace.html">
            
                    
                    DTrace
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="./">
            
                <a href="./">
            
                    
                    Reference
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.5.1" data-path="c.html">
            
                <a href="c.html">
            
                    
                    C API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="lua.html">
            
                <a href="lua.html">
            
                    
                    Lua API
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >C API</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h3 id="a">A</h3>
<h4 id="mtevamqpsend">mtev_amqp_send</h4>
<blockquote>
<p>Publish an AMQP message to one of the configured amqp brokers.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_amqp_send</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> amqp_envelope_t_ *env, <span class="hljs-keyword">int</span> mandatory, <span class="hljs-keyword">int</span> immediate, <span class="hljs-keyword">int</span> id)</span>
</span></code></pre>
<ul>
<li><code>env</code> An envelope with a valid message. The env pointer must be word aligned.</li>
<li><code>mandatory</code> Set to non-zero if the message should be sent with the mandatory flag.</li>
<li><code>immediate</code> Set to non-zero if the message should be sent with the immediate flag.</li>
<li><code>id</code> the ID of the connection: -1 to broadcast.</li>
</ul>
<h4 id="mtevamqpsenddata">mtev_amqp_send_data</h4>
<blockquote>
<p>Publish an AMQP message to one of the configured amqp brokers.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_amqp_send_data</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *exchange, <span class="hljs-keyword">char</span> *route, <span class="hljs-keyword">int</span> mandatory, <span class="hljs-keyword">int</span> immediate, <span class="hljs-keyword">void</span> *payload, 
                    <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> id)</span>
</span></code></pre>
<ul>
<li><code>exchange</code> The AMQP exchange to publish to.</li>
<li><code>route</code> The route to set on the message.</li>
<li><code>mandatory</code> Set to non-zero if the message should be sent with the mandatory flag.</li>
<li><code>immediate</code> Set to non-zero if the message should be sent with the immediate flag.</li>
<li><code>payload</code> the contents of the message.</li>
<li><code>len</code> the number of bytes present in payload.</li>
<li><code>id</code> the ID of the connection: -1 to broadcast.</li>
</ul>
<h3 id="b">B</h3>
<h4 id="mtevb32decode">mtev_b32_decode</h4>
<blockquote>
<p>Decode a base32 encoded input buffer into the provided output buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_b32_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the encoded content.</li>
<li><code>src_len</code> The size (in bytes) of the encoded data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the decoded output.  Returns zero is dest_len is too small.</li>
</ul>
<p>mtev_b32_decode decodes input until an the entire input is consumed or until an invalid base32 character is encountered.</p>
<h4 id="mtevb32encode">mtev_b32_encode</h4>
<blockquote>
<p>Encode raw data as base32 encoded output into the provided buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_b32_encode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the raw data.</li>
<li><code>src_len</code> The size (in bytes) of the raw data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the encoded output.  Returns zero is out_sz is too small.</li>
</ul>
<h4 id="mtevb32encodelen">mtev_b32_encode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain the base-32 encoding for a given number of bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span> 
mtev_b32_encode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the raw data buffer that might be encoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to store an encoded version of an input string.</li>
</ul>
<h4 id="mtevb32maxdecodelen">mtev_b32_max_decode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain a decoded base-32-encoded string of a given length.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span> 
mtev_b32_max_decode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the base-32-encoded string that might be decoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to decode the input string.</li>
</ul>
<h4 id="mtevb64decode">mtev_b64_decode</h4>
<blockquote>
<p>Decode a base64 encoded input buffer into the provided output buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_b64_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the encoded content.</li>
<li><code>src_len</code> The size (in bytes) of the encoded data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the decoded output.  Returns zero is dest_len is too small.</li>
</ul>
<p>mtev_b64_decode decodes input until an the entire input is consumed or until an invalid base64 character is encountered.</p>
<h4 id="mtevb64encode">mtev_b64_encode</h4>
<blockquote>
<p>Encode raw data as base64 encoded output into the provided buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_b64_encode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *src, size_t src_len, <span class="hljs-keyword">char</span> *dest, size_t dest_len)</span>
</span></code></pre>
<ul>
<li><code>src</code> The buffer containing the raw data.</li>
<li><code>src_len</code> The size (in bytes) of the raw data.</li>
<li><code>dest</code> The destination buffer to which the function will produce.</li>
<li><code>dest_len</code> The size of the destination buffer.</li>
<li><strong>RETURN</strong> The size of the encoded output.  Returns zero is out_sz is too small.</li>
</ul>
<p>mtev_b64_encode encodes an input string into a base64 representation with no linefeeds.</p>
<h4 id="mtevb64encodelen">mtev_b64_encode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain the base-64 encoding for a given number of bytes.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span> 
mtev_b64_encode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the raw data buffer that might be encoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to store an encoded version of an input string.</li>
</ul>
<h4 id="mtevb64maxdecodelen">mtev_b64_max_decode_len</h4>
<blockquote>
<p>Calculate how large a buffer must be to contain a decoded base-64-encoded string of a given length.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span> 
mtev_b64_max_decode_len(<span class="hljs-keyword">size_t</span> src_len)
</code></pre>
<ul>
<li><code>src_len</code> The size (in bytes) of the base-64-encoded string that might be decoded.</li>
<li><strong>RETURN</strong> The size of the buffer that would be needed to decode the input string.</li>
</ul>
<h3 id="c">C</h3>
<h4 id="mtevclusterbyname">mtev_cluster_by_name</h4>
<blockquote>
<p>Find the cluster with the registered name.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_cluster_t</span> *
mtev_cluster_by_name(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>name</code> The name of the cluster.</li>
<li><strong>RETURN</strong> Returns a pointer to the cluster or NULL is not found.</li>
</ul>
<p>Takes a name and finds a globally registered cluster by that name.</p>
<h4 id="mtevclusterenabled">mtev_cluster_enabled</h4>
<blockquote>
<p>Report on the availability of the clusters feature.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean 
<span class="hljs-title">mtev_cluster_enabled</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> mtev_true if clusters can be configured, otherwise mtev_false.</li>
</ul>
<h4 id="mtevclusterfindnode">mtev_cluster_find_node</h4>
<blockquote>
<p>Find a node by uuid within a cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_cluster_node_t</span> *
mtev_cluster_find_node(<span class="hljs-keyword">mtev_cluster_t</span> *cluster, <span class="hljs-keyword">uuid_t</span> nodeid)
</code></pre>
<ul>
<li><code>cluster</code> The &apos;<cluster>&apos; containing the node.</cluster></li>
<li><code>nodeid</code> The nodeid being searched for.</li>
<li><strong>RETURN</strong> Returns a pointer to the mtev_cluster_node_t or NULL if not found.</li>
</ul>
<p>Takes a cluster and a node UUID and returns a pointer to the 
corresponding mtev_cluster_node_t.</p>
<h4 id="mtevclusterinit">mtev_cluster_init</h4>
<blockquote>
<p>Initialize the mtev cluster configuration.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_cluster_init</span><span class="hljs-params">()</span>
</span></code></pre>
<p>Initializes the mtev cluster configuration.</p>
<h4 id="mtevclustersize">mtev_cluster_size</h4>
<blockquote>
<p>Report the number of nodes in the cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_cluster_size</span><span class="hljs-params">(mtev_cluster_t *cluster)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The cluster.</li>
<li><strong>RETURN</strong> The number of nodes in the cluster.</li>
</ul>
<p>Determines the number of nodes in the given cluster.</p>
<h4 id="mtevclusterupdate">mtev_cluster_update</h4>
<blockquote>
<p>Add or update an mtev cluster.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_cluster_update</span><span class="hljs-params">(mtev_conf_section_t cluster)</span>
</span></code></pre>
<ul>
<li><code>cluster</code> The &apos;<cluster>&apos; node configuration.</cluster></li>
<li><strong>RETURN</strong> Returns -1 on error, 0 on insert, or 1 on update.</li>
</ul>
<p>Takes a configuration section representing a cluster and registers
it in the global cluster configuration.</p>
<h3 id="d">D</h3>
<h4 id="mtevdynbufferadd">mtev_dyn_buffer_add</h4>
<blockquote>
<p>add data to the dyn_buffer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_add</span><span class="hljs-params">(mtev_dyn_buffer_t *buf, uint8_t *data, size_t len)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to add to.</li>
<li><code>data</code> the data to add.</li>
<li><code>len</code> the size of the data to add.</li>
</ul>
<h4 id="mtevdynbufferaddprintf">mtev_dyn_buffer_add_printf</h4>
<blockquote>
<p>add data to the dyn_buffer using printf semantics.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_add_printf</span><span class="hljs-params">(mtev_dyn_buffer_t *buf, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to add to.</li>
<li><code>format</code> the printf style format string</li>
<li><code>args</code> printf arguments</li>
</ul>
<p>This does NUL terminate the format string but does not advance the write_pointer past
the NUL.  Basically, the last mtev_dyn_buffer_add_printf will leave the resultant
data NUL terminated.</p>
<h4 id="mtevdynbufferadvance">mtev_dyn_buffer_advance</h4>
<blockquote>
<p>move the write_pointer forward len bytes</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_advance</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to advance</li>
</ul>
<h4 id="mtevdynbufferdata">mtev_dyn_buffer_data</h4>
<blockquote>
<p>return the front of the dyn_buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_data</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to get the pointer from.</li>
<li><strong>RETURN</strong> the pointer to the front (beginning) of the dyn_buffer</li>
</ul>
<h4 id="mtevdynbufferdestroy">mtev_dyn_buffer_destroy</h4>
<blockquote>
<p>destroy the dyn_buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_destroy</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><p><code>buf</code> the buffer to destroy</p>
<p>This must be called at the end of dyn_buffer interactions in case the
buffer has overflowed into dynamic allocation space.</p>
</li>
</ul>
<h4 id="mtevdynbufferensure">mtev_dyn_buffer_ensure</h4>
<blockquote>
<p>possibly grow the dyn_buffer so it can fit len bytes</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_ensure</span><span class="hljs-params">(mtev_dyn_buffer_t *buf, size_t len)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to ensure</li>
<li><code>len</code> the size of the data about to be added</li>
</ul>
<h4 id="mtevdynbufferinit">mtev_dyn_buffer_init</h4>
<blockquote>
<p>initialize a dyn_buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_init</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><p><code>buf</code> the buffer to init</p>
<p>Provided for completeness or non-stack allocations.</p>
</li>
</ul>
<h4 id="mtevdynbufferreset">mtev_dyn_buffer_reset</h4>
<blockquote>
<p>move the write position to the beginning of the buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_reset</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to reset.</li>
</ul>
<h4 id="mtevdynbuffersize">mtev_dyn_buffer_size</h4>
<blockquote>
<p>return the total size of the buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_size</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to get the size from.</li>
<li><strong>RETURN</strong> the total size of the buffer</li>
</ul>
<h4 id="mtevdynbufferused">mtev_dyn_buffer_used</h4>
<blockquote>
<p>return the total used space of the buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_used</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to get the used space from.</li>
<li><strong>RETURN</strong> the total used space of the buffer</li>
</ul>
<h4 id="mtevdynbufferwritepointer">mtev_dyn_buffer_write_pointer</h4>
<blockquote>
<p>return the end of the dyn_buffer</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_dyn_buffer_write_pointer</span><span class="hljs-params">(mtev_dyn_buffer_t *buf)</span>
</span></code></pre>
<ul>
<li><code>buf</code> the buffer to get the pointer from.</li>
<li><strong>RETURN</strong> the pointer to the end of the dyn_buffer</li>
</ul>
<h3 id="e">E</h3>
<h4 id="eventeraccept">eventer_accept</h4>
<blockquote>
<p>Execute an opset-appropriate <code>accept</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_accept</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">struct</span> sockaddr *addr, socklen_t *len, <span class="hljs-keyword">int</span> *mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>addr</code> a <code>struct sockaddr</code> to be populated.</li>
<li><code>len</code> a <code>socklen_t</code> pointer to the size of the <code>addr</code> argument; updated.</li>
<li><code>mask</code> a point the a mask. If the call does not complete, <code>*mask</code> it set.</li>
<li><strong>RETURN</strong> an opset-appropriate return value. (fd for POSIX, -1 for SSL).</li>
</ul>
<p>If the function returns -1 and <code>errno</code> is <code>EAGAIN</code>, the <code>*mask</code> reflects the
necessary activity to make progress.</p>
<h4 id="eventeradd">eventer_add</h4>
<blockquote>
<p>Add an event object to the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_add</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object to add.</li>
</ul>
<h4 id="eventeraddasynch">eventer_add_asynch</h4>
<blockquote>
<p>Add an asynchronous event to a specific job queue.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_add_asynch</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>q</code> a job queue</li>
<li><code>e</code> an event object</li>
</ul>
<p>This adds the <code>e</code> event to the job queue <code>q</code>.  <code>e</code> must have a mask
of <code>EVENETER_ASYNCH</code>.</p>
<h4 id="eventeraddat">eventer_add_at</h4>
<blockquote>
<p>Convenience function to schedule a callback at a specific time.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_add_at(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval whence)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>whence</code> the time at which to run the callback.</li>
<li><strong>RETURN</strong> N/A (C Macro).</li>
</ul>
<h4 id="eventeraddin">eventer_add_in</h4>
<blockquote>
<p>Convenience function to create an event to run a callback in the future</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_add_in(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval diff)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>diff</code> the amount of time to wait before running the callback.</li>
<li><strong>RETURN</strong> N/A (C Macro).</li>
</ul>
<h4 id="eventeraddinsus">eventer_add_in_s_us</h4>
<blockquote>
<p>Convenience function to create an event to run a callback in the future</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_add_in_s_us(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> seconds
                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> microseconds)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>seconds</code> the number of seconds to wait before running the callback.</li>
<li><code>microseconds</code> the number of microseconds (in addition to <code>seconds</code>) to wait before running the callback.</li>
<li><strong>RETURN</strong> N/A (C Macro).</li>
</ul>
<h4 id="eventeraddrecurrent">eventer_add_recurrent</h4>
<blockquote>
<p>Add an event to run during every loop cycle.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_add_recurrent</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
</ul>
<p><code>e</code> must have a mask of EVENER<em>RECURRENT.  This event will be invoked on
a single thread (dictated by <code>e</code>) once for each pass through the eventer loop.
This happens _often</em>, so do light work.</p>
<h4 id="eventeraddtimed">eventer_add_timed</h4>
<blockquote>
<p>Add a timed event to the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_add_timed</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
</ul>
<p>This adds the <code>e</code> event to the eventer. <code>e</code> must have a mask of
<code>EVENTER_TIMED</code>.</p>
<h4 id="eventeralloc">eventer_alloc</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_alloc()
</code></pre>
<ul>
<li><strong>RETURN</strong> A newly allocated event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventerallocasynch">eventer_alloc_asynch</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_alloc_asynch(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><strong>RETURN</strong> A newly allocated asynch event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventeralloccopy">eventer_alloc_copy</h4>
<blockquote>
<p>Allocate an event copied from another to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_alloc_copy(<span class="hljs-keyword">eventer_t</span> src)
</code></pre>
<ul>
<li><code>src</code> a source eventer_t to copy.</li>
<li><strong>RETURN</strong> A newly allocated event that is a copy of src.</li>
</ul>
<p>The allocated event has a refernce count of 1.</p>
<h4 id="eventerallocfd">eventer_alloc_fd</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_alloc_fd(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> mask)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><code>fd</code> The file descriptor.</li>
<li><code>mask</code> The mask of activity of interest.</li>
<li><strong>RETURN</strong> A newly allocated fd event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventerallocrecurrent">eventer_alloc_recurrent</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_alloc_recurrent(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><strong>RETURN</strong> A newly allocated recurrent event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventeralloctimer">eventer_alloc_timer</h4>
<blockquote>
<p>Allocate an event to be injected into the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_alloc_timer(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval *whence)
</code></pre>
<ul>
<li><code>func</code> The callback function.</li>
<li><code>closure</code> The closure for the callback function.</li>
<li><code>whence</code> The time at which the event should fire.</li>
<li><strong>RETURN</strong> A newly allocated timer event.</li>
</ul>
<p>The allocated event has a refernce count of 1 and is attached to the
calling thread.</p>
<h4 id="eventerallocationscurrent">eventer_allocations_current</h4>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span> 
eventer_allocations_current()
</code></pre>
<ul>
<li><strong>RETURN</strong> the number of currently allocated eventer objects.</li>
</ul>
<h4 id="eventerallocationstotal">eventer_allocations_total</h4>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span> 
eventer_allocations_total()
</code></pre>
<ul>
<li><strong>RETURN</strong> the number of allocated eventer objects over the life of the process.</li>
</ul>
<h4 id="eventerat">eventer_at</h4>
<blockquote>
<p>Convenience function to create an event to run a callback at a specific time.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_at(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval whence)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>whence</code> the time at which to run the callback.</li>
<li><strong>RETURN</strong> an event that has not been added to the eventer.</li>
</ul>
<blockquote>
<p>Note this does not actually schedule the event. See <a href="c.html#eventeraddat"><code>eventer_add_at</code></a>.</p>
</blockquote>
<h4 id="eventercallback">eventer_callback</h4>
<blockquote>
<p>Directly invoke an event&apos;s callback.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_callback</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> mask, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval *now)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>mask</code> the mask that callback should be acting upon (see <code>eventer_get_mask</code>)</li>
<li><code>closure</code> the closure on which the callback should act</li>
<li><code>now</code> the time the callback should see as &quot;now&quot;.</li>
<li><strong>RETURN</strong> The return value of the callback function as invoked.</li>
</ul>
<p>This does not call the callback in the contexts of the eventloop.  This means
that should the callback return a mask, the event-loop will not interpret it
and change state appropriately.  The caller must respond appropriately to any
return values.</p>
<h4 id="eventercallbackforname">eventer_callback_for_name</h4>
<blockquote>
<p>Find an event callback function that has been registered by name.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">evneter_func_t</span> 
eventer_callback_for_name(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>name</code> the name of the callback.</li>
<li><strong>RETURN</strong> the function pointer or NULL if no such callback has been registered.</li>
</ul>
<h4 id="eventercallbackms">eventer_callback_ms</h4>
<blockquote>
<p>Get the milliseconds since epoch of the current callback invocation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span> 
eventer_callback_ms()
</code></pre>
<ul>
<li><strong>RETURN</strong> milliseconds since epoch of callback invocation, or current time.</li>
</ul>
<h4 id="eventercallbackus">eventer_callback_us</h4>
<blockquote>
<p>Get the microseconds since epoch of the current callback invocation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span> 
eventer_callback_us()
</code></pre>
<ul>
<li><strong>RETURN</strong> microseconds since epoch of callback invocation, or current time.</li>
</ul>
<h4 id="eventerchooseowner">eventer_choose_owner</h4>
<blockquote>
<p>Find a thread in the default eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">pthread_t</span> 
eventer_choose_owner(<span class="hljs-keyword">int</span> n)
</code></pre>
<ul>
<li><code>n</code> an integer.</li>
<li><strong>RETURN</strong> a pthread_t of an eventer loop thread in the default eventer pool.</li>
</ul>
<p>This return the first thread when 0 is passed as an argument.  All non-zero arguments
are spread acorss the remaining threads (if existent) as <code>n</code> modulo one less than
the concurrency of the default event pool.</p>
<p>This is done because many systems aren&apos;t thread safe and can only schedule their
work on a single thread (thread 1). By spreading all thread-safe workloads across
the remaining threads we reduce potential overloading of the &quot;main&quot; thread.</p>
<p>To assign an event to a thread, use the result of this function to assign:
<code>e-&gt;thr_owner</code>.</p>
<h4 id="eventerchooseownerpool">eventer_choose_owner_pool</h4>
<blockquote>
<p>Find a thread in a specific eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">pthread_t</span> 
eventer_choose_owner_pool(<span class="hljs-keyword">eventer_pool_t</span> *pool, <span class="hljs-keyword">int</span> n)
</code></pre>
<ul>
<li><code>pool</code> an eventer pool.</li>
<li><code>n</code> an integer.</li>
<li><strong>RETURN</strong> a pthread_t of an eventer loop thread in the specified evneter pool.</li>
</ul>
<p>This function chooses a thread within the specified pool by taking <code>n</code>
modulo the concurrency of the pool.  If the default pool is speicified, special
assignment behavior applies. See <a href="c.html#eventerchooseowner"><code>eventer_choose_owner</code></a>.</p>
<p>To assign an event to a thread, use the result of this function to assign:
<code>e-&gt;thr_owner</code>.</p>
<h4 id="eventerclose">eventer_close</h4>
<blockquote>
<p>Execute an opset-appropriate <code>close</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_close</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> *mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>mask</code> a point the a mask. If the call does not complete, <code>*mask</code> it set.</li>
<li><strong>RETURN</strong> 0 on sucess or -1 with errno set.</li>
</ul>
<p>If the function returns -1 and <code>errno</code> is <code>EAGAIN</code>, the <code>*mask</code> reflects the
necessary activity to make progress.</p>
<h4 id="eventerderef">eventer_deref</h4>
<blockquote>
<p>See eventer_free.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_deref</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> the event to dereference.</li>
</ul>
<h4 id="eventerfdopsetgetaccept">eventer_fd_opset_get_accept</h4>
<blockquote>
<p>Retrieve the accept function from an fd opset.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_accept_t</span> 
eventer_fd_opset_get_accept(<span class="hljs-keyword">eventer_fd_opset_t</span> opset)
</code></pre>
<ul>
<li><code>opset</code> an opset (see <code>eventer_get_fd_opset</code>)</li>
<li><strong>RETURN</strong> An eventer_fd_accept_t function</li>
</ul>
<h4 id="eventerfdopsetgetclose">eventer_fd_opset_get_close</h4>
<blockquote>
<p>Retrieve the close function from an fd opset.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_close_t</span> 
eventer_fd_opset_get_close(<span class="hljs-keyword">eventer_fd_opset_t</span> opset)
</code></pre>
<ul>
<li><code>opset</code> an opset (see <code>eventer_get_fd_opset</code>)</li>
<li><strong>RETURN</strong> An eventer_fd_close_t function</li>
</ul>
<h4 id="eventerfdopsetgetread">eventer_fd_opset_get_read</h4>
<blockquote>
<p>Retrieve the read function from an fd opset.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_read_t</span> 
eventer_fd_opset_get_read(<span class="hljs-keyword">eventer_fd_opset_t</span> opset)
</code></pre>
<ul>
<li><code>opset</code> an opset (see <code>eventer_get_fd_opset</code>)</li>
<li><strong>RETURN</strong> An eventer_fd_read_t function</li>
</ul>
<h4 id="eventerfdopsetgetwrite">eventer_fd_opset_get_write</h4>
<blockquote>
<p>Retrieve the write function from an fd opset.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_write_t</span> 
eventer_fd_opset_get_write(<span class="hljs-keyword">eventer_fd_opset_t</span> opset)
</code></pre>
<ul>
<li><code>opset</code> an opset (see <code>eventer_get_fd_opset</code>)</li>
<li><strong>RETURN</strong> An eventer_fd_write_t function</li>
</ul>
<h4 id="eventerfindfd">eventer_find_fd</h4>
<blockquote>
<p>Find an event object in the eventer system by file descriptor.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_find_fd(<span class="hljs-keyword">int</span> e)
</code></pre>
<ul>
<li><code>fd</code> a file descriptor</li>
<li><strong>RETURN</strong> the event object if it exists; NULL if not found.</li>
</ul>
<h4 id="eventerforeachfdevent">eventer_foreach_fdevent</h4>
<blockquote>
<p>Run a user-provided function over all registered file descriptor events.</p>
</blockquote>
<pre><code class="lang-c">void 
eventer_foreach_fdevent(void (*fn)(eventer_t, void *), void *closure)
</code></pre>
<ul>
<li><code>fn</code> a function to be called with each event and <code>closure</code> as its arguments.</li>
<li><code>closure</code> the second argument to be passed to <code>fn</code>.</li>
</ul>
<h4 id="eventerforeachtimedevent">eventer_foreach_timedevent</h4>
<blockquote>
<p>Run a user-provided function over all registered timed events.</p>
</blockquote>
<pre><code class="lang-c">void 
eventer_foreach_timedevent(void (*fn)(eventer_t, void *), void *closure)
</code></pre>
<ul>
<li><code>fn</code> a function to be called with each event and <code>closure</code> as its arguments.</li>
<li><code>closure</code> the second argument to be passed to <code>fn</code>.</li>
</ul>
<h4 id="eventerfree">eventer_free</h4>
<blockquote>
<p>Dereferences the event specified.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_free</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> the event to dereference.</li>
</ul>
<h4 id="eventergetcallback">eventer_get_callback</h4>
<blockquote>
<p>Retrieve the callback function for an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_func_t</span> 
eventer_get_callback(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> An <code>eventer_func_t</code> callback function.</li>
</ul>
<h4 id="eventergetclosure">eventer_get_closure</h4>
<blockquote>
<p>Retrieve an event&apos;s closure.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">eventer_get_closure</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> The previous closure set.</li>
</ul>
<h4 id="eventergetepoch">eventer_get_epoch</h4>
<blockquote>
<p>Find the start time of the eventer loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_get_epoch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timeval *epoch)</span>
</span></code></pre>
<ul>
<li><code>epoch</code> a point to a <code>struct timeval</code> to fill out.</li>
<li><strong>RETURN</strong> 0 on success; -1 on failure (eventer loop not started).</li>
</ul>
<h4 id="eventergetfd">eventer_get_fd</h4>
<blockquote>
<p>Retrieve the file descriptor for an fd-based event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_get_fd</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> a file descriptor.</li>
</ul>
<h4 id="eventergetfdopset">eventer_get_fd_opset</h4>
<blockquote>
<p>Retrieve the fd opset from an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_fd_opset_t</span> 
eventer_get_fd_opset(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> The currently active opset for a fd-based eventer_t.</li>
</ul>
<h4 id="eventergetmask">eventer_get_mask</h4>
<blockquote>
<p>Retrieve the mask for an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_get_mask</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><p><strong>RETURN</strong> a mask of bitwise-or&apos;d valued.</p>
<ul>
<li><code>EVENTER_READ</code> -- trigger/set when a file descriptor is readable.</li>
<li><code>EVENTER_WRITE</code> -- trigger/set when a file descriptor is writeable.</li>
<li><code>EVENTER_EXCEPTION</code> -- trigger/set problems with a file descriptor.</li>
<li><code>EVENTER_TIMER</code> -- trigger/set at a specific time.</li>
<li><code>EVENTER_RECURRENT</code> -- trigger/set on each pass through the event-loop.</li>
<li><code>EVENTER_ASYNCH</code> -- trigger from a non-event-loop thread, set upon completion.</li>
<li><code>EVENTER_ASYNCH_WORK</code> -- set during asynchronous work.</li>
<li><code>EVENTER_ASYNCH_CLEANUP</code> -- set during asynchronous cleanup.</li>
</ul>
</li>
</ul>
<h4 id="eventergetowner">eventer_get_owner</h4>
<blockquote>
<p>Retrieve the thread that owns an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">pthread_t</span> 
eventer_get_owner(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> a <code>pthread_t</code> thread.</li>
</ul>
<h4 id="eventergetpoolforevent">eventer_get_pool_for_event</h4>
<blockquote>
<p>Determin which eventer pool owns a given event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_pool_t</span> *
eventer_get_pool_for_event(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object.</li>
<li><strong>RETURN</strong> the <code>eventer_pool_t</code> to which the event is scheduled.</li>
</ul>
<h4 id="eventergetwhence">eventer_get_whence</h4>
<blockquote>
<p>Retrieve the time at which a timer event will fire.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">struct</span> timeval 
<span class="hljs-title">eventer_get_whence</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> A absolute time.</li>
</ul>
<h4 id="eventergettimeofcallback">eventer_gettimeofcallback</h4>
<blockquote>
<p>Get the time of the last invoked callback in this thread.</p>
</blockquote>
<pre><code class="lang-c">
eventer_gettimeofcallback(<span class="hljs-keyword">struct</span> timeval *now, <span class="hljs-keyword">void</span> *tzp)
</code></pre>
<ul>
<li><code>now</code> a <code>struct timeval</code> to populate with the request time.</li>
<li><code>tzp</code> is ignored and for API compatibility with gettimeofday.</li>
<li><strong>RETURN</strong> 0 on success, non-zero on failure.</li>
</ul>
<p>This function returns the time of the last callback execution.  It
is fast and cheap (cheaper than gettimeofday), so if a function
wishes to know what time it is and the &quot;time of invocation&quot; is good
enough, this is considerably cheaper than a call to <code>mtev_gettimeofday</code>
or other system facilities.</p>
<h4 id="eventerimplpropset">eventer_impl_propset</h4>
<blockquote>
<p>Set properties for the event loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_impl_propset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *value)</span>
</span></code></pre>
<ul>
<li><code>key</code> the property</li>
<li><code>value</code> the property&apos;s value.</li>
<li><strong>RETURN</strong> 0 on success, -1 otherwise.</li>
</ul>
<p>Sets propoerties within the eventer. That can only be called prior
to <a href="c.html#eventerinit"><code>eventer_init</code></a>. See [Eventer configuuration)(../config/eventer.md)
for valid properties.</p>
<h4 id="eventerimplsetrlimit">eventer_impl_setrlimit</h4>
<blockquote>
<p>Attempt to set the rlimit on allowable open files.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_impl_setrlimit</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> the limit of the number of open files.</li>
</ul>
<p>The target is the <code>rlim_nofiles</code> eventer config option. If that configuration
option is unspecified, 1048576 is used.</p>
<h4 id="eventerin">eventer_in</h4>
<blockquote>
<p>Convenience function to create an event to run a callback in the future</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_in(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">struct</span> timeval diff)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>diff</code> the amount of time to wait before running the callback.</li>
<li><strong>RETURN</strong> an event that has not been added to the eventer.</li>
</ul>
<blockquote>
<p>Note this does not actually schedule the event. See <a href="c.html#eventeraddin"><code>eventer_add_in</code></a>.</p>
</blockquote>
<h4 id="eventerinsus">eventer_in_s_us</h4>
<blockquote>
<p>Convenience function to create an event to run a callback in the future</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_in_s_us(<span class="hljs-keyword">eventer_func_t</span> func, <span class="hljs-keyword">void</span> *closure, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> seconds
                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> microseconds)
</code></pre>
<ul>
<li><code>func</code> the callback function to run.</li>
<li><code>closure</code> the closure to be passed to the callback.</li>
<li><code>seconds</code> the number of seconds to wait before running the callback.</li>
<li><code>microseconds</code> the number of microseconds (in addition to <code>seconds</code>) to wait before running the callback.</li>
<li><strong>RETURN</strong> an event that has not been added to the eventer.</li>
</ul>
<blockquote>
<p>Note this does not actually schedule the event. See <a href="c.html#eventeraddinsus"><code>eventer_add_in_s_us</code></a>.</p>
</blockquote>
<h4 id="eventerinitglobals">eventer_init_globals</h4>
<blockquote>
<p>Initialize global structures required for eventer operation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_init_globals</span><span class="hljs-params">()</span>
</span></code></pre>
<p>This function is called by <a href="c.html#mtevmain"><code>mtev_main</code></a>.  Developers should not
need to call this function directly.</p>
<h4 id="eventerisloop">eventer_is_loop</h4>
<blockquote>
<p>Determine if a thread is participating in the eventer loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_is_loop</span><span class="hljs-params">(pthread_t tid)</span>
</span></code></pre>
<ul>
<li><code>tid</code> a thread</li>
<li><strong>RETURN</strong> 0 if the specified thread lives outside the eventer loop; 1 otherwise.</li>
</ul>
<h4 id="eventerloop">eventer_loop</h4>
<blockquote>
<p>Start the event loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_loop</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> N/A (does not return)</li>
</ul>
<p>This function should be called as that last think in your <code>child_main</code> function.
See <a href="c.html#mtevmain%60"><code>mtev_main</code></a>.</p>
<h4 id="eventerloopconcurrency">eventer_loop_concurrency</h4>
<blockquote>
<p>Determine the concurrency of the default eventer loop.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_loop_concurrency</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> number of threads used for the default eventer loop.</li>
</ul>
<h4 id="eventernamecallback">eventer_name_callback</h4>
<blockquote>
<p>Register a human/developer readable name for a eventer callback function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_name_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, eventer_func_t callback)</span>
</span></code></pre>
<ul>
<li><code>name</code> the human readable name.</li>
<li><code>callback</code> the functin pointer of the eveter callback.</li>
<li><strong>RETURN</strong> 0 on success.</li>
</ul>
<h4 id="eventernamecallbackext">eventer_name_callback_ext</h4>
<blockquote>
<p>Register a functional describer for a callback and it&apos;s event object.</p>
</blockquote>
<pre><code class="lang-c">int 
eventer_name_callback_ext(const char *name, eventer_func_t callback, void (*fn)(char *buff, int bufflen, 
                          eventer_t e, void *closure), void *closure)
</code></pre>
<ul>
<li><code>name</code> the human readable name.</li>
<li><code>callback</code> the functin pointer of the eveter callback.</li>
<li><code>fn</code> function to call when describing the event. It should write a null terminated string into buff (no more than bufflen).</li>
<li><strong>RETURN</strong> 0 on success.</li>
</ul>
<p>This function allows more in-depth descriptions of events.  When an event
is displayed (over the console or REST endpoints), this function is called
with the event in question and the closure specified at registration time.</p>
<h4 id="eventernameforcallback">eventer_name_for_callback</h4>
<blockquote>
<p>Retrieve a human readable name for the provided callback with event context.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">eventer_name_for_callback</span><span class="hljs-params">(evneter_func_t f, eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>f</code> a callback function.</li>
<li><code>e</code> and event object</li>
<li><strong>RETURN</strong> name of callback</li>
</ul>
<p>The returned value may be a pointer to reusable thread-local storage.
The value should be used before a subsequent call to this function.
Aside from that caveat, it is thread-safe.</p>
<h4 id="eventerpool">eventer_pool</h4>
<blockquote>
<p>Find an eventer pool by name.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_pool_t</span> *
eventer_pool(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
</code></pre>
<ul>
<li><code>name</code> the name of an eventer pool.</li>
<li><strong>RETURN</strong> an <code>eventer_pool_t *</code> by the given name, or NULL.</li>
</ul>
<h4 id="eventerpoolconcurrency">eventer_pool_concurrency</h4>
<blockquote>
<p>Retrieve the concurrency of an eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">uint32_t</span> 
eventer_pool_concurrency(<span class="hljs-keyword">eventer_pool_t</span> *pool)
</code></pre>
<ul>
<li><code>pool</code> an eventer pool.</li>
<li><strong>RETURN</strong> the number of threads powering the specified pool.</li>
</ul>
<h4 id="eventerpoolname">eventer_pool_name</h4>
<blockquote>
<p>Retrieve the name of an eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *
<span class="hljs-title">eventer_pool_name</span><span class="hljs-params">(eventer_pool_t *pool)</span>
</span></code></pre>
<ul>
<li><code>pool</code> an eventer pool.</li>
<li><strong>RETURN</strong> the name of the eventer pool.</li>
</ul>
<h4 id="eventerpoolwatchdogtimeout">eventer_pool_watchdog_timeout</h4>
<blockquote>
<p>Set a custom watchdog timeout for threads in an eventer pool.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_pool_watchdog_timeout</span><span class="hljs-params">(eventer_pool_t *pool, <span class="hljs-keyword">double</span> timeout)</span>
</span></code></pre>
<ul>
<li><code>pool</code> an eventer pool</li>
<li><code>timeout</code> the deadman timer in seconds.</li>
</ul>
<h4 id="eventerread">eventer_read</h4>
<blockquote>
<p>Execute an opset-appropriate <code>read</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_read</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">void</span> *buff, size_t len, <span class="hljs-keyword">int</span> *mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>buff</code> a buffer in which to place read data.</li>
<li><code>len</code> the size of <code>buff</code> in bytes.</li>
<li><code>mask</code> a point the a mask. If the call does not complete, <code>*mask</code> it set.</li>
<li><strong>RETURN</strong> the number of bytes read or -1 with errno set.</li>
</ul>
<p>If the function returns -1 and <code>errno</code> is <code>EAGAIN</code>, the <code>*mask</code> reflects the
necessary activity to make progress.</p>
<h4 id="eventerref">eventer_ref</h4>
<blockquote>
<p>Add a reference to an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_ref</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> the event to reference.</li>
</ul>
<p>Adding a reference to an event will prevent it from being deallocated
prematurely.  This is classic reference counting.  It is are that one
needs to maintain an actual event past the point where the eventer
system would normally free it.  Typically, one will allocate a new
event and copy the contents of the old event into it allowing the
original to be freed.</p>
<h4 id="eventerremove">eventer_remove</h4>
<blockquote>
<p>Remove an event object from the eventer system.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_remove(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object to add.</li>
<li><strong>RETURN</strong> the event object removed if found; NULL if not found.</li>
</ul>
<h4 id="eventerremovefd">eventer_remove_fd</h4>
<blockquote>
<p>Remove an event object from the eventer system by file descriptor.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_remove_fd(<span class="hljs-keyword">int</span> e)
</code></pre>
<ul>
<li><code>fd</code> a file descriptor</li>
<li><strong>RETURN</strong> the event object removed if found; NULL if not found.</li>
</ul>
<h4 id="eventerremovefde">eventer_remove_fde</h4>
<blockquote>
<p>Removes an fd event from the eventloop based on filedescriptor alone.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_remove_fde(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> The event removed, NULL if no event was present.</li>
</ul>
<h4 id="eventerremoverecurrent">eventer_remove_recurrent</h4>
<blockquote>
<p>Remove a recurrent event from the eventer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_remove_recurrent(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object.</li>
<li><strong>RETURN</strong> The event removed (<code>== e</code>); NULL if not found.</li>
</ul>
<h4 id="eventerremovetimed">eventer_remove_timed</h4>
<blockquote>
<p>Remove a timed event from the eventer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
eventer_remove_timed(<span class="hljs-keyword">eventer_t</span> e)
</code></pre>
<ul>
<li><code>e</code> an event object (mask must be <code>EVENTER_TIMED</code>).</li>
<li><strong>RETURN</strong> the event removed, NULL if not found.</li>
</ul>
<h4 id="eventersetcallback">eventer_set_callback</h4>
<blockquote>
<p>Set an event&apos;s callback function.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_set_callback</span><span class="hljs-params">(eventer_t e, eventer_func_t func)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> func <code>eventer_func_t</code> callback function.</li>
</ul>
<h4 id="eventersetclosure">eventer_set_closure</h4>
<blockquote>
<p>Set an event&apos;s closure.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_set_closure</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">void</span> *closure)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>closure</code> a pointer to user-data to be supplied during callback.</li>
</ul>
<h4 id="eventersetfdblocking">eventer_set_fd_blocking</h4>
<blockquote>
<p>Set a file descriptor into blocking mode.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_set_fd_blocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span>
</span></code></pre>
<ul>
<li><code>fd</code> a file descriptor</li>
<li><strong>RETURN</strong> 0 on success, -1 on error (errno set).</li>
</ul>
<h4 id="eventersetfdnonblocking">eventer_set_fd_nonblocking</h4>
<blockquote>
<p>Set a file descriptor into non-blocking mode.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_set_fd_nonblocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span>
</span></code></pre>
<ul>
<li><code>fd</code> a file descriptor</li>
<li><strong>RETURN</strong> 0 on success, -1 on error (errno set).</li>
</ul>
<h4 id="eventersetmask">eventer_set_mask</h4>
<blockquote>
<p>Change an event&apos;s interests or intentions.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_set_mask</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>mask</code> a new mask</li>
</ul>
<p>Do not change change a mask from one event &quot;type&quot; to another. fd events
must remain fd events. Timer must remain timer. Recurrent must remain recurrent.
Do not alter asynch events at all.  This simply changes the mask of the event
without changing any eventer state and should be used with extremem care.
Consider using the callback&apos;s return value or <code>eventer_update</code> to change
the mask of an active event in the system.</p>
<h4 id="eventersetowner">eventer_set_owner</h4>
<blockquote>
<p>Set the thread that owns an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_set_owner</span><span class="hljs-params">(eventer_t e, pthread_t t)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>t</code> a <code>pthread_t</code> thread; must be a valid event-loop.</li>
</ul>
<h4 id="eventerthreadcheck">eventer_thread_check</h4>
<blockquote>
<p>Determine if the calling thread &quot;owns&quot; an event.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_thread_check</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><strong>RETURN</strong> 0 if <code>e-&gt;thr_owner</code> is the <code>pthread_self()</code>, non-zero otherwise.</li>
</ul>
<h4 id="eventertrigger">eventer_trigger</h4>
<blockquote>
<p>Trigger an unregistered eventer and incorporate the outcome into the eventer.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_trigger</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">int</span> mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object that is not registered with the eventer.</li>
<li><code>mask</code> the mask to be used when invoking the event&apos;s callback.</li>
</ul>
<p>This is often used to &quot;start back up&quot; an event that has been removed from the
eventer for any reason.</p>
<h4 id="eventerupdate">eventer_update</h4>
<blockquote>
<p>Change the activity mask for file descriptor events.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_update</span><span class="hljs-params">(evneter_t e, <span class="hljs-keyword">int</span> mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>mask</code> a new mask that is some bitwise or of <code>EVENTER_READ</code>, <code>EVENTER_WRITE</code>, and <code>EVENTER_EXCEPTION</code></li>
</ul>
<h4 id="eventerupdatewhence">eventer_update_whence</h4>
<blockquote>
<p>Change the time at which a registered timer event should fire.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_update_whence</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">struct</span> timeval whence)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>whence</code> an absolute time.</li>
</ul>
<h4 id="eventerwakeup">eventer_wakeup</h4>
<blockquote>
<p>Signal up an event loop manually.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">eventer_wakeup</span><span class="hljs-params">(eventer_t e)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event</li>
</ul>
<p>The event <code>e</code> is used to determine which thread of the eventer loop to wake up.
If <code>e</code> is <code>NULL</code> the first thread in the default eventer loop is signalled. The
eventer loop can wake up on timed events, asynchronous job completions and 
file descriptor activity.  If, for an external reason, one needs to wake up
a looping thread, this call is used.</p>
<h4 id="eventerwrite">eventer_write</h4>
<blockquote>
<p>Execute an opset-appropriate <code>write</code> call.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">eventer_write</span><span class="hljs-params">(eventer_t e, <span class="hljs-keyword">void</span> *buff, size_t len, <span class="hljs-keyword">int</span> *mask)</span>
</span></code></pre>
<ul>
<li><code>e</code> an event object</li>
<li><code>buff</code> a buffer containing data to write.</li>
<li><code>len</code> the size of <code>buff</code> in bytes.</li>
<li><code>mask</code> a point the a mask. If the call does not complete, <code>*mask</code> it set.</li>
<li><strong>RETURN</strong> the number of bytes written or -1 with errno set.</li>
</ul>
<p>If the function returns -1 and <code>errno</code> is <code>EAGAIN</code>, the <code>*mask</code> reflects the
necessary activity to make progress.</p>
<h3 id="g">G</h3>
<h4 id="mtevgetnanos">mtev_get_nanos</h4>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span> 
mtev_get_nanos(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><blockquote>
<p>Like mtev_gethrtime. It actually is the implementation of mtev_gethrtime()</p>
</blockquote>
</li>
</ul>
<ul>
<li><ul>
<li><strong>RETURN</strong> number of nanos seconds from an arbitrary time in the past.</li>
</ul>
</li>
</ul>
<h4 id="mtevgetipipv4">mtev_getip_ipv4</h4>
<blockquote>
<p>find the local IPv4 address that would be used to talk to remote</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_getip_ipv4</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr remote, <span class="hljs-keyword">struct</span> in_addr *local)</span>
</span></code></pre>
<ul>
<li><code>remote</code> the destination (no packets are sent)</li>
<li><code>local</code> the pointer to the local address to be set</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure</li>
</ul>
<h4 id="mtevgettimeofday">mtev_gettimeofday</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_gettimeofday</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> timeval *t, <span class="hljs-keyword">void</span> **ttp)</span>
</span></code></pre>
<ul>
<li><blockquote>
<p>Maybe fast-pathed version of gettimeofday</p>
</blockquote>
</li>
</ul>
<ul>
<li><ul>
<li><strong>RETURN</strong> same as system gettimeofday();</li>
</ul>
</li>
<li></li>
<li>If the fast path is taken, ttp is ignored.</li>
</ul>
<h3 id="l">L</h3>
<h4 id="mtevlockfileacquire">mtev_lockfile_acquire</h4>
<blockquote>
<p>lock the file immediately if possible, return -1 otherwise.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_lockfile_t</span> 
mtev_lockfile_acquire(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fp)
</code></pre>
<ul>
<li><code>fp</code> the path to the lock file</li>
<li><strong>RETURN</strong> &gt;= 0 on success, -1 on failure</li>
</ul>
<h4 id="mtevlockfileacquireowner">mtev_lockfile_acquire_owner</h4>
<blockquote>
<p>lock the file immediately if possible, return -1 otherwise.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_lockfile_t</span> 
mtev_lockfile_acquire_owner(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fp, <span class="hljs-keyword">pid_t</span> *owner)
</code></pre>
<ul>
<li><code>fp</code> the path to the lock file</li>
<li><code>owner</code> is a pointer to a pid.  If the lock is owned by another process, this will be set to that pid, otherwise it will be set to -1.</li>
<li><strong>RETURN</strong> &gt;= 0 on success, -1 on failure</li>
</ul>
<h4 id="mtevlockfilerelease">mtev_lockfile_release</h4>
<blockquote>
<p>release a held file lock</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_lockfile_release</span><span class="hljs-params">(mtev_lockfile_t fd)</span>
</span></code></pre>
<ul>
<li><code>fd</code> the file lock to release</li>
<li><strong>RETURN</strong> -1 on failure, 0 on success</li>
</ul>
<h4 id="mtevlualmcalloc">mtev_lua_lmc_alloc</h4>
<blockquote>
<p>Allocated and initialize a <code>lua_module_closure_t</code> for a new runtime.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">lua_module_closure_t</span> *
mtev_lua_lmc_alloc(<span class="hljs-keyword">mtev_dso_generic_t</span> *self, <span class="hljs-keyword">mtev_lua_resume_info_t</span> *resume)
</code></pre>
<ul>
<li><code>self</code> the module implementing a custom lua runtime environment</li>
<li><code>resume</code> the custom resume function for this environment</li>
<li><strong>RETURN</strong> a new allocated and initialized <code>lua_module_closure</code></li>
</ul>
<blockquote>
<p>Note these are not thread safe because lua is not thread safe. If you are managing multiple
C threads, you should have a <code>lua_module_closure_t</code> for each thread and maintain them in a
thread-local fashion.  Also ensure that any use of the eventer does not migrate cross thread.</p>
</blockquote>
<h4 id="mtevlualmcfree">mtev_lua_lmc_free</h4>
<blockquote>
<p>Free a <code>lua_module_closure_t</code> structure that has been allocated.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_lua_lmc_free</span><span class="hljs-params">(lua_module_closure_t *lmc)</span>
</span></code></pre>
<ul>
<li><code>lmc</code> The <code>lua_module_closure_t</code> to be freed.</li>
</ul>
<h4 id="mtevlualmcl">mtev_lua_lmc_L</h4>
<blockquote>
<p>Get the <code>lua_State *</code> for this module closure.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">lua_State *
<span class="hljs-title">mtev_lua_lmc_L</span><span class="hljs-params">(lua_module_closure_t *lmc)</span>
</span></code></pre>
<ul>
<li><code>lmc</code> the <code>lua_module_closure_t</code> that was allocated for this runtime.</li>
<li><strong>RETURN</strong> a Lua state</li>
</ul>
<h4 id="mtevlualmcresume">mtev_lua_lmc_resume</h4>
<blockquote>
<p>Invoke lua_resume with the correct context based on the <code>lua_module_closure_t</code></p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_lua_lmc_resume</span><span class="hljs-params">(lua_module_closure_t *lmc, mtev_lua_resume_info_t *ri, <span class="hljs-keyword">int</span> nargs)</span>
</span></code></pre>
<ul>
<li><code>lmc</code> the <code>lua_module_closure_t</code> associated with the current lua runtime.</li>
<li><code>ri</code> resume meta information</li>
<li><code>nargs</code> the number of arguments on the lua stack to return</li>
<li><strong>RETURN</strong> the return value of the underlying <code>lua_resume</code> call.</li>
</ul>
<h4 id="mtevlualmcsetl">mtev_lua_lmc_setL</h4>
<blockquote>
<p>Set the <code>lua_State *</code> for this module closure, returning the previous value.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">lua_State *
<span class="hljs-title">mtev_lua_lmc_setL</span><span class="hljs-params">(lua_module_closure_t *lmc)</span>
</span></code></pre>
<ul>
<li><code>lmc</code> the <code>lua_module_closure_t</code> that was allocated for this runtime.</li>
<li><code>lmc</code> the <code>lua_State *</code> that should be placed in this closure.</li>
<li><strong>RETURN</strong> the previous lua Lua state associated with this closure</li>
</ul>
<h3 id="m">M</h3>
<h4 id="mtevmain">mtev_main</h4>
<blockquote>
<p>Run a comprehensive mtev setup followed by a &quot;main&quot; routine.</p>
</blockquote>
<pre><code class="lang-c">int 
mtev_main(const char *appname, const char *config_filename, int debug, int foreground, 
          mtev_log_op_t lock, const char *glider, const char *drop_to_user, 
          const char *drop_to_group, int (*passed_child_main)(void))
</code></pre>
<ul>
<li><code>appname</code> The application name (should be the config root node name).</li>
<li><code>config_filename</code> The path the the config file.</li>
<li><code>debug</code> Enable debugging (logging).</li>
<li><code>foreground</code> 0 to daemonize with watchdog, 1 to foreground, 2 to foreground with watchdog.</li>
<li><code>lock</code> Specifies where to not lock, try lock or exit, or lock or wait.</li>
<li><code>glider</code> A path to an executable to invoke against the process id on crash. May be NULL.</li>
<li><code>drop_to_user</code> A target user for dropping privileges when under watchdog. May be NULL.</li>
<li><code>drop_to_group</code> A target group for dropping privileges when under watchdog. May be NULL.</li>
<li><code>passed_child_main</code> A programmers supplied main function.</li>
<li><strong>RETURN</strong> -1 on failure, 0 on success if <code>foreground==1</code>, or the return value of <code>main</code> if run in the foreground.</li>
</ul>
<h4 id="mtevmainstatus">mtev_main_status</h4>
<blockquote>
<p>Determine if that application is already running under this configuration.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_main_status</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *appname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *config_filename, <span class="hljs-keyword">int</span> debug, pid_t *pid
                 pid_t *pgid)</span>
</span></code></pre>
<ul>
<li><code>appname</code> The application name (should be the config root node name).</li>
<li><code>config_filename</code> The path the the config file.</li>
<li><code>debug</code> Enable debugging (logging).</li>
<li><code>pid</code> If not null, it is populated with the process id of the running instance.</li>
<li><code>pgid</code> If not null, it is populated with the process group id of the running instance.</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure.</li>
</ul>
<h4 id="mtevmainterminate">mtev_main_terminate</h4>
<blockquote>
<p>Terminate an already running application under the same configuration.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_main_terminate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *appname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *config_filename, <span class="hljs-keyword">int</span> debug)</span>
</span></code></pre>
<ul>
<li><code>appname</code> The application name (should be the config root node name).</li>
<li><code>config_filename</code> The path the the config file.</li>
<li><code>debug</code> Enable debugging (logging).</li>
<li><strong>RETURN</strong> 0 on success, -1 on failure.  If the application is not running at the time of invocation, termination is considered successful.</li>
</ul>
<h4 id="mtevmaybedecl">MTEV_MAYBE_DECL</h4>
<blockquote>
<p>C Macro for declaring a &quot;maybe&quot; buffer.</p>
</blockquote>
<pre><code class="lang-c">
MTEV_MAYBE_DECL(type, name, cnt)
</code></pre>
<ul>
<li><code>type</code> A C type (e.g. char)</li>
<li><code>name</code> The name of the C variable to declare.</li>
<li><code>cnt</code> The number of type elements initially declared.</li>
</ul>
<p>A &quot;maybe&quot; buffer is a buffer that is allocated on-stack, but
if more space is required can be reallocated off stack (malloc).
One should always call <code>MTEV_MAYBE_FREE</code> on any allocated
maybe buffer.</p>
<h4 id="mtevmaybedeclvars">MTEV_MAYBE_DECL_VARS</h4>
<blockquote>
<p>C Macro for declaring a &quot;maybe&quot; buffer.</p>
</blockquote>
<pre><code class="lang-c">
MTEV_MAYBE_DECL_VARS(type, name, cnt)
</code></pre>
<ul>
<li><code>type</code> A C type (e.g. char)</li>
<li><code>name</code> The name of the C variable to declare.</li>
<li><code>cnt</code> The number of type elements initially declared.</li>
</ul>
<h4 id="mtevmaybefree">MTEV_MAYBE_FREE</h4>
<blockquote>
<p>C Macro to free any heap space associated with a &quot;maybe&quot; buffer.</p>
</blockquote>
<pre><code class="lang-c">
MTEV_MAYBE_FREE(name)
</code></pre>
<ul>
<li><code>name</code> The name of the &quot;maybe&quot; buffer.</li>
</ul>
<h4 id="mtevmaybeinitvars">MTEV_MAYBE_INIT_VARS</h4>
<blockquote>
<p>C Macro for initializing a &quot;maybe&quot; buffer</p>
</blockquote>
<pre><code class="lang-c">
MTEV_MAYBE_INIT_VARS(name)
</code></pre>
<ul>
<li><code>name</code> The name of &quot;maybe&quot; buffer.</li>
</ul>
<h4 id="mtevmayberealloc">MTEV_MAYBE_REALLOC</h4>
<blockquote>
<p>C Macro to ensure a maybe buffer has at least cnt elements allocated.</p>
</blockquote>
<pre><code class="lang-c">
MTEV_MAYBE_REALLOC(name, cnt)
</code></pre>
<ul>
<li><code>name</code> The name of the &quot;maybe&quot; buffer.</li>
<li><code>cnt</code> The total number of elements expected in the allocation.</li>
</ul>
<p>This macro will never reduce the size and is a noop if a size smaller
than or equal to the current allocation size is specified.  It is safe
to simply run this macro prior to each write to the buffer.</p>
<h4 id="mtevmaybesize">MTEV_MAYBE_SIZE</h4>
<blockquote>
<p>C Macro for number of bytes available in this buffer.</p>
</blockquote>
<pre><code class="lang-c">
MTEV_MAYBE_SIZE(name)
</code></pre>
<ul>
<li><code>name</code> The name of the &quot;maybe&quot; buffer.</li>
</ul>
<h4 id="mtevmergesort">mtev_merge_sort</h4>
<blockquote>
<p>Merge sort data starting at head_ptr_ptr, iteratively</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">void</span> **head_ptr_ptr, mtev_sort_next_function next, 
                mtev_sort_set_next_function set_next, mtev_sort_compare_function compare)</span>
</span></code></pre>
<ul>
<li><code>next</code> the function to call to get the next pointer from a node</li>
<li><code>set_next</code> the function to call to alter the item directly after current</li>
<li><code>compare</code> the function to call to compare 2 nodes</li>
</ul>
<h4 id="mkdirforfile">mkdir_for_file</h4>
<blockquote>
<p>Create directories along a path.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mkdir_for_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, mode_t m)</span>
</span></code></pre>
<ul>
<li><code>file</code> a filename for which a directory is desired.</li>
<li><code>m</code> the mode used for creating directories.</li>
<li><strong>RETURN</strong> Returns 0 on success, -1 on error.</li>
</ul>
<p>Creates all directories from / (as needed) to hold a named file.</p>
<h3 id="n">N</h3>
<h4 id="mtevnowms">mtev_now_ms</h4>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span> 
mtev_now_ms()
</code></pre>
<ul>
<li><blockquote>
<p>the current system time in milliseconds</p>
</blockquote>
</li>
</ul>
<ul>
<li><ul>
<li><strong>RETURN</strong> mtev_gettimeofday() in milliseconds since epoch</li>
</ul>
</li>
</ul>
<h4 id="mtevnowus">mtev_now_us</h4>
<pre><code class="lang-c"><span class="hljs-keyword">uint64_t</span> 
mtev_now_us()
</code></pre>
<ul>
<li><blockquote>
<p>the current system time in microseconds</p>
</blockquote>
</li>
</ul>
<ul>
<li><ul>
<li><strong>RETURN</strong> mtev_gettimeofday() in microseconds since epoch</li>
</ul>
</li>
</ul>
<h3 id="s">S</h3>
<h4 id="mtevsecuritychroot">mtev_security_chroot</h4>
<blockquote>
<p>chroot(2) to the specified directory.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_security_chroot</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span>
</span></code></pre>
<ul>
<li><code>path</code> The path to chroot to.</li>
<li><strong>RETURN</strong> Zero is returned on success.</li>
</ul>
<p>mtev_security_chroot placing the calling application into a chroot
environment.</p>
<h4 id="mtevsecuritysetcaps">mtev_security_setcaps</h4>
<blockquote>
<p>change the capabilities of the process</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_security_setcaps</span><span class="hljs-params">(mtev_security_captype_t type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *capstring)</span>
</span></code></pre>
<ul>
<li><code>which</code> the effective, inherited or both</li>
<li><code>capstring</code> alteration to the capabilities</li>
<li><strong>RETURN</strong> Zero is returned on success.</li>
</ul>
<p>mtev_security_setcaps will change the capability set of the current
process.</p>
<h4 id="mtevsecurityusergroup">mtev_security_usergroup</h4>
<blockquote>
<p>change the effective or real, effective and saved user and group</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_security_usergroup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *group, mtev_boolean effective)</span>
</span></code></pre>
<ul>
<li><code>user</code> The user name as either a login or a userid in string form.</li>
<li><code>group</code> The group name as either a login or a groupid in string form.</li>
<li><code>effective</code> If true then only effective user and group are changed.</li>
<li><strong>RETURN</strong> Zero is returned on success.</li>
</ul>
<p>mtev_security_usergroup will change the real, effective, and saved
user and group for the calling process.  This is thread-safe.</p>
<h4 id="mtevsemdestroy">mtev_sem_destroy</h4>
<blockquote>
<p>releases all resources related to a semaphore</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_sem_destroy</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore to destroy</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsemgetvalue">mtev_sem_getvalue</h4>
<blockquote>
<p>retrieves the current value of a semaphore, placing it in *value</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_sem_getvalue</span><span class="hljs-params">(mtev_sem_t *s, <span class="hljs-keyword">int</span> *value)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to operate</li>
<li><code>value</code> a pointer an integer that will be populated with the current value of the semaphore</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevseminit">mtev_sem_init</h4>
<blockquote>
<p>initializes a counting semaphore for first time use.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_sem_init</span><span class="hljs-params">(mtev_sem_t *s, <span class="hljs-keyword">int</span> unused, <span class="hljs-keyword">int</span> value)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore to be initialized</li>
<li><code>unused</code> is unused (keeps API combatibility with sem_init()</li>
<li><code>value</code> sets the initial value of the semaphore</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsempost">mtev_sem_post</h4>
<blockquote>
<p>increments the value of the semaphore releasing any waiters.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_sem_post</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to wait</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsemtrywait">mtev_sem_trywait</h4>
<blockquote>
<p>decrements the value of the semaphore if greater than 0 or fails</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_sem_trywait</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to wait</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsemwait">mtev_sem_wait</h4>
<blockquote>
<p>decrements the value of the semaphore waiting if required.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_sem_wait</span><span class="hljs-params">(mtev_sem_t *s)</span>
</span></code></pre>
<ul>
<li><code>s</code> the semaphore on which to wait</li>
<li><strong>RETURN</strong> 0 on success or -1 on failure</li>
</ul>
<h4 id="mtevsortcomparefunction">mtev_sort_compare_function</h4>
<blockquote>
<p>Function definition to compare sortable entries</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_sort_compare_function</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *left, <span class="hljs-keyword">void</span> *right)</span>
</span></code></pre>
<ul>
<li><code>left</code> one object to compare</li>
<li><code>right</code> the other object to compare</li>
<li><strong>RETURN</strong> less than zero, zero, or greater than zero if left is less than, equal, or greater than right.</li>
</ul>
<h4 id="mtevsortnextfunction">mtev_sort_next_function</h4>
<blockquote>
<p>Function definition to get the next item from current</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> *
<span class="hljs-title">mtev_sort_next_function</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *current)</span>
</span></code></pre>
<ul>
<li><code>current</code> the current node</li>
<li><strong>RETURN</strong> the item after current</li>
</ul>
<h4 id="mtevsortsetnextfunction">mtev_sort_set_next_function</h4>
<blockquote>
<p>Function definition to re-order objects</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_sort_set_next_function</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *current, <span class="hljs-keyword">void</span> *value)</span>
</span></code></pre>
<ul>
<li><code>current</code> the current node</li>
<li><code>value</code> the value that should be directly after current</li>
</ul>
<h4 id="mtevsysgethrtime">mtev_sys_gethrtime</h4>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_hrtime_t</span> 
mtev_sys_gethrtime(<span class="hljs-keyword">void</span>)
</code></pre>
<ul>
<li><blockquote>
<p>Exposes the system gethrtime() or equivalent impl</p>
</blockquote>
</li>
</ul>
<ul>
<li><ul>
<li><strong>RETURN</strong> mtev_hrtime_t the system high-res time</li>
</ul>
</li>
</ul>
<h3 id="t">T</h3>
<h4 id="mtevtimefastmode">mtev_time_fast_mode</h4>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean 
<span class="hljs-title">mtev_time_fast_mode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **reason)</span>
</span></code></pre>
<ul>
<li><blockquote>
<p>check to see if fast mode is enabled</p>
</blockquote>
</li>
</ul>
<ul>
<li><ul>
<li><strong>RETURN</strong> true if fast mode is on, false otherwise, the reason param will contain a text description</li>
</ul>
</li>
</ul>
<h4 id="mtevtimemaintain">mtev_time_maintain</h4>
<pre><code class="lang-c"><span class="hljs-function">mtev_boolean 
<span class="hljs-title">mtev_time_maintain</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><blockquote>
<p>Usually this is managed for you, but this is safe to call at any time</p>
</blockquote>
</li>
</ul>
<ul>
<li><ul>
<li><strong>RETURN</strong> mtev_true if it was successful in parameterizing the CPU for rdtsc, mtev_false otherwise</li>
</ul>
</li>
<li></li>
<li>Safe to call at any time but if you start_tsc, you should never need to call this</li>
<li>as the maintenance system can do it for you. However, if you find you need to call it</li>
<li>you must be bound to a thread using the mtev_thread APIs and the function will return</li>
<li>whether it was successful in parameterizing the CPU for rdtsc use.</li>
</ul>
<h4 id="mtevtimestarttsc">mtev_time_start_tsc</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_time_start_tsc</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><blockquote>
<p>use TSC clock if possible for this CPU num</p>
</blockquote>
</li>
</ul>
<ul>
<li></li>
<li>This will remain active in the thread until you call stop</li>
</ul>
<h4 id="mtevtimestoptsc">mtev_time_stop_tsc</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_time_stop_tsc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span></code></pre>
<ul>
<li><blockquote>
<p>Turn off TSC usage for the current cpu of this thread (from when start_tsc was called)</p>
</blockquote>
</li>
</ul>
<h4 id="mtevtimetogglerequireinvarianttsc">mtev_time_toggle_require_invariant_tsc</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_time_toggle_require_invariant_tsc</span><span class="hljs-params">(mtev_boolean enable)</span>
</span></code></pre>
<ul>
<li><blockquote>
<p>will switch on/off the requirement of an invariant tsc.  This must be run before any call to mtev_time_toggle_tsc() or mtev_time_tsc_start() and is a one time call.</p>
</blockquote>
</li>
</ul>
<p> *</p>
<ul>
<li>Defaults to enabled.</li>
</ul>
<h4 id="mtevtimetoggletsc">mtev_time_toggle_tsc</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_time_toggle_tsc</span><span class="hljs-params">(mtev_boolean enable)</span>
</span></code></pre>
<ul>
<li><blockquote>
<p>will switch on/off rdtsc usage across all cores regardless of detected state of rdtsc or start/stop usage.</p>
</blockquote>
</li>
</ul>
<ul>
<li></li>
<li>Defaults to enabled.</li>
<li></li>
<li>This is independent of start_tsc/stop_tsc.  You can disable all and then reenable and the thread</li>
<li>will keep going using the state from the last start/stop_tsc</li>
</ul>
<h3 id="u">U</h3>
<h4 id="updateretries">update_retries</h4>
<blockquote>
<p>Updates the list of retries and signals to quit if the limit is exceeded</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">update_retries</span><span class="hljs-params">(<span class="hljs-keyword">int</span> retries, <span class="hljs-keyword">int</span> span, retry_data** data)</span>
</span></code></pre>
<ul>
<li><code>offset</code> The current location in the data array to place the new time in</li>
<li><code>times</code> An array of times used to determine if there have been too many restarts</li>
<li><strong>RETURN</strong> Returns 1 to signal a quit, 0 otherwise</li>
</ul>
<p>.</p>
<p>update_retries will iterate through a list of times the task has restarted. If it determines that the system has been restarted too many times in too short a period, it will return 1 and the program will terminate. Otherwise, it will return 0 and the program will restart.</p>
<h3 id="w">W</h3>
<h4 id="mtevwatchdogchildeventerheartbeat">mtev_watchdog_child_eventer_heartbeat</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_watchdog_child_eventer_heartbeat</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> Returns zero on success</li>
</ul>
<p>mtev_watchdog_child_eventer_heartbeat registers a periodic heartbeat through the eventer subsystem.  The eventer must be initialized before calling this function.</p>
<h4 id="mtevwatchdogchildheartbeat">mtev_watchdog_child_heartbeat</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_watchdog_child_heartbeat</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> Returns zero on success</li>
</ul>
<p>mtev_watchdog_child_heartbeat is called within the child function to alert the parent that the child is still alive and functioning correctly.</p>
<h4 id="mtevwatchdogcreate">mtev_watchdog_create</h4>
<pre><code class="lang-c"><span class="hljs-keyword">mtev_watchdog_t</span> *
mtev_watchdog_create()
</code></pre>
<ul>
<li><strong>RETURN</strong> a new heartbeat identifier (or null, if none could be allocated)</li>
</ul>
<p>mtev_watchdog_create creates a new heartbeat that must be assessed for liveliness by the parent.</p>
<h4 id="mtevwatchdogdisable">mtev_watchdog_disable</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_watchdog_disable</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart on which to act</li>
</ul>
<p>mtev_watchdog_disable will make the parent ignore failed heartbeats.</p>
<h4 id="mtevwatchdogenable">mtev_watchdog_enable</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_watchdog_enable</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart on which to act</li>
</ul>
<p>mtev_watchdog_enable will make the parent respect and act on failed heartbeats.</p>
<h4 id="mtevwatchdogheartbeat">mtev_watchdog_heartbeat</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_watchdog_heartbeat</span><span class="hljs-params">(mtev_watchdog_t *hb)</span>
</span></code></pre>
<ul>
<li><code>hb</code> is the heart on which to pulse.  If null, the default heart is used.</li>
<li><strong>RETURN</strong> Returns zero on success</li>
</ul>
<p>mtev_watchdog_heartbeat will pulse on the specified heart.</p>
<h4 id="mtevwatchdogoverridetimeout">mtev_watchdog_override_timeout</h4>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_watchdog_override_timeout</span><span class="hljs-params">(mtev_watchdog_t *lifeline, <span class="hljs-keyword">double</span> timeout)</span>
</span></code></pre>
<ul>
<li><code>hb</code> the heart on which to act</li>
<li><code>timeout</code> the timeout in seconds for this heart (0 for default)</li>
</ul>
<p>mtev_watchdog_override_timeout will allow the caller to override the timeout
for a specific heart in the system.</p>
<h4 id="mtevwatchdogpreforkinit">mtev_watchdog_prefork_init</h4>
<blockquote>
<p>Prepare the program to split into a child/parent-monitor relationship.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> 
<span class="hljs-title">mtev_watchdog_prefork_init</span><span class="hljs-params">()</span>
</span></code></pre>
<ul>
<li><strong>RETURN</strong> Returns zero on success.</li>
</ul>
<p>mtev_watchdog_prefork_init sets up the necessary plumbing to bridge across a
child to instrument watchdogs.</p>
<h4 id="mtevwatchdogrecurrentheartbeat">mtev_watchdog_recurrent_heartbeat</h4>
<pre><code class="lang-c"><span class="hljs-keyword">eventer_t</span> 
mtev_watchdog_recurrent_heartbeat(<span class="hljs-keyword">mtev_watchdog_t</span> *hb)
</code></pre>
<ul>
<li><code>hb</code> is the heart on which to beat.</li>
<li><strong>RETURN</strong> Returns and event that the caller must schedule.</li>
</ul>
<p>mtev_watchdog_recurrent_heartbeat creates a recurrent eventer_t to beat a heart.</p>
<h4 id="mtevwatchdogstartchild">mtev_watchdog_start_child</h4>
<blockquote>
<p>Starts a function as a separate child under close watch.</p>
</blockquote>
<pre><code class="lang-c">int 
mtev_watchdog_start_child(const char *app, int (*func)(), int child_watchdog_timeout)
</code></pre>
<ul>
<li><code>app</code> The name of the application (for error output).</li>
<li><code>func</code> The function that will be the child process.</li>
<li><code>child_watchdog_timeout</code> The number of seconds of lifelessness before the parent reaps and restarts the child.</li>
<li><strong>RETURN</strong> Returns on program termination.</li>
</ul>
<p>mtev_watchdog_start_child will fork and run the specified function in the child process.  The parent will watch.  The child process must initialize the eventer system and then call mtev_watchdog_child_hearbeat to let the parent know it is alive.  If the eventer system is being used to drive the child process, mtev_watchdog_child_eventer_heartbeat may be called once after the eventer is initalized.  This will induce a regular heartbeat.</p>
<h3 id="z">Z</h3>
<h4 id="mtevzipkinannotationsetendpoint">mtev_zipkin_annotation_set_endpoint</h4>
<blockquote>
<p>Sets the endpoint for an annotation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_zipkin_annotation_set_endpoint</span><span class="hljs-params">(Zipkin_Annotation *annotation, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name, 
                                    <span class="hljs-keyword">bool</span> service_name_copy, <span class="hljs-keyword">struct</span> in_addr host, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port)</span>
</span></code></pre>
<ul>
<li><code>annotation</code> The annotation to update.</li>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
<li><code>host</code> The IPv4 host address of theservice.</li>
<li><code>port</code> The IP port of the service.</li>
</ul>
<p>mtev_zipkin_annotation_set_endpoint sets an endpoint for the provided annotation.</p>
<h4 id="mtevzipkinbannotationsetendpoint">mtev_zipkin_bannotation_set_endpoint</h4>
<blockquote>
<p>Sets the endpoint for an annotation.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_zipkin_bannotation_set_endpoint</span><span class="hljs-params">(Zipkin_BinaryAnnotation *annotation, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name, 
                                     <span class="hljs-keyword">bool</span> service_name_copy, <span class="hljs-keyword">struct</span> in_addr host, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port)</span>
</span></code></pre>
<ul>
<li><code>annotation</code> The annotation to update.</li>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
<li><code>host</code> The IPv4 host address of theservice.</li>
<li><code>port</code> The IP port of the service.</li>
</ul>
<p>mtev_zipkin_bannotation_set_endpoint sets an endpoint for the provided annotation.</p>
<h4 id="mtevzipkindefaultendpoint">mtev_zipkin_default_endpoint</h4>
<blockquote>
<p>Sets the default endpoint used for new spans.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_zipkin_default_endpoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name, <span class="hljs-keyword">bool</span> service_name_copy, <span class="hljs-keyword">struct</span> in_addr host
                             <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port)</span>
</span></code></pre>
<ul>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
<li><code>host</code> The IPv4 host address of theservice.</li>
<li><code>port</code> The IP port of the service.</li>
</ul>
<p>mtev_zipkin_default_endpoint sets a default endpoint for any new spans created without their own default.  Use this with care, it is application global.  You should likely only call this once at startup.</p>
<h4 id="mtevzipkinencode">mtev_zipkin_encode</h4>
<blockquote>
<p>Encode a span into the specified buffer for Zipkin.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">size_t</span> 
mtev_zipkin_encode(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *buffer, <span class="hljs-keyword">size_t</span> len, Zipkin_Span *span)
</code></pre>
<ul>
<li><code>buffer</code> The target buffer.</li>
<li><code>len</code> The target buffer&apos;s size.</li>
<li><code>span</code> The span to encode.</li>
<li><strong>RETURN</strong> The length of a successful encoding.</li>
</ul>
<p>mtev_zipkin_encode will take a span and encode it for Zipkin using the Thift BinaryProtocol.  The return value is always the length of a successful encoding, even if the buffer supplied is too small.  The caller must check the the returned length is less than or equal to the provided length to determine whether the encoding was successful.  The caller may provide a NULL buffer if and only if the provided len is 0.</p>
<h4 id="mtevzipkinsampling">mtev_zipkin_sampling</h4>
<blockquote>
<p>Set sampling probabilities for different types of traces.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_zipkin_sampling</span><span class="hljs-params">(<span class="hljs-keyword">double</span> new_traces, <span class="hljs-keyword">double</span> parented_traces, <span class="hljs-keyword">double</span> debug_traces)</span>
</span></code></pre>
<ul>
<li><code>new_traces</code> probability of createing a new trace (trace_id == NULL)</li>
<li><code>parented_traces</code> probability of createing a parented trace (parent_span_id == NULL)</li>
<li><code>debug_traces</code> probability of createing a debug trace (debug != NULL &amp;&amp; *debug)</li>
</ul>
<p>mtev_zipkin_sampling sets sampling probabilities for creating new traces. Default values are 1.0</p>
<h4 id="mtevzipkinspanannotate">mtev_zipkin_span_annotate</h4>
<blockquote>
<p>Annotate a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_Annotation * 
<span class="hljs-title">mtev_zipkin_span_annotate</span><span class="hljs-params">(Zipkin_Span *span, int64_t *timestamp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *value, <span class="hljs-keyword">bool</span> value_copy)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to annotate.</li>
<li><code>timestamp</code> A pointer the number of microseconds since epoch. NULL means now.</li>
<li><code>value</code> The annotation value itself.</li>
<li><code>value_copy</code> Whether value should be allocated (copied) within the span.</li>
<li><strong>RETURN</strong> A new annotation.</li>
</ul>
<p>mtev_zipkin_span_annotate make an annotation on the provided span.  The returned resource is managed by the span and will be released with it.</p>
<h4 id="mtevzipkinspanbannotate">mtev_zipkin_span_bannotate</h4>
<blockquote>
<p>Annotate a span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_BinaryAnnotation * 
<span class="hljs-title">mtev_zipkin_span_bannotate</span><span class="hljs-params">(Zipkin_Span *span, Zipkin_AnnotationType annotation_type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, 
                           <span class="hljs-keyword">bool</span> key_copy, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *value, int32_t value_len, <span class="hljs-keyword">bool</span> value_copy)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to annotate.</li>
<li><code>annotation_type</code> The type of the value being passed in.</li>
<li><code>key</code> The key for the annotation</li>
<li><code>key_copy</code> Whether key should be allocated (copied) within the span.</li>
<li><code>value</code> The pointer to a value for the annotation.</li>
<li><code>value_len</code> The length (in memory) of the binary value.</li>
<li><code>value_copy</code> Whether value should be allocated (copied) within the span.</li>
<li><strong>RETURN</strong> A new binary annotation.</li>
</ul>
<p>mtev_zipkin_span_bannotate make a binary annotation on the provided span.  The returned resource is managed by the span and will be released with it.</p>
<h4 id="mtevzipkinspandefaultendpoint">mtev_zipkin_span_default_endpoint</h4>
<blockquote>
<p>Sets the default endpoint used for new annotations within the span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_zipkin_span_default_endpoint</span><span class="hljs-params">(Zipkin_Span *span, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service_name, <span class="hljs-keyword">bool</span> service_name_copy, 
                                  <span class="hljs-keyword">struct</span> in_addr host, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> port)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to update.</li>
<li><code>service_name</code> The service name to use.</li>
<li><code>service_name_copy</code> Whether service_name should be allocated (copied) within the span.</li>
<li><code>host</code> The IPv4 host address of theservice.</li>
<li><code>port</code> The IP port of the service.</li>
</ul>
<p>mtev_zipkin_span_default_endpoint sets a default endpoint for any annotations or binary_annotations added to the span.  All annotations added without an endpoint will use the last default set on the span.</p>
<h4 id="mtevzipkinspandrop">mtev_zipkin_span_drop</h4>
<blockquote>
<p>Release resources allociated with span without publishing.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_zipkin_span_drop</span><span class="hljs-params">(Zipkin_Span *span)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to release.</li>
</ul>
<p>mtev_zipkin_span_drop releases all resources associated with the span.</p>
<h4 id="mtevzipkinspannew">mtev_zipkin_span_new</h4>
<blockquote>
<p>Allocate a new tracing span.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function">Zipkin_Span * 
<span class="hljs-title">mtev_zipkin_span_new</span><span class="hljs-params">(int64_t *trace_id, int64_t *parent_span_id, int64_t *span_id, 
                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">bool</span> name_copy, <span class="hljs-keyword">bool</span> debug, <span class="hljs-keyword">bool</span> force)</span>
</span></code></pre>
<ul>
<li><code>trace_id</code> A pointer to the trace_id, if NULL, one will be assigned.</li>
<li><code>parent_span_id</code> A point to the span&apos;s parent_id (NULL is originating).</li>
<li><code>span_id</code> A pointer to the span&apos;s id (NULL will imply that trace_id should be used).</li>
<li><code>name</code> A name for this span.</li>
<li><code>name_copy</code> Wether the name should be allocated (copied) within the span.</li>
<li><code>debug</code> Pointer to whether this is a debug span (bypasses any sampling), NULL allowed.</li>
<li><code>force</code> force the span to be created as if all probabilities were 1.</li>
<li><strong>RETURN</strong> A new span.</li>
</ul>
<p>mtev_zipkin_span_new allocates a new span in the system. The caller must eventually release the span via a call to either mtev_zipkin_span_drop or mtev_zipkin_span_publish.</p>
<h4 id="mtevzipkinspanpublish">mtev_zipkin_span_publish</h4>
<blockquote>
<p>Pulish then release resources allociated with span without publishing.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> 
<span class="hljs-title">mtev_zipkin_span_publish</span><span class="hljs-params">(Zipkin_Span *span)</span>
</span></code></pre>
<ul>
<li><code>span</code> The span to publish and release.</li>
</ul>
<p>mtev_zipkin_span_publish first publishes, then releases all resources associated with the span.</p>
<h4 id="mtevzipkinstrtoid">mtev_zipkin_str_to_id</h4>
<blockquote>
<p>Convert a string Id to an int64_t Id.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span> * 
mtev_zipkin_str_to_id(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *in, <span class="hljs-keyword">int64_t</span> *buf)
</code></pre>
<ul>
<li><code>in</code> Id in string form</li>
<li><code>buf</code> working buffer (must not be NULL)</li>
<li><strong>RETURN</strong> pointer to translated id</li>
</ul>
<p>mtev_zipkin_str_to_id will take string form id (trace_id, parent_span_id, or span_id) and convert it to an int64_t.  If conversion fails, the function will return NULL.</p>
<h4 id="mtevzipkintimevaltotimestamp">mtev_zipkin_timeval_to_timestamp</h4>
<blockquote>
<p>Convert a struct timeval to a timestamp.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-keyword">int64_t</span> 
mtev_zipkin_timeval_to_timestamp(<span class="hljs-keyword">struct</span> timeval *tv)
</code></pre>
<ul>
<li><code>tv</code> A point to a struct timeval representing the time in question.</li>
<li><strong>RETURN</strong> a timestamp suitable for use in annotations.</li>
</ul>
<p>mtev_zipkin_timeval_to_timestamp wil convert a struct timeval (e.g. from gettimeofday) to a the &quot;microseconds since epoch&quot; format expected by Zipkin.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Reference">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="lua.html" class="navigation navigation-next " aria-label="Next page: Lua API">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"C API","level":"1.5.1","depth":2,"next":{"title":"Lua API","level":"1.5.2","depth":2,"path":"apireference/lua.md","ref":"apireference/lua.md","articles":[]},"previous":{"title":"Reference","level":"1.5","depth":1,"path":"apireference/README.md","ref":"apireference/README.md","articles":[{"title":"C API","level":"1.5.1","depth":2,"path":"apireference/c.md","ref":"apireference/c.md","articles":[]},{"title":"Lua API","level":"1.5.2","depth":2,"path":"apireference/lua.md","ref":"apireference/lua.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["collapsible-menu","callouts","anchorjs"],"root":"./docs-md","styles":{"website":"styles/website.css"},"pluginsConfig":{"collapsible-menu":{},"callouts":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"fontSettings":{"theme":"night","family":"sans"},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"apireference/c.md","mtime":"","type":"markdown"},"gitbook":{"version":"3.2.2","time":""},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-collapsible-menu/plugin.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

